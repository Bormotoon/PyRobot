
FILE START: __init__.py


FILE END: __init__.py

FILE START: ast_evaluator.py

# FILE START: ast_evaluator.py
import ast
import logging
import operator
# Импортируем SAFE_GLOBALS из нового модуля
from .kumir_globals import SAFE_GLOBALS
from .robot_state import RobotError
logger = logging.getLogger('KumirAstEvaluator')
class EvaluationError(Exception):
	"""Ошибка во время вычисления AST."""
	pass
class SafeEvaluator(ast.NodeVisitor):
	"""
	Безопасный вычислитель AST для выражений Кумира.
	"""
	def __init__(self, env_vars, robot_sensors):
		"""
		Инициализация вычислителя.
		"""
		self.env = env_vars
		# Объединяем глобально разрешенные функции/константы с сенсорами робота
		self.allowed_callables = {**SAFE_GLOBALS, **robot_sensors}
		logger.debug(
			f"Evaluator initialized. Env keys: {list(env_vars.keys())}, Callables: {list(self.allowed_callables.keys())}")
	# Методы visit_... остаются без изменений, как в предыдущем ответе
	def visit(self, node):
		# ... (код без изменений) ...
		method_name = 'visit_' + node.__class__.__name__
		visitor = getattr(self, method_name, self.generic_visit)
		logger.debug(f"Visiting node: {node.__class__.__name__}, Method: {visitor.__name__}")
		try:
			return visitor(node)
		except EvaluationError:  # Пробрасываем ошибки EvaluationError
			raise
		except RobotError as e:  # Пробрасываем ошибки робота
			logger.warning(f"Robot error during evaluation: {e}")
			raise EvaluationError(f"Ошибка робота: {e}")  # Оборачиваем в EvaluationError
		except Exception as e:
			logger.error(f"Unexpected error visiting {node.__class__.__name__}: {e}", exc_info=True)
			raise EvaluationError(f"Неожиданная ошибка вычисления узла {node.__class__.__name__}: {e}")
	def generic_visit(self, node):
		# ... (код без изменений) ...
		logger.error(f"Unsupported AST node type encountered: {node.__class__.__name__}")
		raise EvaluationError(f"Неподдерживаемый тип узла AST: {node.__class__.__name__}")
	def visit_Expression(self, node):
		# ... (код без изменений) ...
		return self.visit(node.body)
	def visit_Constant(self, node):
		# ... (код без изменений) ...
		logger.debug(f"Visiting Constant: {node.value}")
		return node.value
	def visit_Name(self, node):
		# ... (код без изменений) ...
		name = node.id
		logger.debug(f"Visiting Name: {name}")
		# 1. Ищем в переменных окружения
		if name in self.env:
			logger.debug(f"Found '{name}' in env: {self.env[name]}")
			return self.env[name]
		# 2. Ищем в разрешенных глобальных функциях/константах/сенсорах
		if name in self.allowed_callables:
			logger.debug(f"Found '{name}' in allowed callables.")
			return self.allowed_callables[name]
		logger.error(f"Name '{name}' not found in env or allowed callables.")
		raise EvaluationError(f"Неизвестное имя: '{name}'")
	def visit_BinOp(self, node):
		# ... (код без изменений) ...
		logger.debug(f"Visiting BinOp: {type(node.op)}")
		left_val = self.visit(node.left)
		right_val = self.visit(node.right)
		logger.debug(f"BinOp operands: left={left_val} ({type(left_val)}), right={right_val} ({type(right_val)})")
		op_map = {
			ast.Add: operator.add, ast.Sub: operator.sub, ast.Mult: operator.mul,
			ast.Div: operator.truediv, ast.FloorDiv: operator.floordiv, ast.Mod: operator.mod,
			ast.Pow: operator.pow,
		}
		op_func = op_map.get(type(node.op))
		if op_func:
			try:
				result = op_func(left_val, right_val)
				logger.debug(f"BinOp result: {result}")
				return result
			except ZeroDivisionError:
				logger.error("Division by zero detected.")
				raise EvaluationError("Деление на ноль")
			except TypeError as e:
				logger.error(f"TypeError in BinOp: {e}")
				raise EvaluationError(f"Ошибка типа в операции {type(node.op).__name__}: {e}")
			except Exception as e:
				logger.error(f"Error in BinOp {type(node.op).__name__}: {e}", exc_info=True)
				raise EvaluationError(f"Ошибка в бинарной операции {type(node.op).__name__}: {e}")
		else:
			logger.error(f"Unsupported binary operator: {type(node.op)}")
			raise EvaluationError(f"Неподдерживаемый бинарный оператор: {type(node.op).__name__}")
	def visit_BoolOp(self, node):
		# ... (код без изменений) ...
		logger.debug(f"Visiting BoolOp: {type(node.op)}")
		results = []
		op_is_and = isinstance(node.op, ast.And)
		for value_node in node.values:
			val = self.visit(value_node)
			if op_is_and and not val:
				logger.debug("BoolOp (and) short-circuited to False")
				return False
			if not op_is_and and val:
				logger.debug("BoolOp (or) short-circuited to True")
				return True
			results.append(val)
		final_result = results[-1]
		logger.debug(f"BoolOp final result: {final_result}")
		return final_result
	def visit_UnaryOp(self, node):
		# ... (код без изменений) ...
		logger.debug(f"Visiting UnaryOp: {type(node.op)}")
		operand_val = self.visit(node.operand)
		logger.debug(f"UnaryOp operand: {operand_val} ({type(operand_val)})")
		if isinstance(node.op, ast.Not):
			result = not operand_val
			logger.debug(f"UnaryOp (Not) result: {result}")
			return result
		elif isinstance(node.op, ast.USub):
			try:
				result = -operand_val
				logger.debug(f"UnaryOp (USub) result: {result}")
				return result
			except TypeError as e:
				logger.error(f"TypeError in UnaryOp (USub): {e}")
				raise EvaluationError(f"Ошибка типа в унарном минусе: {e}")
		else:
			logger.error(f"Unsupported unary operator: {type(node.op)}")
			raise EvaluationError(f"Неподдерживаемый унарный оператор: {type(node.op).__name__}")
	def visit_Compare(self, node):
		# ... (код без изменений) ...
		logger.debug(f"Visiting Compare: ops={node.ops}")
		left_val = self.visit(node.left)
		results = []
		current_left = left_val
		for i, op in enumerate(node.ops):
			comparator_node = node.comparators[i]
			current_right = self.visit(comparator_node)
			logger.debug(f"Compare step {i}: left={current_left}, op={type(op).__name__}, right={current_right}")
			op_map = {
				ast.Eq: operator.eq, ast.NotEq: operator.ne, ast.Lt: operator.lt,
				ast.LtE: operator.le, ast.Gt: operator.gt, ast.GtE: operator.ge,
			}
			op_func = op_map.get(type(op))
			if op_func:
				try:
					result = op_func(current_left, current_right)
					results.append(result)
					current_left = current_right
				except TypeError as e:
					logger.error(f"TypeError in Compare: {e}")
					raise EvaluationError(f"Ошибка типа в сравнении {type(op).__name__}: {e}")
				except Exception as e:
					logger.error(f"Error in Compare {type(op).__name__}: {e}", exc_info=True)
					raise EvaluationError(f"Ошибка в сравнении {type(op).__name__}: {e}")
			else:
				logger.error(f"Unsupported comparison operator: {type(op)}")
				raise EvaluationError(f"Неподдерживаемый оператор сравнения: {type(op).__name__}")
		final_result = all(results)
		logger.debug(f"Compare final result: {final_result}")
		return final_result
	def visit_Call(self, node):
		# ... (код без изменений) ...
		logger.debug(f"Visiting Call: func={getattr(node.func, 'id', node.func)}")
		func_obj = self.visit(node.func)
		if not callable(func_obj):
			logger.error(f"Attempted to call non-callable object: {func_obj}")
			raise EvaluationError(f"Попытка вызова не функции: {getattr(node.func, 'id', '<неизвестно>')}")
		func_name = getattr(node.func, 'id', None)
		is_allowed = False
		if func_name:
			is_allowed = func_name in self.allowed_callables
		else:
			# Проверяем сам объект
			for allowed_name, allowed_val in self.allowed_callables.items():
				if func_obj is allowed_val:
					is_allowed = True
					func_name = allowed_name  # Нашли имя для логгирования
					break
		if not is_allowed:
			logger.error(f"Attempted to call disallowed function/object: {func_name or func_obj}")
			raise EvaluationError(f"Вызов функции '{func_name or '<неизвестный объект>'}' не разрешен.")
		args = [self.visit(arg) for arg in node.args]
		kwargs = {kw.arg: self.visit(kw.value) for kw in node.keywords}
		logger.debug(f"Calling function '{func_name or '<lambda/other>'}' with args: {args}, kwargs: {kwargs}")
		try:
			result = func_obj(*args, **kwargs)
			logger.debug(f"Call result: {result}")
			return result
		except RobotError as e:
			logger.warning(f"Robot error during function call '{func_name}': {e}")
			raise  # Пробрасываем ошибку робота
		except TypeError as e:
			logger.error(f"TypeError during function call '{func_name}': {e}")
			raise EvaluationError(f"Ошибка типа при вызове функции '{func_name}': {e}")
		except Exception as e:
			logger.error(f"Error during function call '{func_name}': {e}", exc_info=True)
			raise EvaluationError(f"Ошибка при вызове функции '{func_name}': {e}")
	# --- Запрещенные или опасные узлы ---
	def visit_Attribute(self, node):
		# ... (код без изменений) ...
		logger.error(f"Disallowed AST node: Attribute access (e.g., obj.attr)")
		raise EvaluationError("Доступ к атрибутам объектов запрещен.")
	def visit_Subscript(self, node):
		# ... (код без изменений) ...
		logger.debug(f"Visiting Subscript")
		value = self.visit(node.value)
		slice_val = self.visit(node.slice)
		index = slice_val
		logger.debug(f"Subscript: value={value}, index={index}")
		if isinstance(value, dict):
			try:
				result = value[index]
				logger.debug(f"Subscript result (dict access): {result}")
				return result
			except KeyError:
				logger.error(f"KeyError accessing dict with index {index}")
				raise EvaluationError(f"Ошибка доступа к таблице: элемент с индексом {index} не найден.")
			except TypeError as e:
				logger.error(f"TypeError during dict access with index {index}: {e}")
				raise EvaluationError(f"Ошибка типа при доступе к таблице: {e}")
		else:
			logger.error(f"Disallowed subscript access on type {type(value)}")
			raise EvaluationError(
				f"Доступ по индексу разрешен только для таблиц (словарей), не для {type(value).__name__}.")
	def visit_Lambda(self, node):  # ... и остальные запреты без изменений ...
		logger.error("Disallowed AST node: Lambda")
		raise EvaluationError("Создание lambda-функций запрещено.")
	def visit_ListComp(self, node):
		logger.error("Disallowed AST node: List Comprehension")
		raise EvaluationError("Генераторы списков запрещены.")
	def visit_DictComp(self, node):
		logger.error("Disallowed AST node: Dict Comprehension")
		raise EvaluationError("Генераторы словарей запрещены.")
	def visit_SetComp(self, node):
		logger.error("Disallowed AST node: Set Comprehension")
		raise EvaluationError("Генераторы множеств запрещены.")
	def visit_GeneratorExp(self, node):
		logger.error("Disallowed AST node: Generator Expression")
		raise EvaluationError("Выражения-генераторы запрещены.")
	def visit_Yield(self, node):
		logger.error("Disallowed AST node: Yield")
		raise EvaluationError("Использование yield запрещено.")
	def visit_YieldFrom(self, node):
		logger.error("Disallowed AST node: Yield From")
		raise EvaluationError("Использование yield from запрещено.")
	def visit_Await(self, node):
		logger.error("Disallowed AST node: Await")
		raise EvaluationError("Использование await запрещено.")
	def visit_AsyncFunctionDef(self, node):
		logger.error("Disallowed AST node: Async Function Definition")
		raise EvaluationError("Определение async-функций запрещено.")
	def visit_Import(self, node):
		logger.error("Disallowed AST node: Import")
		raise EvaluationError("Импорт модулей запрещен.")
	def visit_ImportFrom(self, node):
		logger.error("Disallowed AST node: Import From")
		raise EvaluationError("Импорт из модулей запрещен.")
# Можно добавить запрет на другие узлы по мере необходимости
# FILE END: ast_evaluator.py
FILE END: ast_evaluator.py

FILE START: builtins.py

"""
Реализация встроенных функций для языка KUMIR, предназначенных для преобразования числовых значений в их
строковые представления, а также для преобразования строк в числовые и логические значения.
"""
# --- Новые внутренние (на английском) имена функций ---
def int_to_str(number):
    """
    Возвращает строковое представление целого числа.
    Прототип KUMIR:
      алг лит цел_в_лит(цел число)
    Параметры:
      number (int): Целое число, которое необходимо преобразовать в строку.
    Возвращаемое значение:
      str: Строковое представление переданного числа.
    """
    # Преобразуем целое число в строку с помощью встроенной функции str()
    return str(number)
def float_to_str(number):
    """
    Возвращает строковое представление числа с плавающей точкой.
    Прототип KUMIR:
      алг лит вещ_в_лит(вещ число)
    Параметры:
      number (float): Число с плавающей точкой для преобразования в строку.
    Возвращаемое значение:
      str: Строковое представление переданного числа.
    """
    # Преобразуем число с плавающей точкой в строку
    return str(number)
def str_to_float(string, success):
    """
    Преобразует заданную строку в число с плавающей точкой.
    Если строка содержит корректное представление числа, возвращает (число, "да");
    иначе возвращает (0.0, "нет").
    Прототип KUMIR:
      алг вещ лит_в_вещ(лит строка, рез лог успех)
    Примечание:
      В данной реализации переменная success не изменяется в окружении, а возвращается в виде части кортежа.
      Пользовательский код должен обрабатывать возвращаемый кортеж соответствующим образом.
    Параметры:
      string (str): Строка для преобразования.
      success: Параметр, предназначенный для обозначения успешности преобразования (не используется напрямую).
    Возвращаемое значение:
      tuple: Кортеж (числовое значение, индикатор успеха в виде строки "да" или "нет").
    """
    try:
        result = float(string)
        # Если преобразование успешно, возвращаем результат и строку "да"
        return result, "да"
    except:
        # В случае ошибки возвращаем 0.0 и строку "нет"
        return 0.0, "нет"
def str_to_int(string, success):
    """
    Преобразует заданную строку в целое число.
    Если строка корректно представляет целое число, возвращает (число, "да");
    иначе возвращает (0, "нет").
    Прототип KUMIR:
      алг цел лит_в_цел(лит строка, рез лог успех)
    Параметры:
      string (str): Строка для преобразования.
      success: Параметр, предназначенный для обозначения успешности преобразования (не используется напрямую).
    Возвращаемое значение:
      tuple: Кортеж (целое число, индикатор успеха в виде строки "да" или "нет").
    """
    try:
        result = int(string)
        # Успешное преобразование: возвращаем число и "да"
        return result, "да"
    except:
        # В случае ошибки возвращаем 0 и "нет"
        return 0, "нет"
def Int(string, default):
    """
    Преобразует заданную строку в целое число.
    Если строка не является корректным представлением целого числа, возвращает значение по умолчанию.
    Прототип KUMIR:
      алг цел Цел(лит строка, цел по умолчанию)
    Параметры:
      string (str): Строка для преобразования в целое число.
      default (int): Значение по умолчанию, которое возвращается, если преобразование не удалось.
    Возвращаемое значение:
      int: Преобразованное целое число или значение по умолчанию.
    """
    try:
        return int(string)
    except:
        return default
def Float(string, default):
    """
    Преобразует заданную строку в число с плавающей точкой.
    Если строка не является корректным представлением числа с плавающей точкой, возвращает значение по умолчанию.
    Прототип KUMIR:
      алг вещ Вещ(лит строка, вещ по умолчанию)
    Параметры:
      string (str): Строка для преобразования в число с плавающей точкой.
      default (float): Значение по умолчанию, возвращаемое при ошибке преобразования.
    Возвращаемое значение:
      float: Преобразованное число с плавающей точкой или значение по умолчанию.
    """
    try:
        return float(string)
    except:
        return default
def Bool(string, default):
    """
    Преобразует заданную строку в логическое значение.
    Распознает следующие строки как True: "да", "1", "истина";
    как False: "нет", "0", "ложь".
    Если строка не соответствует ни одному из этих вариантов, возвращает значение по умолчанию.
    Прототип KUMIR:
      алг лог Лог(лит строка, лог по умолчанию)
    Параметры:
      string (str): Строка для преобразования в логическое значение.
      default (bool): Значение по умолчанию, если строка не соответствует ожидаемым вариантам.
    Возвращаемое значение:
      bool: Преобразованное логическое значение или значение по умолчанию.
    """
    # Приводим строку к нижнему регистру и удаляем лишние пробелы
    s = str(string).strip().lower()
    if s in ["да", "1", "истина"]:
        return True
    elif s in ["нет", "0", "ложь"]:
        return False
    else:
        return default
# --- Алиасы для обратной совместимости (имена, как указано в документации KUMIR) ---
цел_в_лит = int_to_str  # Алиас для преобразования целого числа в строку
вещ_в_лит = float_to_str  # Алиас для преобразования числа с плавающей точкой в строку
лит_в_вещ = str_to_float  # Алиас для преобразования строки в число с плавающей точкой
лит_в_цел = str_to_int  # Алиас для преобразования строки в целое число
Цел = Int  # Алиас для функции преобразования строки в целое число с значением по умолчанию
Вещ = Float  # Алиас для функции преобразования строки в число с плавающей точкой с значением по умолчанию
Лог = Bool  # Алиас для функции преобразования строки в логическое значение
FILE END: builtins.py

FILE START: constants.py

"""
Модуль констант для языка KUMIR.
Содержит набор зарезервированных ключевых слов, допустимых типов данных,
а также определяет максимальное значение для целых чисел.
"""
# RESERVED_KEYWORDS - множество зарезервированных ключевых слов,
# которые не могут быть использованы в качестве идентификаторов в KUMIR.
# Добавлены 'пауза' и 'стоп'
RESERVED_KEYWORDS = {
    "алг", "нач", "кон", "исп", "кон_исп", "дано", "надо", "арг", "рез",
    "аргрез", "знач", "цел", "вещ", "лог", "сим", "лит", "таб", "целтаб",
    "вещтаб", "логтаб", "симтаб", "литтаб", "и", "или", "не", "да", "нет",
    "утв", "выход", "ввод", "вывод", "нс", "если", "то", "иначе", "все",
    "выбор", "при", "нц", "кц", "кц_при", "раз", "пока", "для", "от", "до",
    "шаг", "пауза", "стоп"  # <--- ДОБАВЛЕНЫ ПАУЗА И СТОП
}
# ALLOWED_TYPES - множество допустимых типов данных в языке KUMIR.
ALLOWED_TYPES = {"цел", "вещ", "лог", "сим", "лит"}
# MAX_INT - максимальное значение для целых чисел, используемое в KUMIR.
MAX_INT = 2147483647
# МАКСЦЕЛ - алиас для MAX_INT, используется для обратной совместимости
# с документацией KUMIR.
МАКСЦЕЛ = MAX_INT
FILE END: constants.py

FILE START: declarations.py

# FILE START: declarations.py
"""
Модуль declarations.py
@description Обработка объявлений переменных, присваиваний, ввода/вывода.
             Работает с новой структурой env и использует методы интерпретатора
             для разрешения ссылок и обновления значений.
"""
import logging
import math
import re
import sys
# Импортируем нужные исключения из нового файла
from .kumir_exceptions import (DeclarationError, AssignmentError, InputOutputError,
                               KumirInputRequiredError, KumirExecutionError, KumirEvalError)
from .constants import ALLOWED_TYPES, MAX_INT
from .file_functions import get_default_output
from .identifiers import is_valid_identifier
# Импортируем safe_eval только для использования, а не для исключений
from .safe_eval import safe_eval
logger = logging.getLogger('KumirDeclarations')
# Определения классов исключений УДАЛЕНЫ отсюда
# Функции get_default_value, _validate_and_convert_value, parse_dimensions остаются без изменений
def get_default_value(kumir_type):
	"""Возвращает значение по умолчанию для заданного типа Кумира."""
	base_type = kumir_type.replace('таб', '')
	if base_type == "цел": return 0
	if base_type == "вещ": return 0.0
	if base_type == "лог": return False
	if base_type == "сим": return ""
	if base_type == "лит": return ""
	if kumir_type.endswith("таб"): return {}
	logger.warning(f"Requesting default value for unknown type '{kumir_type}'. Returning None.")
	return None
def _validate_and_convert_value(value, target_type, var_name_for_error):
	"""
	Проверяет и конвертирует значение к целевому типу KUMIR.
	"""
	is_target_table = target_type.endswith("таб")
	base_target_type = target_type[:-3] if is_target_table else target_type
	if base_target_type not in ALLOWED_TYPES:
		raise TypeError(f"Неподдерживаемый целевой тип '{target_type}' для '{var_name_for_error}'")
	if value is None:
		raise AssignmentError(f"Попытка присвоить неопределенное значение (None) переменной '{var_name_for_error}'.")
	if is_target_table:
		if not isinstance(value, dict):
			raise AssignmentError(
				f"Попытка присвоить значение типа '{type(value).__name__}' таблице '{var_name_for_error}'. Ожидался словарь (dict)."
			)
		return value
	try:
		if base_target_type == "цел":
			try:
				f_val = float(value)
				if f_val != int(f_val):
					raise ValueError("Дробное число нельзя присвоить целой переменной")
				converted_value = int(f_val)
			except ValueError:
				converted_value = int(value)
			if not (-MAX_INT - 1 <= converted_value <= MAX_INT):
				raise ValueError(f"Значение {converted_value} выходит за допустимый диапазон для типа 'цел'.")
		elif base_target_type == "вещ":
			converted_value = float(value)
			if not math.isfinite(converted_value):
				raise ValueError(f"Значение {converted_value} не является конечным числом для типа 'вещ'.")
		elif base_target_type == "лог":
			if isinstance(value, bool):
				converted_value = value
			elif isinstance(value, str):
				low_val = value.lower().strip()
				if low_val in ["да", "true", "1"]:
					converted_value = True
				elif low_val in ["нет", "false", "0"]:
					converted_value = False
				else:
					try:
						converted_value = (float(value) != 0)
					except ValueError:
						raise ValueError(f"Недопустимое логическое значение: '{value}'. Ожидалось да/нет или число.")
			elif isinstance(value, (int, float)):
				converted_value = (value != 0)
			else:
				converted_value = bool(value)
		elif base_target_type == "сим":
			converted_value = str(value)
			if len(converted_value) != 1:
				raise ValueError("Значение для типа 'сим' должно быть ровно одним символом.")
		elif base_target_type == "лит":
			converted_value = str(value)
		else:
			raise TypeError(f"Неожиданный базовый тип: {base_target_type}")
		return converted_value
	except (ValueError, TypeError) as e:
		raise AssignmentError(
			f"Ошибка преобразования значения '{value}' ({type(value).__name__}) к типу '{target_type}' для '{var_name_for_error}': {e}"
		)
	except Exception as e:
		logger.exception(f"Неожиданная ошибка при конвертации значения для '{var_name_for_error}'")
		raise AssignmentError(f"Неожиданная ошибка при преобразовании значения для '{var_name_for_error}': {e}")
def parse_dimensions(dim_spec_str):
	"""Парсит строку размерностей таблицы вида "нач1:кон1, нач2:кон2, ..."."""
	dimensions = []
	if not dim_spec_str: return dimensions
	parts = re.split(r'\s*,\s*', dim_spec_str.strip())
	for i, part in enumerate(parts):
		if not part: continue
		match = re.match(r"^\s*(-?\d+)\s*:\s*(-?\d+)\s*$", part)
		if not match: raise DeclarationError(
			f"Некорректный формат размерности #{i + 1}: '{part}'. Ожидался формат 'целое:целое'.")
		try:
			start_bound = int(match.group(1));
			end_bound = int(match.group(2))
			if start_bound > end_bound:
				raise DeclarationError(
					f"Начальная граница ({start_bound}) размерности #{i + 1} больше конечной ({end_bound}).")
			dimensions.append((start_bound, end_bound))
		except ValueError:
			raise DeclarationError(f"Границы размерности #{i + 1} ('{part}') не являются целыми числами.")
	return dimensions
# process_declaration, process_assignment, split_respecting_quotes, process_output, process_input
# остаются без изменений в своей логике, но теперь используют импортированные исключения.
def process_declaration(line, env):
	"""
	Обрабатывает строку объявления переменной или таблицы.
	Создает запись в env с новой структурой ('kind', 'type', 'value', ...).
	"""
	logger.debug(f"Processing declaration: '{line}'")
	match = re.match(r"^\s*(\S+)(?:\s+(таб))?(?:\s+(.*))?$", line.strip(), re.IGNORECASE)
	if not match: raise DeclarationError(f"Некорректный синтаксис объявления: '{line}'")
	type_kw_raw, is_table_kw, rest_of_line = match.groups()
	type_kw = type_kw_raw.lower()
	is_table = bool(is_table_kw)
	if type_kw not in ALLOWED_TYPES: raise DeclarationError(f"Неизвестный тип переменной: '{type_kw_raw}'")
	if not rest_of_line: raise DeclarationError(f"Отсутствуют имена переменных после типа '{type_kw_raw}'.")
	identifiers_raw = [ident.strip() for ident in rest_of_line.split(",") if ident.strip()]
	if not identifiers_raw: raise DeclarationError(f"Не найдены имена переменных в строке объявления: '{line}'")
	declared_count = 0
	for ident_raw in identifiers_raw:
		var_name = ident_raw
		dimension_bounds = None
		if is_table:
			dim_match = re.match(r"^\s*(\S.*?)\s*\[\s*(.+?)\s*\]\s*$", ident_raw)
			if dim_match:
				var_name = dim_match.group(1).strip()
				dim_spec_str = dim_match.group(2).strip()
				try:
					dimension_bounds = parse_dimensions(dim_spec_str)
					if not dimension_bounds: raise DeclarationError(
						f"Не указаны корректные размерности для таблицы '{var_name}'.")
					logger.debug(f"Parsed dimensions for table '{var_name}': {dimension_bounds}")
				except DeclarationError as dim_err:
					raise DeclarationError(f"Ошибка в размерностях таблицы '{var_name}': {dim_err}")
			else:
				raise DeclarationError(f"Для таблицы '{ident_raw}' не указаны размерности в квадратных скобках.")
		elif "[" in ident_raw or "]" in ident_raw:
			raise DeclarationError(f"Неожиданные скобки '[]' в объявлении переменной (не таблицы): '{ident_raw}'")
		if not is_valid_identifier(var_name, ""): raise DeclarationError(
			f"Недопустимое имя переменной/таблицы: '{var_name}'")
		if var_name in env: raise DeclarationError(f"Переменная или таблица '{var_name}' уже объявлена.")
		env[var_name] = {"kind": "value", "type": type_kw, "is_table": is_table,
		                 "dimensions": dimension_bounds if is_table else None,
		                 "value": {} if is_table else get_default_value(type_kw)}
		declared_count += 1
		kind_str = "таблица" if is_table else "переменная";
		dim_str = f" с размерностями {dimension_bounds}" if is_table else ""
		logger.info(f"Declared {kind_str} '{var_name}' (base type '{type_kw}'{dim_str}).")
	return declared_count > 0
def process_assignment(line, interpreter):
	"""
	Обрабатывает строку присваивания (:=).
	Использует interpreter.update_variable_value для записи значения.
	"""
	logger.debug(f"Processing assignment: '{line}'")
	parts = line.split(":=", 1);
	if len(parts) != 2: raise AssignmentError(f"Неверный синтаксис присваивания (ожидалось :=): {line}")
	left_raw = parts[0].strip()
	right_expr = parts[1].strip()
	if not left_raw: raise AssignmentError("Отсутствует переменная слева от ':='.")
	if not right_expr: raise AssignmentError("Отсутствует выражение справа от ':='.")
	try:
		# Передаем текущее окружение и интерпретатор в safe_eval
		current_env = interpreter.get_env_by_index(interpreter.get_current_env_index())
		rhs_value = safe_eval(right_expr, current_env, interpreter.robot, interpreter)
		logger.debug(f"Evaluated RHS '{right_expr}' -> {rhs_value} (type: {type(rhs_value)})")
	except KumirEvalError as e:
		raise KumirEvalError(f"Ошибка вычисления правой части присваивания ('{right_expr}'): {e}")
	except Exception as e:
		logger.error(f"Unexpected error evaluating RHS '{right_expr}': {e}", exc_info=True)
		raise KumirEvalError(f"Неожиданная ошибка при вычислении '{right_expr}': {e}")
	target_var_name = left_raw
	indices = None
	table_match = re.match(r"^([a-zA-Zа-яА-ЯёЁ_][a-zA-Zа-яА-ЯёЁ0-9_\s]*?)\[(.+)\]$", left_raw)
	if table_match:
		target_var_name = table_match.group(1).strip()
		indices_expr_str = table_match.group(2).strip()
		logger.debug(f"Assignment target is table element: '{target_var_name}', indices expr: '{indices_expr_str}'")
		index_tokens = split_respecting_quotes(indices_expr_str, delimiter=',', quote_char='"')
		if not index_tokens: raise AssignmentError(f"Не указаны индексы для таблицы '{target_var_name}'.")
		evaluated_indices = []
		try:
			current_env = interpreter.get_env_by_index(interpreter.get_current_env_index())
			for token in index_tokens:
				idx_val = safe_eval(token.strip(), current_env, interpreter.robot, interpreter)
				try:
					evaluated_indices.append(int(idx_val))
				except (ValueError, TypeError):
					raise KumirEvalError(f"Индекс '{token}' (= {idx_val}) не является целым числом.")
			indices = tuple(evaluated_indices)
			logger.debug(f"Evaluated indices: {indices}")
		except KumirEvalError as e:
			raise KumirEvalError(f"Ошибка вычисления индексов '{indices_expr_str}': {e}")
		except Exception as e:
			logger.error(f"Unexpected error evaluating indices '{indices_expr_str}': {e}", exc_info=True)
			raise KumirEvalError(f"Неожиданная ошибка при вычислении индексов: {e}")
	else:
		logger.debug(f"Assignment target is simple variable: '{target_var_name}'")
		if not is_valid_identifier(target_var_name, ""): raise AssignmentError(
			f"Недопустимое имя переменной слева от ':=': '{target_var_name}'")
	try:
		interpreter.update_variable_value(target_var_name, rhs_value, indices)
		logger.info(
			f"Assigned value {rhs_value} to '{target_var_name}'{f' with indices {indices}' if indices else ''}.")
	except (KumirExecutionError, AssignmentError, DeclarationError) as e:
		raise e
	except Exception as e:
		logger.exception(f"Unexpected error during variable update for '{target_var_name}'")
		raise KumirExecutionError(f"Неожиданная ошибка присваивания переменной '{target_var_name}': {e}")
def split_respecting_quotes(text, delimiter=',', quote_char='"'):
	"""Разделяет строку по разделителю, игнорируя разделители внутри кавычек."""
	parts = [];
	current_part = "";
	in_quotes = False;
	escape = False
	for char in text:
		if char == quote_char and not escape:
			in_quotes = not in_quotes;
			current_part += char
		elif char == delimiter and not in_quotes:
			parts.append(current_part.strip());
			current_part = ""
		else:
			current_part += char
		escape = (char == '\\' and not escape)
	parts.append(current_part.strip())
	return parts
def process_output(line, interpreter):
	""" Обрабатывает команду 'вывод'. """
	logger.debug(f"Processing output: '{line}'")
	content_part = line[len("вывод"):].strip();
	append_newline = True
	if content_part.lower().endswith(" нс"):
		content_part = content_part[:-len(" нс")].rstrip();
		append_newline = False
	elif content_part.lower() == "нс":
		content_part = ""; append_newline = False
	output_str_parts = []
	if content_part:
		parts_to_eval = split_respecting_quotes(content_part, delimiter=',', quote_char='"')
		logger.debug(f"Output parts to evaluate: {parts_to_eval}")
		for part_expr in parts_to_eval:
			part_expr_strip = part_expr
			try:
				current_env = interpreter.get_env_by_index(interpreter.get_current_env_index())
				value = safe_eval(part_expr_strip, current_env, interpreter.robot, interpreter)
				if isinstance(value, bool):
					output_str_parts.append("да" if value else "нет")
				elif value is None:
					output_str_parts.append("")
				else:
					output_str_parts.append(str(value))
				logger.debug(f"Evaluated output part '{part_expr_strip}' -> '{output_str_parts[-1]}'")
			except KumirEvalError as e:
				logger.error(f"Error evaluating output part '{part_expr_strip}': {e}")
				raise InputOutputError(f"Ошибка вычисления '{part_expr_strip}' в 'вывод': {e}")
			except Exception as e:
				logger.exception(f"Unexpected error evaluating output part '{part_expr_strip}'")
				raise InputOutputError(f"Неожиданная ошибка в 'вывод' для '{part_expr_strip}': {e}")
	output_str = "".join(output_str_parts)
	if append_newline: output_str += "\n"
	if not hasattr(interpreter, 'output') or interpreter.output is None: interpreter.output = ""
	interpreter.output += output_str;
	output_str_escaped = output_str.replace('\n', '\\n').replace('\r', '\\r')
	logger.info(f"Appended to output buffer: '{output_str_escaped}'")
def process_input(line, interpreter):
	""" Обрабатывает команду 'ввод'. """
	logger.debug(f"Processing 'ввод': '{line}'.")
	var_name_raw = line[len("ввод"):].strip()
	if not var_name_raw: raise InputOutputError("Отсутствует имя переменной после 'ввод'.")
	var_name = var_name_raw;
	indices = None
	if '[' in var_name_raw:
		table_match = re.match(r"^([a-zA-Zа-яА-ЯёЁ_][a-zA-Zа-яА-ЯёЁ0-9_\s]*?)\[(.+)\]$", var_name_raw)
		if table_match:
			var_name = table_match.group(1).strip()
			indices_expr_str = table_match.group(2).strip()
			logger.warning(
				f"Input for table element '{var_name}[{indices_expr_str}]' requested, but not fully supported yet. Evaluating indices...")
			index_tokens = split_respecting_quotes(indices_expr_str, delimiter=',', quote_char='"')
			if not index_tokens: raise AssignmentError(f"Не указаны индексы для таблицы '{var_name}'.")
			evaluated_indices = []
			try:
				current_env = interpreter.get_env_by_index(interpreter.get_current_env_index())
				for token in index_tokens:
					idx_val = safe_eval(token.strip(), current_env, interpreter.robot, interpreter)
					try:
						evaluated_indices.append(int(idx_val))
					except (ValueError, TypeError):
						raise KumirEvalError(f"Индекс '{token}' (= {idx_val}) не является целым числом.")
				indices = tuple(evaluated_indices)
				logger.debug(f"Evaluated indices for input: {indices}")
			except KumirEvalError as e:
				raise InputOutputError(f"Ошибка вычисления индексов '{indices_expr_str}' в 'ввод': {e}")
			except Exception as e:
				raise InputOutputError(f"Неожиданная ошибка при вычислении индексов в 'ввод': {e}")
		else:
			raise InputOutputError(f"Некорректный синтаксис для ввода элемента таблицы: '{var_name_raw}'")
	if not is_valid_identifier(var_name, ""): raise InputOutputError(
		f"Недопустимое имя переменной для ввода: '{var_name}'")
	var_info = interpreter.get_variable_info(var_name)
	if var_info is None: raise DeclarationError(f"Переменная '{var_name}' не объявлена перед использованием в 'ввод'.")
	if var_info.get("is_table") and indices is None: raise InputOutputError(
		f"Команда 'ввод' не поддерживается для целых таблиц ('{var_name}'). Введите элемент таблицы.")
	target_type = var_info["type"]
	prompt = f"Введите значение для '{var_name_raw}' (тип: {target_type}): "
	logger.info(f"Input required for variable '{var_name_raw}' (type: {target_type}). Raising exception.")
	raise KumirInputRequiredError(var_name=var_name, prompt=prompt, target_type=target_type)
# FILE END: declarations.py
FILE END: declarations.py

FILE START: execution.py

# FILE START: execution.py
"""
Модуль execution.py
@description Реализует функции для выполнения управляющих конструкций
языка KUMIR (циклы, условия) и диспетчеризацию отдельных команд, включая вызовы алгоритмов.
Обновлен для работы с механизмом ссылок через interpreter и использует
исключения из kumir_exceptions.
"""
import copy
import logging
import re
import time
# Импортируем все нужные исключения
from .kumir_exceptions import (KumirExecutionError, DeclarationError, AssignmentError,
                               InputOutputError, KumirInputRequiredError, KumirEvalError,
                               RobotError)
from .constants import ALLOWED_TYPES
# Импортируем только нужные функции process_* из declarations
from .declarations import (process_declaration, process_assignment, process_output,
                           process_input, get_default_value, _validate_and_convert_value)
from .robot_commands import process_robot_command
from .safe_eval import safe_eval  # KumirEvalError импортирован выше
from .preprocessing import split_respecting_quotes
from .identifiers import is_valid_identifier
logger = logging.getLogger('KumirExecution')
MAX_INFINITE_LOOP_DURATION_S = 10
# --- Функции обработки управляющих конструкций ---
# Теперь принимают 'interpreter' для передачи его в safe_eval и execute_lines
def process_control_command(line, interpreter):
	"""Обрабатывает команды утв/дано/надо."""
	env = interpreter.get_env_by_index(interpreter.get_current_env_index())
	robot = interpreter.robot
	lower_line = line.lower().strip();
	keyword = None;
	expr = None
	for kw in ["утв", "дано", "надо"]:
		if lower_line.startswith(kw + " "):
			keyword = kw;
			expr = line[len(keyword):].strip();
			break
	if not keyword:
		if lower_line in ["утв", "дано", "надо"]: raise KumirExecutionError(
			f"Команда '{lower_line}' требует логическое выражение после себя.")
		return False
	if not expr: raise KumirExecutionError(f"Команда '{keyword}' требует логическое выражение после себя.")
	try:
		result = safe_eval(expr, env, robot, interpreter)
		logger.debug(f"Control '{keyword}' evaluated '{expr}' -> {result} (type: {type(result)})")
	except KumirEvalError as e:
		raise KumirEvalError(f"Ошибка вычисления выражения '{expr}' в команде '{keyword}': {e}")
	except Exception as e:
		logger.error(f"Unexpected error evaluating control expr '{expr}': {e}", exc_info=True); raise KumirEvalError(
			f"Неожиданная ошибка вычисления '{expr}' в '{keyword}': {e}")
	if isinstance(result, bool):
		condition = result
	elif isinstance(result, str):
		condition = result.strip().lower() == "да"
	else:
		try:
			condition = (float(result) != 0)
		except (ValueError, TypeError):
			condition = bool(result)
	if not condition:
		failure_reason = result if isinstance(result, (str, bool, int, float)) else type(result).__name__
		logger.warning(f"Control command failure: '{keyword} {expr}' evaluated to {failure_reason} (False)")
		raise KumirExecutionError(f"Отказ: условие '{expr}' в команде '{keyword}' ложно (результат: {failure_reason}).")
	else:
		logger.info(f"Control command success: '{keyword} {expr}' is True.")
		return True
def process_if_block(lines, start_index, interpreter, trace, progress_callback, phase_name, original_indices):
	"""Обрабатывает блок если-то-иначе-все."""
	env = interpreter.get_env_by_index(interpreter.get_current_env_index())
	robot = interpreter.robot
	n = len(lines);
	header_line_index = original_indices[start_index];
	header_line = lines[start_index].strip()
	if not header_line.lower().startswith("если"): raise KumirExecutionError(
		"Внутренняя ошибка: process_if_block вызван не для строки 'если'.", header_line_index, header_line)
	condition_expr = header_line[len("если"):].strip()
	if not condition_expr:
		if start_index + 1 < n and not lines[start_index + 1].lower().strip().startswith(("то", "иначе", "все")):
			logger.debug(
				f"Condition for 'если' seems to be on the next line. Reading line {original_indices[start_index + 1] + 1}")
			condition_expr = lines[start_index + 1].strip();
			start_index += 1
		else:
			raise KumirExecutionError(f"Отсутствует условие после 'если' на строке {header_line_index + 1}.",
			                          header_line_index, header_line)
	i = start_index + 1;
	series1_lines, series2_lines = [], [];
	series1_indices, series2_indices = [], []
	current_series, current_indices = None, None;
	found_then, found_else, end_if_index = False, False, -1
	while i < n:
		line_raw = lines[i];
		line = line_raw.strip();
		lower_line = line.lower();
		original_index_for_line = original_indices[i]
		if lower_line == "все":
			end_if_index = i; logger.debug(
				f"Found 'все' for 'если' at index {original_index_for_line + 1} (local index {i})"); break
		elif lower_line.startswith("то") and not found_then:
			found_then = True;
			current_series, current_indices = series1_lines, series1_indices
			content_after_then = line[len("то"):].strip()
			if content_after_then: current_series.append(content_after_then); current_indices.append(
				original_index_for_line)
			logger.debug(f"Found 'то' at index {original_index_for_line + 1}. Content after: '{content_after_then}'")
		elif lower_line.startswith("иначе") and found_then and not found_else:
			found_else = True;
			current_series, current_indices = series2_lines, series2_indices
			content_after_else = line[len("иначе"):].strip()
			if content_after_else: current_series.append(content_after_else); current_indices.append(
				original_index_for_line)
			logger.debug(f"Found 'иначе' at index {original_index_for_line + 1}. Content after: '{content_after_else}'")
		elif lower_line.startswith("иначе если") and found_then and not found_else:
			logger.warning(
				f"Detected 'иначе если' at line {original_index_for_line + 1}. Treating as start of 'иначе'.")
			found_else = True;
			current_series, current_indices = series2_lines, series2_indices
			current_series.append(line_raw);
			current_indices.append(original_index_for_line)
		else:
			if current_series is not None:
				current_series.append(line_raw); current_indices.append(original_index_for_line)
			elif not found_then:
				logger.debug(f"Line '{line}' appended to 'если' condition."); condition_expr += "\n" + line_raw
			else:
				logger.error(
					f"Unexpected line '{line}' at index {original_index_for_line + 1} during 'если' parsing."); raise KumirExecutionError(
					f"Неожиданная строка '{line}' при разборе блока 'если'.", original_index_for_line, line)
		i += 1
	if end_if_index == -1: raise KumirExecutionError(
		f"Не найден 'все' для блока 'если', начавшегося на строке {header_line_index + 1}.", header_line_index,
		header_line)
	if not found_then: raise KumirExecutionError(
		f"Не найдено 'то' в блоке 'если', начавшемся на строке {header_line_index + 1}.", header_line_index,
		header_line)
	logger.debug(f"Evaluating 'если' condition: '{condition_expr}'")
	try:
		cond_value = safe_eval(condition_expr, env, robot, interpreter)
	except KumirEvalError as e:
		raise KumirEvalError(f"Ошибка вычисления условия '{condition_expr}' в 'если': {e}")
	except Exception as e:
		logger.error(f"Unexpected error evaluating 'если' condition '{condition_expr}': {e}",
		             exc_info=True); raise KumirEvalError(f"Неожиданная ошибка в условии 'если': {e}")
	if isinstance(cond_value, bool):
		cond_bool = cond_value
	elif isinstance(cond_value, str):
		cond_bool = cond_value.strip().lower() == "да"
	else:
		try:
			cond_bool = (float(cond_value) != 0)
		except (ValueError, TypeError):
			cond_bool = bool(cond_value)
	logger.info(f"'Если {condition_expr}' evaluated to {cond_bool}.")
	if cond_bool:
		if series1_lines:
			logger.debug(f"Executing 'то' block (lines {len(series1_lines)})."); execute_lines(series1_lines, env,
			                                                                                   robot, interpreter,
			                                                                                   trace, progress_callback,
			                                                                                   phase_name,
			                                                                                   series1_indices)
		else:
			logger.debug("Executing 'то' block (empty).")
	elif found_else:
		if series2_lines:
			logger.debug(f"Executing 'иначе' block (lines {len(series2_lines)})."); execute_lines(series2_lines, env,
			                                                                                      robot, interpreter,
			                                                                                      trace,
			                                                                                      progress_callback,
			                                                                                      phase_name,
			                                                                                      series2_indices)
		else:
			logger.debug("Executing 'иначе' block (empty).")
	else:
		logger.debug("Condition is false, no 'иначе' block to execute.")
	return end_if_index + 1
# --->>> ВОЗВРАЩАЕМ ОПРЕДЕЛЕНИЯ ФУНКЦИЙ ОБРАБОТКИ БЛОКОВ <<<---
def process_select_block(lines, start_index, interpreter, trace, progress_callback, phase_name, original_indices):
	"""Обрабатывает блок выбор-при-иначе-все."""
	env = interpreter.get_env_by_index(interpreter.get_current_env_index())
	robot = interpreter.robot
	n = len(lines);
	header_line_index = original_indices[start_index];
	header_line = lines[start_index].strip()
	if not header_line.lower() == "выбор": raise KumirExecutionError(
		"Внутренняя ошибка: process_select_block вызван не для 'выбор'.", header_line_index, header_line)
	i = start_index + 1;
	branches = [];
	else_series, else_indices = [], [];
	found_else = False;
	end_select_index = -1
	current_branch_dict, current_branch_lines, current_branch_indices = None, None, None
	while i < n:
		line_raw = lines[i];
		line = line_raw.strip();
		lower_line = line.lower();
		original_index_for_line = original_indices[i]
		if lower_line == "все":
			end_select_index = i; logger.debug(f"Found 'все' for 'выбор' at index {original_index_for_line + 1}"); break
		elif lower_line.startswith("при"):
			if found_else: raise KumirExecutionError("Обнаружена ветка 'при' после 'иначе' в блоке 'выбор'.",
			                                         original_index_for_line, line)
			parts = line.split(":", 1);
			if len(parts) != 2: raise KumirExecutionError(f"Отсутствует ':' после условия в ветке 'при': '{line}'",
			                                              original_index_for_line, line)
			cond_part = parts[0].strip();
			condition_expr = cond_part[len("при"):].strip()
			if not condition_expr: raise KumirExecutionError(f"Отсутствует условие после 'при' в строке: '{line}'",
			                                                 original_index_for_line, line)
			first_command = parts[1].strip();
			current_branch_dict = {"condition": condition_expr, "body": [], "indices": []}
			current_branch_lines, current_branch_indices = current_branch_dict["body"], current_branch_dict["indices"]
			if first_command: current_branch_lines.append(first_command); current_branch_indices.append(
				original_index_for_line)
			branches.append(current_branch_dict)
			logger.debug(
				f"Found 'при' branch (idx {len(branches) - 1}) with condition '{condition_expr}'. First command: '{first_command}'")
		elif lower_line.startswith("иначе"):
			if found_else: raise KumirExecutionError("Обнаружено повторное 'иначе' в блоке 'выбор'.",
			                                         original_index_for_line, line)
			if not branches: logger.warning("Блок 'иначе' найден до каких-либо веток 'при' в 'выбор'.")
			found_else = True;
			current_branch_dict = None;
			current_branch_lines, current_branch_indices = else_series, else_indices
			content_after_else = line[len("иначе"):].strip()
			if content_after_else: current_branch_lines.append(content_after_else); current_branch_indices.append(
				original_index_for_line)
			logger.debug(f"Found 'иначе' block. Content after: '{content_after_else}'")
		else:
			if current_branch_lines is not None:
				current_branch_lines.append(line_raw); current_branch_indices.append(original_index_for_line)
			else:
				raise KumirExecutionError(f"Неожиданная строка '{line}' внутри 'выбор' до начала веток 'при'/'иначе'.",
				                          original_index_for_line, line)
		i += 1
	if end_select_index == -1: raise KumirExecutionError(
		f"Не найден 'все' для блока 'выбор', начавшегося на строке {header_line_index + 1}.", header_line_index,
		header_line)
	if not branches and not found_else: logger.warning(
		"Конструкция 'выбор-все' не содержит веток 'при' или блока 'иначе'. Блок пуст.")
	executed = False
	for idx, branch in enumerate(branches):
		condition_expr, series, indices = branch["condition"], branch["body"], branch["indices"]
		logger.debug(f"Evaluating 'при' condition #{idx + 1}: {condition_expr}")
		try:
			cond_value = safe_eval(condition_expr, env, robot, interpreter)
		except KumirEvalError as e:
			raise KumirEvalError(f"Ошибка вычисления условия '{condition_expr}' в ветке 'при' блока 'выбор': {e}")
		except Exception as e:
			logger.error(f"Unexpected error evaluating 'при' condition '{condition_expr}': {e}",
			             exc_info=True); raise KumirEvalError(f"Неожиданная ошибка в условии 'при': {e}")
		if isinstance(cond_value, bool):
			cond_bool = cond_value
		elif isinstance(cond_value, str):
			cond_bool = cond_value.strip().lower() == "да"
		else:
			try:
				cond_bool = (float(cond_value) != 0)
			except (ValueError, TypeError):
				cond_bool = bool(cond_value)
		logger.info(f"'При {condition_expr}' evaluated to {cond_bool}.")
		if cond_bool:
			logger.debug(f"Executing 'при' branch #{idx + 1} (lines {len(series)}).")
			execute_lines(series, env, robot, interpreter, trace, progress_callback, phase_name, indices)
			executed = True;
			break
	if not executed and found_else:
		logger.debug(f"Executing 'иначе' block (lines {len(else_series)}).")
		execute_lines(else_series, env, robot, interpreter, trace, progress_callback, phase_name, else_indices)
	elif not executed:
		logger.debug("No 'при' branch matched and no 'иначе' block found.")
	return end_select_index + 1
def process_loop_for(lines, start_index, interpreter, trace, progress_callback, phase_name, original_indices):
	"""Обрабатывает цикл нц-для-от-до-шаг-кц."""
	env = interpreter.get_env_by_index(interpreter.get_current_env_index())
	robot = interpreter.robot
	n = len(lines);
	header_line_index = original_indices[start_index];
	header_line = lines[start_index].strip()
	match = re.match(
		r"нц\s+для\s+([a-zA-Zа-яА-ЯёЁ_][a-zA-Zа-яА-ЯёЁ0-9_]*)\s+от\s+(.+?)\s+до\s+(.+?)(?:\s+шаг\s+(.+))?$",
		header_line, re.IGNORECASE)
	if not match: raise KumirExecutionError(f"Неверный синтаксис заголовка цикла 'нц для': {header_line}",
	                                        header_line_index, header_line)
	var_name, start_expr, end_expr, step_expr = match.groups();
	step_expr = step_expr.strip() if step_expr else "1"
	logger.debug(f"Parsing 'нц для': var='{var_name}', from='{start_expr}', to='{end_expr}', step='{step_expr}'")
	i = start_index + 1;
	loop_body, body_indices = [], [];
	end_loop_index, nesting_level = -1, 0
	while i < n:
		line_raw = lines[i];
		line = line_raw.strip();
		lower_line = line.lower();
		original_index_for_line = original_indices[i]
		if lower_line.startswith("нц"):
			nesting_level += 1
		elif lower_line == "кц":
			if nesting_level == 0:
				end_loop_index = i; break
			else:
				nesting_level -= 1
		loop_body.append(line_raw);
		body_indices.append(original_index_for_line);
		i += 1
	if end_loop_index == -1: raise KumirExecutionError(
		f"Не найден 'кц' для цикла 'нц для', начавшегося на строке {header_line_index + 1}.", header_line_index,
		header_line)
	try:
		start_val_raw = safe_eval(start_expr, env, robot, interpreter);
		end_val_raw = safe_eval(end_expr, env, robot, interpreter);
		step_val_raw = safe_eval(step_expr, env, robot, interpreter)
		try:
			start_val, end_val, step_val = int(start_val_raw), int(end_val_raw), int(step_val_raw)
		except (ValueError, TypeError) as conv_e:
			raise KumirEvalError(
				f"Параметры цикла 'для' (начало, конец, шаг) должны быть целыми числами. Ошибка преобразования: {conv_e}")
	except KumirEvalError as e:
		raise KumirEvalError(f"Ошибка вычисления параметров цикла 'нц для': {e}")
	except Exception as e:
		logger.error(f"Unexpected error evaluating 'нц для' params: {e}", exc_info=True); raise KumirEvalError(
			f"Неожиданная ошибка в параметрах 'нц для': {e}")
	if step_val == 0: raise KumirExecutionError("Шаг в цикле 'нц для' не может быть равен нулю.", header_line_index,
	                                            header_line)
	# --- Управление переменной цикла ---
	original_value, was_declared = None, False
	var_info = interpreter.get_variable_info(var_name)  # Ищем в текущем и глобальном
	if var_info:
		was_declared = True
		if var_info.get("is_table"): raise KumirExecutionError(f"Переменная цикла '{var_name}' не может быть таблицей.",
		                                                       header_line_index, header_line)
		if var_info["type"] != "цел": logger.warning(
			f"Переменная цикла '{var_name}' имеет тип '{var_info['type']}', но будет использоваться как 'цел'.")
		original_value = interpreter.resolve_variable_value(var_name)  # Сохраняем текущее значение
		logger.debug(f"Loop variable '{var_name}' exists. Original value: {original_value}")
	else:
		# Если не объявлена, создаем временно в *текущем* окружении
		current_env = interpreter.get_env_by_index(interpreter.get_current_env_index())
		current_env[var_name] = {"kind": "value", "type": "цел", "value": None, "is_table": False, "dimensions": None,
		                         "_loop_temp": True}
		logger.debug(f"Loop variable '{var_name}' created temporarily for the loop.")
	current = start_val;
	logger.info(f"Starting 'нц для {var_name}' from {start_val} to {end_val} step {step_val}.");
	iteration_count = 0
	try:
		while True:
			if (step_val > 0 and current > end_val) or (step_val < 0 and current < end_val): break
			iteration_count += 1;
			# Обновляем значение переменной цикла через метод интерпретатора
			try:
				interpreter.update_variable_value(var_name, current)
			except KumirExecutionError as update_err:
				logger.error(
					f"Failed to update loop variable '{var_name}': {update_err}"); break  # Прерываем цикл при ошибке обновления
			logger.debug(f"'для {var_name}' iteration {iteration_count}, value = {current}")
			try:
				execute_lines(loop_body, env, robot, interpreter, trace, progress_callback, phase_name, body_indices)
			except KumirExecutionError as exit_e:
				if str(exit_e) == "Выход":
					logger.info(
						f"Команда 'выход' прервала цикл 'нц для {var_name}' на итерации {iteration_count}."); break
				else:
					raise exit_e
			current += step_val
	finally:
		# Восстанавливаем или удаляем переменную цикла
		var_info_final = interpreter.get_variable_info(var_name)
		if was_declared:
			if var_info_final:  # Если переменная все еще существует
				try:
					interpreter.update_variable_value(var_name, original_value); logger.debug(
						f"Restored original value for '{var_name}'.")
				except KumirExecutionError as restore_err:
					logger.error(f"Failed to restore original value for loop variable '{var_name}': {restore_err}")
			else:
				logger.warning(f"Loop variable '{var_name}' disappeared during loop execution.")
		elif var_info_final and var_info_final.get("_loop_temp"):
			# Удаляем временную переменную из текущего окружения
			current_env = interpreter.get_env_by_index(interpreter.get_current_env_index())
			if var_name in current_env:
				del current_env[var_name];
				logger.debug(f"Removed temporary loop variable '{var_name}'.")
	logger.info(f"Finished 'нц для {var_name}' after {iteration_count} iterations.")
	return end_loop_index + 1
def process_loop_while(lines, start_index, interpreter, trace, progress_callback, phase_name, original_indices):
	"""Обрабатывает цикл нц-пока-кц."""
	env = interpreter.get_env_by_index(interpreter.get_current_env_index())
	robot = interpreter.robot
	n = len(lines);
	header_line_index = original_indices[start_index];
	header_line = lines[start_index].strip()
	match = re.match(r"нц\s+пока\s+(.+)", header_line, re.IGNORECASE)
	if not match: raise KumirExecutionError(f"Неверный синтаксис заголовка цикла 'нц пока': {header_line}",
	                                        header_line_index, header_line)
	condition_expr = match.group(1).strip()
	if not condition_expr: raise KumirExecutionError("Отсутствует условие после 'нц пока'.", header_line_index,
	                                                 header_line)
	logger.debug(f"Parsing 'нц пока': condition='{condition_expr}'")
	i = start_index + 1;
	loop_body, body_indices = [], [];
	end_loop_index, nesting_level = -1, 0
	while i < n:
		line_raw = lines[i];
		line = line_raw.strip();
		lower_line = line.lower();
		original_index_for_line = original_indices[i]
		if lower_line.startswith("нц"):
			nesting_level += 1
		elif lower_line == "кц":
			if nesting_level == 0:
				end_loop_index = i; break
			else:
				nesting_level -= 1
		loop_body.append(line_raw);
		body_indices.append(original_index_for_line);
		i += 1
	if end_loop_index == -1: raise KumirExecutionError(
		f"Не найден 'кц' для цикла 'нц пока', начавшегося на строке {header_line_index + 1}.", header_line_index,
		header_line)
	logger.info(f"Starting 'нц пока {condition_expr}'.");
	iteration_count = 0
	while True:
		iteration_count += 1
		try:
			cond_value = safe_eval(condition_expr, env, robot, interpreter)
		except KumirEvalError as e:
			raise KumirEvalError(f"Ошибка вычисления условия '{condition_expr}' в цикле 'нц пока': {e}")
		except Exception as e:
			logger.error(f"Unexpected error evaluating 'нц пока' condition '{condition_expr}': {e}",
			             exc_info=True); raise KumirEvalError(f"Неожиданная ошибка в условии 'нц пока': {e}")
		if isinstance(cond_value, bool):
			cond_bool = cond_value
		elif isinstance(cond_value, str):
			cond_bool = cond_value.strip().lower() == "да"
		else:
			try:
				cond_bool = (float(cond_value) != 0)
			except (ValueError, TypeError):
				cond_bool = bool(cond_value)
		logger.debug(f"'пока {condition_expr}' (Iteration {iteration_count}) evaluated to {cond_bool}.")
		if not cond_bool: logger.debug("Condition is false, exiting 'нц пока'."); break
		try:
			execute_lines(loop_body, env, robot, interpreter, trace, progress_callback, phase_name, body_indices)
		except KumirExecutionError as exit_e:
			if str(exit_e) == "Выход":
				logger.info(f"Команда 'выход' прервала цикл 'нц пока' на итерации {iteration_count}."); break
			else:
				raise exit_e
	logger.info(f"Finished 'нц пока {condition_expr}' after {iteration_count - 1} successful iterations.")
	return end_loop_index + 1
def process_loop_n_times(lines, start_index, interpreter, trace, progress_callback, phase_name, original_indices):
	"""Обрабатывает цикл нц-N-раз-кц."""
	env = interpreter.get_env_by_index(interpreter.get_current_env_index())
	robot = interpreter.robot
	n = len(lines);
	header_line_index = original_indices[start_index];
	header_line = lines[start_index].strip()
	match = re.match(r"нц\s+(.+?)\s+раз", header_line, re.IGNORECASE)
	if not match: raise KumirExecutionError(f"Неверный синтаксис заголовка цикла 'нц N раз': {header_line}",
	                                        header_line_index, header_line)
	count_expr = match.group(1).strip();
	logger.debug(f"Parsing 'нц N раз': count_expr='{count_expr}'")
	try:
		count_raw = safe_eval(count_expr, env, robot, interpreter)
		try:
			count = int(count_raw)
		except (ValueError, TypeError):
			raise KumirEvalError(
				f"Количество повторений '{count_expr}' (вычислено как '{count_raw}') не является целым числом.")
	except KumirEvalError as e:
		raise KumirEvalError(f"Ошибка вычисления количества повторений '{count_expr}' в цикле 'нц N раз': {e}")
	except Exception as e:
		logger.error(f"Unexpected error evaluating 'N раз' count '{count_expr}': {e}",
		             exc_info=True); raise KumirEvalError(f"Неожиданная ошибка в количестве повторений 'нц N раз': {e}")
	if count < 0: logger.warning(
		f"Число повторений в 'нц {count} раз' отрицательное. Цикл не будет выполнен."); count = 0
	i = start_index + 1;
	loop_body, body_indices = [], [];
	end_loop_index, nesting_level = -1, 0
	while i < n:
		line_raw = lines[i];
		line = line_raw.strip();
		lower_line = line.lower();
		original_index_for_line = original_indices[i]
		if lower_line.startswith("нц"):
			nesting_level += 1
		elif lower_line == "кц":
			if nesting_level == 0:
				end_loop_index = i; break
			else:
				nesting_level -= 1
		loop_body.append(line_raw);
		body_indices.append(original_index_for_line);
		i += 1
	if end_loop_index == -1: raise KumirExecutionError(
		f"Не найден 'кц' для цикла 'нц N раз', начавшегося на строке {header_line_index + 1}.", header_line_index,
		header_line)
	logger.info(f"Starting 'нц {count} раз'.")
	for iteration in range(count):
		current_iteration = iteration + 1;
		logger.debug(f"'нц N раз' iteration {current_iteration}/{count}")
		try:
			execute_lines(loop_body, env, robot, interpreter, trace, progress_callback, phase_name, body_indices)
		except KumirExecutionError as exit_e:
			if str(exit_e) == "Выход":
				logger.info(f"Команда 'выход' прервала цикл 'нц N раз' на итерации {current_iteration}."); break
			else:
				raise exit_e
	logger.info(f"Finished 'нц {count} раз'.")
	return end_loop_index + 1
def process_loop_infinite(lines, start_index, interpreter, trace, progress_callback, phase_name, original_indices):
	"""Обрабатывает бесконечный цикл нц-кц."""
	env = interpreter.get_env_by_index(interpreter.get_current_env_index())
	robot = interpreter.robot
	n = len(lines);
	header_line_index = original_indices[start_index];
	header_line = lines[start_index].strip()
	if not header_line.lower() == "нц": raise KumirExecutionError(
		"Внутренняя ошибка: process_loop_infinite вызван не для 'нц'.", header_line_index, header_line)
	logger.debug("Parsing infinite 'нц' loop.")
	i = start_index + 1;
	loop_body, body_indices = [], [];
	end_loop_index, nesting_level = -1, 0
	while i < n:
		line_raw = lines[i];
		line = line_raw.strip();
		lower_line = line.lower();
		original_index_for_line = original_indices[i]
		if lower_line.startswith("нц"):
			nesting_level += 1
		elif lower_line == "кц":
			if nesting_level == 0:
				end_loop_index = i; break
			else:
				nesting_level -= 1
		loop_body.append(line_raw);
		body_indices.append(original_index_for_line);
		i += 1
	if end_loop_index == -1: raise KumirExecutionError(
		f"Не найден 'кц' для цикла 'нц', начавшегося на строке {header_line_index + 1}.", header_line_index,
		header_line)
	logger.info("Starting infinite 'нц' loop.");
	iteration_count = 0;
	start_time = time.time()
	while True:
		iteration_count += 1;
		logger.debug(f"Infinite 'нц' loop iteration {iteration_count}")
		current_time_exec = time.time()
		if current_time_exec - start_time > MAX_INFINITE_LOOP_DURATION_S: logger.error(
			f"Infinite loop 'нц' exceeded max duration ({MAX_INFINITE_LOOP_DURATION_S}s) after {iteration_count} iterations."); raise KumirExecutionError(
			f"Превышено максимальное время выполнения ({MAX_INFINITE_LOOP_DURATION_S}с) для цикла 'нц'.",
			header_line_index, header_line)
		try:
			execute_lines(loop_body, env, robot, interpreter, trace, progress_callback, phase_name, body_indices)
		except KumirExecutionError as exit_e:
			if str(exit_e) == "Выход":
				logger.info(f"Команда 'выход' прервала бесконечный цикл 'нц' на итерации {iteration_count}."); break
			else:
				raise exit_e
	logger.info(f"Finished infinite 'нц' loop after {iteration_count} iterations.")
	return end_loop_index + 1
# --- execute_lines и execute_line ---
# Теперь принимают 'interpreter' и передают его дальше
def execute_lines(lines, current_env_for_exec, robot, interpreter, trace, progress_callback, phase_name,
                  original_indices=None):
	""" Выполняет список строк кода Кумира. """
	n = len(lines);
	i = 0
	while i < n:
		line_content_raw = lines[i];
		line_content = line_content_raw.strip()
		current_original_index = original_indices[i] if original_indices and i < len(original_indices) else i
		if not line_content: i += 1; continue
		logger.debug(f"Preparing to execute line index {current_original_index + 1} ({phase_name}): '{line_content}'")
		state_before = None;
		output_before = interpreter.output;
		error_occurred = None
		processed_by_block = False;
		next_i_in_lines = i + 1
		try:
			lower_line = line_content.lower()
			is_if_block = lower_line.startswith("если");
			is_select_block = lower_line == "выбор";
			is_loop_block = lower_line.startswith("нц")
			if is_if_block or is_select_block or is_loop_block:
				processed_by_block = True;
				logger.debug(f"Processing block starting at line {current_original_index + 1}")
				state_before = interpreter.get_state()
				block_processor = None
				if is_if_block:
					block_processor = process_if_block
				elif is_select_block:
					block_processor = process_select_block
				elif is_loop_block:
					if re.match(r"нц\s+для", lower_line):
						loop_func = process_loop_for
					elif re.match(r"нц\s+пока", lower_line):
						loop_func = process_loop_while
					elif re.match(r"нц\s+.+?\s+раз", lower_line):
						loop_func = process_loop_n_times
					elif lower_line == "нц":
						loop_func = process_loop_infinite
					else:
						raise KumirExecutionError(f"Неизвестный синтаксис цикла 'нц'", current_original_index,
						                          line_content)
					block_processor = loop_func
				else:
					raise KumirExecutionError("Внутренняя ошибка: не найден обработчик блока", current_original_index,
					                          line_content)
				next_line_index_in_lines = block_processor(lines, i, interpreter, trace, progress_callback, phase_name,
				                                           original_indices)
				next_i_in_lines = next_line_index_in_lines
			else:
				processed_by_block = False;
				state_before = interpreter.get_state()
				# Передаем оригинальную строку с отступами
				execute_line(line_content_raw, interpreter, current_original_index)
		except KumirInputRequiredError as e:
			if not hasattr(e, 'line_index') or e.line_index is None: e.line_index = current_original_index
			if not hasattr(e, 'line_content') or e.line_content is None: e.line_content = line_content_raw
			error_occurred = e;
			raise e
		except (
		KumirExecutionError, KumirEvalError, RobotError, DeclarationError, AssignmentError, InputOutputError) as e:
			logger.error(
				f"Error executing line index {current_original_index + 1} ({phase_name}: '{line_content_raw}'): {e}",
				exc_info=False)
			error_occurred = e
			if not hasattr(e, 'line_index') or e.line_index is None: e.line_index = current_original_index
			if not hasattr(e, 'line_content') or e.line_content is None: e.line_content = line_content_raw
			raise e
		except Exception as e:
			logger.exception(
				f"Unexpected error executing line index {current_original_index + 1} ({phase_name}: '{line_content_raw}')")
			error_occurred = e;
			new_e = KumirExecutionError(f"Неожиданная внутренняя ошибка: {type(e).__name__}", current_original_index,
			                            line_content_raw);
			raise new_e from e
		finally:
			if not processed_by_block and state_before is not None:
				state_after = interpreter.get_state();
				output_after = interpreter.output
				trace_entry = {"phase": phase_name, "commandIndex": current_original_index, "command": line_content_raw,
				               "stateBefore": state_before, "stateAfter": state_after,
				               "outputDelta": output_after[len(output_before):]}
				if error_occurred: trace_entry["error"] = str(error_occurred)
				trace.append(trace_entry)
				if progress_callback:
					callback_data = {"phase": phase_name, "commandIndex": current_original_index,
					                 "output": output_after,
					                 "robotPos": state_after.get("robot") if state_after else None}
					if error_occurred: callback_data["error"] = str(error_occurred)
					try:
						progress_callback(callback_data)
					except Exception as cb_err:
						logger.error(f"Error in progress callback: {cb_err}", exc_info=True)
			i = next_i_in_lines
def execute_line(line_raw, interpreter, current_original_index):
	""" Выполняет одну строку кода Кумира. """
	line = line_raw.strip();
	logger.debug(f"Executing single line index {current_original_index + 1}: '{line}'");
	lower_line = line.lower()
	env = interpreter.get_env_by_index(interpreter.get_current_env_index());
	robot = interpreter.robot
	try:
		type_match = None
		for type_kw in ALLOWED_TYPES:
			if re.match(rf"^{type_kw}(\s+.*|$)", lower_line): type_match = type_kw; break
		if type_match:
			if process_declaration(line_raw, env): return
		if lower_line == "использовать робот": logger.info(
			"Ignoring 'использовать Робот' command in backend execution."); return
		if ":=" in line: process_assignment(line_raw, interpreter); return
		if lower_line.startswith("вывод"): process_output(line_raw, interpreter); return
		if lower_line.startswith("ввод"): process_input(line_raw, interpreter); return
		if lower_line.startswith(("утв ", "дано ", "надо ")):
			if process_control_command(line_raw, interpreter): return
		if lower_line == "стоп": logger.info("Execution stopped by 'стоп' command."); raise KumirExecutionError(
			"Выполнение прервано командой 'стоп'.")
		if lower_line == "выход": logger.info("Raising 'Выход' exception."); raise KumirExecutionError("Выход")
		if lower_line == "пауза" or lower_line.startswith("ждать "):
			logger.info(f"Command '{lower_line}' ignored by backend (handled by frontend animation).")
			if interpreter.progress_callback:
				try:
					interpreter.progress_callback({'phase': 'pause', 'commandIndex': current_original_index})
				except Exception as cb_err:
					logger.error(f"Error in pause progress callback: {cb_err}")
			return
		if process_robot_command(line, robot): return
		if process_algorithm_call(line_raw, interpreter, current_original_index): return
		logger.error(f"Unknown command or syntax error: '{line}'")
		raise KumirExecutionError(f"Неизвестная команда или синтаксическая ошибка.")
	except (KumirExecutionError, KumirEvalError, RobotError, DeclarationError, AssignmentError, InputOutputError,
	        KumirInputRequiredError) as e:
		if hasattr(e, 'line_index') and e.line_index is None: e.line_index = current_original_index
		if hasattr(e, 'line_content') and e.line_content is None: e.line_content = line_raw
		raise e
	except Exception as e:
		logger.exception(f"Unexpected error processing line index {current_original_index + 1}: '{line_raw}'")
		raise KumirExecutionError(f"Неожиданная ошибка: {e}", current_original_index, line_raw) from e
# FILE END: execution.py
FILE END: execution.py

FILE START: file_functions.py

# FILE START: file_functions.py
"""
Модуль file_functions.py
@description Реализует функции для работы с текстовыми файлами ВНУТРИ ПЕСОЧНИЦЫ.
Все пути, передаваемые в функции, проверяются и разрешаются относительно
безопасного базового каталога (песочницы).
"""
import logging
import os
import sys
from pathlib import Path  # Используем pathlib для удобной работы с путями
logger = logging.getLogger('KumirFileFunctions')
# --- Настройка Песочницы ---
# Определяем базовый каталог для песочницы.
# Путь строится относительно текущего файла (__file__) -> backend/kumir_interpreter -> backend -> kumir_sandbox
try:
	# Получаем абсолютный путь к каталогу, где находится этот файл
	current_dir = Path(__file__).parent.absolute()
	# Поднимаемся на один уровень (к каталогу backend)
	backend_dir = current_dir.parent
	# Создаем путь к каталогу песочницы
	SANDBOX_BASE_DIR = backend_dir / "kumir_sandbox"
	# Убедимся, что каталог существует, создаем его, если нет
	SANDBOX_BASE_DIR.mkdir(parents=True, exist_ok=True)
	# Сохраняем абсолютный путь как строку для сравнения префиксов
	SANDBOX_BASE_PATH_STR = str(SANDBOX_BASE_DIR)
	logger.info(f"File sandbox initialized at: {SANDBOX_BASE_PATH_STR}")
except Exception as e:
	logger.exception(f"CRITICAL: Failed to initialize file sandbox directory: {e}")
	# Если песочница не создана, дальнейшая работа опасна.
	# Можно либо остановить приложение, либо установить SANDBOX_BASE_DIR в None
	# и проверять это в _resolve_sandbox_path. Установим в None для явной ошибки.
	SANDBOX_BASE_DIR = None
	SANDBOX_BASE_PATH_STR = None  # raise RuntimeError(f"Failed to initialize file sandbox: {e}") # Можно раскомментировать для остановки
class SandboxError(Exception):
	"""Исключение для ошибок, связанных с выходом из песочницы."""
	pass
def _resolve_sandbox_path(user_path):
	"""
    Преобразует пользовательский путь в абсолютный путь внутри песочницы.
    Проверяет, что результирующий путь не выходит за пределы песочницы.
    Args:
        user_path (str): Путь, указанный пользователем (может быть относительным).
    Returns:
        Path: Объект Path с абсолютным путем внутри песочницы.
    Raises:
        SandboxError: Если путь выходит за пределы песочницы или песочница не инициализирована.
        TypeError: Если user_path не является строкой.
    """
	if SANDBOX_BASE_DIR is None or SANDBOX_BASE_PATH_STR is None:
		logger.critical("Sandbox base directory is not configured. File operations denied.")
		raise SandboxError("Файловая песочница не инициализирована.")
	if not isinstance(user_path, str):
		raise TypeError(f"Путь должен быть строкой, получен {type(user_path)}")
	# Создаем путь относительно базового каталога песочницы
	combined_path = SANDBOX_BASE_DIR / user_path
	# Получаем канонический абсолютный путь (разрешает '..', '.', симлинки)
	try:
		# Используем resolve() для получения реального пути в файловой системе
		# strict=True вызовет ошибку, если путь не существует (может быть не нужно для создания)
		# Поэтому используем abspath() для начального разрешения, а потом проверим префикс
		abs_path = combined_path.absolute()
		abs_path_str = str(abs_path)
	except Exception as e:
		# Ошибки могут возникнуть из-за слишком длинного имени, некорректных символов и т.д.
		logger.error(f"Error resolving path '{user_path}' relative to sandbox: {e}")
		raise SandboxError(f"Некорректный путь: '{user_path}'")
	# ГЛАВНАЯ ПРОВЕРКА: Убеждаемся, что абсолютный путь начинается с пути к песочнице
	# Это предотвращает выход из песочницы через '..' или абсолютные пути.
	if not abs_path_str.startswith(SANDBOX_BASE_PATH_STR):
		logger.warning(
			f"Path traversal attempt detected: User path '{user_path}' resolved to '{abs_path_str}', which is outside sandbox '{SANDBOX_BASE_PATH_STR}'.")
		raise SandboxError(f"Доступ запрещен: путь '{user_path}' выходит за пределы песочницы.")
	logger.debug(f"Resolved sandboxed path for '{user_path}' -> '{abs_path}'")
	return abs_path  # Возвращаем объект Path
# --- Глобальные настройки (без изменений) ---
_open_files = {}
_default_encoding = "UTF-8"
_default_input = None
_default_output = None
# Функция _normalize_encoding остается без изменений
def _normalize_encoding(enc):
	"""Нормализует имя кодировки."""
	# ... (код без изменений) ...
	enc = enc.replace("-", "").lower()
	if enc in ["cp1251", "windows1251", "windows"]:
		return "cp1251"
	elif enc in ["cp866", "ibm866", "dos"]:
		return "cp866"
	elif enc in ["koi8r", "koi8", "кои8", "кои8р"]:
		return "koi8-r"
	elif enc in ["utf8", "utf", "linux"]:
		return "utf-8"
	else:
		return None
# Функция set_encoding остается без изменений
def set_encoding(encoding_name):
	"""Устанавливает глобальную кодировку."""
	# ... (код без изменений) ...
	global _default_encoding
	norm = _normalize_encoding(encoding_name)
	if norm is None:
		raise Exception(f"Invalid encoding name: {encoding_name}")
	_default_encoding = norm
	logger.info(f"Default file encoding set to: {_default_encoding}")
	return "да"  # Возвращаем "да" для совместимости с Кумиром
# --- Модифицированные файловые функции ---
def open_for_reading(filename):
	"""
    Открывает текстовый файл ВНУТРИ ПЕСОЧНИЦЫ для чтения.
    """
	global _open_files, _default_encoding
	try:
		# Разрешаем путь внутри песочницы
		path_obj = _resolve_sandbox_path(filename)
		path_str = str(path_obj)
	except (SandboxError, TypeError) as e:
		raise Exception(f"Ошибка открытия файла для чтения '{filename}': {e}")
	if path_str in _open_files:
		raise Exception(f"Файл '{filename}' уже открыт.")
	# Используем path_obj для проверок и открытия
	if not path_obj.exists():
		raise Exception(f"Файл '{filename}' не найден в песочнице.")
	if not path_obj.is_file():
		raise Exception(f"Путь '{filename}' указывает на директорию, а не на файл.")
	if not os.access(path_str, os.R_OK):  # os.access все еще нужен для проверки прав
		raise Exception(f"Нет прав на чтение файла '{filename}'.")
	try:
		# Открываем файл с использованием path_obj (или path_str)
		f = open(path_obj, "r", encoding=_default_encoding)
		logger.info(f"Opened file '{filename}' (path: {path_str}) for reading.")
	except Exception as e:
		raise Exception(f"Ошибка при открытии файла '{filename}' для чтения: {e}")
	_open_files[path_str] = f
	return f
def open_for_writing(filename):
	"""
    Открывает текстовый файл ВНУТРИ ПЕСОЧНИЦЫ для записи ("w").
    """
	global _open_files, _default_encoding
	try:
		path_obj = _resolve_sandbox_path(filename)
		path_str = str(path_obj)
	except (SandboxError, TypeError) as e:
		raise Exception(f"Ошибка открытия файла для записи '{filename}': {e}")
	if path_str in _open_files:
		raise Exception(f"Файл '{filename}' уже открыт.")
	# Проверяем права на запись (или создание)
	parent_dir = path_obj.parent
	if path_obj.exists():
		if not path_obj.is_file():
			raise Exception(f"Путь '{filename}' указывает на директорию, запись невозможна.")
		if not os.access(path_str, os.W_OK):
			raise Exception(f"Нет прав на запись в файл '{filename}'.")
	elif not parent_dir.exists() or not os.access(str(parent_dir), os.W_OK):
		# Проверяем существование родительской директории и права на запись в нее
		raise Exception(
			f"Нет прав на создание файла '{filename}' в директории '{parent_dir.relative_to(SANDBOX_BASE_DIR)}'.")
	try:
		# Открываем файл в режиме записи
		f = open(path_obj, "w", encoding=_default_encoding)
		logger.info(f"Opened file '{filename}' (path: {path_str}) for writing.")
	except Exception as e:
		raise Exception(f"Ошибка при открытии файла '{filename}' для записи: {e}")
	_open_files[path_str] = f
	return f
def open_for_append(filename):
	"""
    Открывает текстовый файл ВНУТРИ ПЕСОЧНИЦЫ для добавления ("a").
    """
	global _open_files, _default_encoding
	try:
		path_obj = _resolve_sandbox_path(filename)
		path_str = str(path_obj)
	except (SandboxError, TypeError) as e:
		raise Exception(f"Ошибка открытия файла для добавления '{filename}': {e}")
	if path_str in _open_files:
		raise Exception(f"Файл '{filename}' уже открыт.")
	# Проверяем права на запись/создание (аналогично open_for_writing)
	parent_dir = path_obj.parent
	if path_obj.exists():
		if not path_obj.is_file():
			raise Exception(f"Путь '{filename}' указывает на директорию, добавление невозможно.")
		if not os.access(path_str, os.W_OK):
			raise Exception(f"Нет прав на запись (добавление) в файл '{filename}'.")
	elif not parent_dir.exists() or not os.access(str(parent_dir), os.W_OK):
		raise Exception(
			f"Нет прав на создание файла '{filename}' для добавления в директории '{parent_dir.relative_to(SANDBOX_BASE_DIR)}'.")
	try:
		# Открываем файл в режиме добавления
		f = open(path_obj, "a", encoding=_default_encoding)
		logger.info(f"Opened file '{filename}' (path: {path_str}) for appending.")
	except Exception as e:
		raise Exception(f"Ошибка при открытии файла '{filename}' для добавления: {e}")
	_open_files[path_str] = f
	return f
# Функция close_file остается почти без изменений, но использует имя файла из объекта f
def close_file(f):
	"""Закрывает ранее открытый файл."""
	global _open_files
	if not hasattr(f, 'name') or not f.name:
		raise Exception("Некорректный файловый объект передан для закрытия.")
	# Получаем абсолютный путь файла по его имени
	# Важно: имя файла в f.name уже должно быть абсолютным путем, который мы сохранили
	path_str = f.name
	if path_str not in _open_files:
		# Это может случиться, если файл был открыт не нашими функциями
		# или был закрыт ранее. Проверяем, начинается ли путь с песочницы для безопасности.
		if SANDBOX_BASE_PATH_STR and path_str.startswith(SANDBOX_BASE_PATH_STR):
			logger.warning(f"Attempting to close file '{f.name}' which was not tracked as open. Closing anyway.")
		else:
			# Попытка закрыть файл вне песочницы или некорректный путь
			logger.error(f"Attempting to close untracked or potentially unsafe file: '{f.name}'")
			raise Exception(f"Файл '{f.name}' не был найден среди открытых или находится вне песочницы.")
	try:
		f.close()
		logger.info(f"Closed file '{os.path.relpath(path_str, SANDBOX_BASE_PATH_STR)}' (path: {path_str}).")
	except Exception as e:
		# Удаляем из _open_files даже если закрытие вызвало ошибку,
		# чтобы не блокировать повторное открытие
		if path_str in _open_files:
			del _open_files[path_str]
		raise Exception(f"Ошибка при закрытии файла '{f.name}': {e}")
	# Удаляем запись об открытом файле только при успешном закрытии
	if path_str in _open_files:
		del _open_files[path_str]
# Функции reset_reading, eof, has_data остаются без изменений (работают с файловым объектом)
def reset_reading(f):
	"""Сбрасывает указатель файла f в начало файла."""
	# ... (код без изменений) ...
	try:
		f.seek(0)
	except Exception as e:
		raise Exception(f"Error resetting file pointer for '{f.name}': {e}")
def eof(f):
	"""Проверяет, достигнут ли конец файла."""
	# ... (код без изменений) ...
	try:
		cur = f.tell()
		f.seek(0, os.SEEK_END)
		end = f.tell()
		f.seek(cur)
		return "да" if cur >= end else "нет"
	except Exception as e:
		raise Exception(f"Error checking EOF for '{f.name}': {e}")
def has_data(f):
	"""Проверяет, имеется ли хотя бы один видимый символ после текущей позиции."""
	# ... (код без изменений) ...
	try:
		cur = f.tell()
		char = f.read(1)
		f.seek(cur)
		return "да" if char else "нет"
	except Exception as e:
		raise Exception(f"Error checking has_data for '{f.name}': {e}")
# --- Функции проверки ---
def can_open_for_reading(filename):
	"""Проверяет, существует ли файл ВНУТРИ ПЕСОЧНИЦЫ и доступен ли он для чтения."""
	try:
		path_obj = _resolve_sandbox_path(filename)
		# Проверяем существование, что это файл, и права на чтение
		if path_obj.exists() and path_obj.is_file() and os.access(str(path_obj), os.R_OK):
			return "да"
		else:
			return "нет"
	except (SandboxError, TypeError):
		return "нет"  # Если путь некорректен или вне песочницы, то открыть нельзя
	except Exception as e:
		logger.warning(f"Error in can_open_for_reading for '{filename}': {e}")
		return "нет"
def can_open_for_writing(filename):
	"""
    Проверяет, существует ли файл ВНУТРИ ПЕСОЧНИЦЫ и доступен ли для записи,
    либо может ли быть создан.
    """
	try:
		path_obj = _resolve_sandbox_path(filename)
		path_str = str(path_obj)
		parent_dir = path_obj.parent
		if path_obj.exists():
			# Файл существует: проверяем, что это файл и есть права на запись
			if path_obj.is_file() and os.access(path_str, os.W_OK):
				return "да"
			else:
				return "нет"
		else:
			# Файл не существует: проверяем, что родительская папка существует и есть права на запись в нее
			if parent_dir.exists() and parent_dir.is_dir() and os.access(str(parent_dir), os.W_OK):
				return "да"
			else:
				return "нет"
	except (SandboxError, TypeError):
		return "нет"
	except Exception as e:
		logger.warning(f"Error in can_open_for_writing for '{filename}': {e}")
		return "нет"
def exists(name):
	"""Проверяет, существует ли файл или директория с заданным именем ВНУТРИ ПЕСОЧНИЦЫ."""
	try:
		path_obj = _resolve_sandbox_path(name)
		return "да" if path_obj.exists() else "нет"
	except (SandboxError, TypeError):
		return "нет"
	except Exception as e:
		logger.warning(f"Error in exists for '{name}': {e}")
		return "нет"
def is_directory(name):
	"""Проверяет, является ли объект с заданным именем директорией ВНУТРИ ПЕСОЧНИЦЫ."""
	try:
		path_obj = _resolve_sandbox_path(name)
		# Проверяем существование перед проверкой на директорию
		return "да" if path_obj.exists() and path_obj.is_dir() else "нет"
	except (SandboxError, TypeError):
		return "нет"
	except Exception as e:
		logger.warning(f"Error in is_directory for '{name}': {e}")
		return "нет"
# --- Функции модификации ---
def create_directory(dirname):
	"""Создает директорию с заданным именем ВНУТРИ ПЕСОЧНИЦЫ."""
	try:
		path_obj = _resolve_sandbox_path(dirname)
		# exist_ok=True: не вызывать ошибку, если папка уже существует
		# parents=True: создавать родительские директории при необходимости
		path_obj.mkdir(parents=True, exist_ok=True)
		logger.info(f"Directory '{dirname}' (path: {path_obj}) created or already exists.")
		return "да"
	except (SandboxError, TypeError) as e:
		raise Exception(f"Ошибка создания директории '{dirname}': {e}")
	except Exception as e:
		raise Exception(f"Ошибка при создании директории '{dirname}': {e}")
def delete_file(filename):
	"""Удаляет файл с заданным именем ВНУТРИ ПЕСОЧНИЦЫ."""
	try:
		path_obj = _resolve_sandbox_path(filename)
		path_str = str(path_obj)
		# Дополнительная проверка перед удалением
		if not path_obj.exists():
			raise FileNotFoundError(f"Файл '{filename}' не найден для удаления.")
		if not path_obj.is_file():
			raise IsADirectoryError(f"Путь '{filename}' указывает на директорию, а не файл.")
		if path_str in _open_files:
			raise Exception(f"Нельзя удалить файл '{filename}', так как он открыт.")
		path_obj.unlink()  # Используем unlink для удаления файла
		logger.info(f"File '{filename}' (path: {path_obj}) deleted.")
		return "да"
	except (SandboxError, TypeError, FileNotFoundError, IsADirectoryError) as e:
		raise Exception(f"Ошибка удаления файла '{filename}': {e}")
	except Exception as e:
		raise Exception(f"Ошибка при удалении файла '{filename}': {e}")
def delete_directory(dirname):
	"""Удаляет ПУСТУЮ директорию с заданным именем ВНУТРИ ПЕСОЧНИЦЫ."""
	try:
		path_obj = _resolve_sandbox_path(dirname)
		if not path_obj.exists():
			raise FileNotFoundError(f"Директория '{dirname}' не найдена для удаления.")
		if not path_obj.is_dir():
			raise NotADirectoryError(f"Путь '{dirname}' указывает на файл, а не директорию.")
		# Проверяем, что директория пуста
		if any(path_obj.iterdir()):
			raise OSError(f"Директория '{dirname}' не пуста, удаление невозможно.")
		path_obj.rmdir()  # Удаляем директорию
		logger.info(f"Directory '{dirname}' (path: {path_obj}) deleted.")
		return "да"
	except (SandboxError, TypeError, FileNotFoundError, NotADirectoryError, OSError) as e:
		raise Exception(f"Ошибка удаления директории '{dirname}': {e}")
	except Exception as e:
		raise Exception(f"Ошибка при удалении директории '{dirname}': {e}")
# --- Функции получения путей (теперь возвращают пути внутри песочницы) ---
def full_path(name):
	"""
    Возвращает 'песочный' относительный путь для заданного имени.
    Показывает путь относительно базы песочницы.
    """
	try:
		path_obj = _resolve_sandbox_path(name)
		# Возвращаем путь относительно базы песочницы
		relative_path = path_obj.relative_to(SANDBOX_BASE_DIR)
		# Возвращаем как строку в стиле Unix (с '/')
		return str(relative_path).replace('\\', '/')
	except (SandboxError, TypeError) as e:
		# В случае ошибки возвращаем исходное имя или пустую строку?
		# Вернем исходное имя, как если бы разрешение не удалось.
		logger.warning(f"Could not resolve sandboxed full_path for '{name}': {e}")
		return name
	except Exception as e:
		logger.warning(f"Error in full_path for '{name}': {e}")
		return name
def WORKING_DIRECTORY():
	"""Возвращает путь к корневому каталогу песочницы."""
	if SANDBOX_BASE_PATH_STR:
		# Возвращаем просто '/', обозначая корень песочницы
		return "/"
	else:
		logger.error("Working directory requested but sandbox is not initialized.")
		return "./"  # Запасной вариант
def PROGRAM_DIRECTORY():
	"""Возвращает путь к корневому каталогу песочницы (аналогично WORKING_DIRECTORY)."""
	# В контексте песочницы нет разницы между рабочей папкой и папкой программы.
	return WORKING_DIRECTORY()
# --- Функции стандартного ввода/вывода ---
def set_input(filename):
	"""
    Устанавливает файл (ВНУТРИ ПЕСОЧНИЦЫ) или консоль в качестве источника ввода.
    """
	global _default_input, _default_encoding
	filename_strip = filename.strip()
	# Специальное имя для консоли
	if filename_strip.lower() == "консоль":
		if _default_input and _default_input is not sys.stdin:
			try:
				# Закрываем предыдущий файл, если он был открыт нами
				# Используем путь из f.name для удаления из _open_files
				close_file(_default_input)  # close_file обработает _open_files
			except Exception as e:
				logger.warning(f"Could not close previous default input '{_default_input.name}': {e}")
		_default_input = sys.stdin  # Стандартный ввод Python (input())
		logger.info("Default input set to console (stdin).")
		return "да"
	# Пустая строка - сброс на stdin
	if filename_strip == "":
		if _default_input and _default_input is not sys.stdin:
			try:
				close_file(_default_input)
			except Exception as e:
				logger.warning(f"Could not close previous default input '{_default_input.name}': {e}")
		_default_input = sys.stdin  # input()
		logger.info("Default input reset to console (stdin).")
		return "да"
	# Иначе - это имя файла в песочнице
	try:
		path_obj = _resolve_sandbox_path(filename_strip)
		path_str = str(path_obj)
	except (SandboxError, TypeError) as e:
		raise Exception(f"Ошибка установки файла ввода '{filename}': {e}")
	# Проверяем возможность чтения
	if can_open_for_reading(filename_strip) != "да":
		raise Exception(f"Файл '{filename}' не найден или недоступен для чтения в песочнице.")
	# Закрываем предыдущий файл ввода, если он был
	if _default_input and _default_input is not sys.stdin:
		try:
			close_file(_default_input)
		except Exception as e:
			logger.warning(f"Could not close previous default input '{_default_input.name}': {e}")
	try:
		# Открываем новый файл
		new_input_file = open(path_obj, "r", encoding=_default_encoding)
		_open_files[path_str] = new_input_file  # Регистрируем как открытый
		_default_input = new_input_file
		logger.info(f"Default input set to file '{filename_strip}' (path: {path_str}).")
		return "да"
	except Exception as e:
		raise Exception(f"Ошибка при открытии файла '{filename}' для ввода: {e}")
def set_output(filename):
	"""
    Устанавливает файл (ВНУТРИ ПЕСОЧНИЦЫ) или консоль в качестве места вывода.
    """
	global _default_output, _default_encoding
	filename_strip = filename.strip()
	# Специальное имя для консоли
	if filename_strip.lower() == "консоль":
		if _default_output and _default_output is not sys.stdout:
			try:
				close_file(_default_output)
			except Exception as e:
				logger.warning(f"Could not close previous default output '{_default_output.name}': {e}")
		_default_output = sys.stdout  # Стандартный вывод Python (print())
		logger.info("Default output set to console (stdout).")
		return "да"
	# Пустая строка - сброс на stdout
	if filename_strip == "":
		if _default_output and _default_output is not sys.stdout:
			try:
				close_file(_default_output)
			except Exception as e:
				logger.warning(f"Could not close previous default output '{_default_output.name}': {e}")
		_default_output = sys.stdout
		logger.info("Default output reset to console (stdout).")
		return "да"
	# Иначе - это имя файла в песочнице
	try:
		path_obj = _resolve_sandbox_path(filename_strip)
		path_str = str(path_obj)
	except (SandboxError, TypeError) as e:
		raise Exception(f"Ошибка установки файла вывода '{filename}': {e}")
	# Проверяем возможность записи
	if can_open_for_writing(filename_strip) != "да":
		raise Exception(f"Файл '{filename}' не может быть открыт или создан для записи в песочнице.")
	# Закрываем предыдущий файл вывода, если он был
	if _default_output and _default_output is not sys.stdout:
		try:
			close_file(_default_output)
		except Exception as e:
			logger.warning(f"Could not close previous default output '{_default_output.name}': {e}")
	try:
		# Открываем новый файл для записи (перезаписи!)
		new_output_file = open(path_obj, "w", encoding=_default_encoding)
		_open_files[path_str] = new_output_file  # Регистрируем
		_default_output = new_output_file
		logger.info(f"Default output set to file '{filename_strip}' (path: {path_str}).")
		return "да"
	except Exception as e:
		raise Exception(f"Ошибка при открытии файла '{filename}' для вывода: {e}")
# --- ConsoleFile и get_default_* остаются без изменений ---
class ConsoleFile:
	"""Псевдо-файл, связанный с терминалом (sys.stdin/sys.stdout)."""
	def __init__(self):
		self.name = "консоль"  # Имя для идентификации
		self.closed = False
		self._input_buffer = ""  # Для возможной буферизации ввода
	def write(self, s):
		"""Записывает строку в стандартный вывод."""
		if self.closed:
			raise Exception("Ошибка: Попытка записи в закрытый файл 'консоль'.")
		# Используем стандартный вывод
		# В веб-сервере это может не отображаться пользователю напрямую,
		# а перехватываться логгером или буферизироваться.
		# Если _default_output перенаправлен, запись пойдет туда.
		# Мы должны писать в sys.stdout, если хотим именно на консоль сервера.
		# print(s, end="", file=sys.stdout) # Явно в stdout сервера
		# Или используем текущий _default_output
		output_stream = get_default_output() or sys.stdout
		try:
			print(s, end="", file=output_stream, flush=True)
		except Exception as e:
			logger.error(
				f"Error writing to console/default output: {e}")  # Не бросаем исключение наверх, чтобы не прерывать программу из-за ошибки вывода
	def read(self, n=-1):
		"""
        Читает данные из стандартного ввода.
        ПРЕДУПРЕЖДЕНИЕ: Блокирует выполнение в ожидании ввода! Не использовать на сервере.
        """
		if self.closed:
			raise Exception("Ошибка: Попытка чтения из закрытого файла 'консоль'.")
		input_stream = get_default_input() or sys.stdin
		if input_stream is sys.stdin:
			# Чтение из реальной консоли (блокирующее!)
			logger.warning("Reading from console (stdin) requested. This is blocking!")
			try:
				line = input()  # Блокирующий вызов
				# В Кумире обычно читают построчно, добавим \n
				return line + "\n" if n == -1 or n >= len(line) + 1 else line[:n]
			except EOFError:
				return ""  # Конец ввода
		else:
			# Чтение из файла, установленного через set_input
			try:
				if n == -1:
					return input_stream.read()
				else:
					return input_stream.read(n)
			except Exception as e:
				logger.error(f"Error reading from default input file '{input_stream.name}': {e}")
				raise Exception(f"Ошибка чтения из файла ввода '{input_stream.name}': {e}")
	def seek(self, offset, whence=os.SEEK_SET):
		# Перемещение указателя для консоли не имеет смысла или невозможно
		logger.warning("Attempted to seek on console file. Operation ignored.")
		if whence == os.SEEK_SET and offset == 0: return  # Разрешим seek(0)
		raise OSError("Cannot seek on console file object.")
	def tell(self):
		# Позиция для консоли не определена
		logger.warning("Attempted to tell() on console file. Returning 0.")
		return 0
	def close(self):
		"""Закрытие 'консоли' невозможно."""
		# Мы не должны закрывать sys.stdin/sys.stdout
		# self.closed = True # Можно установить флаг, но лучше бросить ошибку
		raise Exception("Нельзя закрыть стандартный файл 'консоль'.")
	def __iter__(self):
		# Позволяет читать консоль построчно в цикле for (например)
		return self
	def __next__(self):
		# Читает следующую строку
		line = self.read()  # Используем наш read, который может читать из файла или stdin
		if line:
			# Убираем \n в конце, если он был добавлен нашим read() для stdin
			if (get_default_input() or sys.stdin) is sys.stdin and line.endswith('\n'):
				return line[:-1]
			return line
		else:
			raise StopIteration
def console_file():
	"""Возвращает объект, представляющий консоль."""
	return ConsoleFile()
def get_default_input():
	"""Возвращает текущий источник ввода по умолчанию (файл или sys.stdin)."""
	global _default_input
	return _default_input
def get_default_output():
	"""Возвращает текущий выходной поток по умолчанию (файл или sys.stdout)."""
	global _default_output
	return _default_output
# FILE END: file_functions.py
FILE END: file_functions.py

FILE START: identifiers.py

# FILE START: identifiers.py
import re
# --->>> ДОБАВЛЯЕМ ИМПОРТЫ ИЗ constants <<<---
from .constants import RESERVED_KEYWORDS, \
    ALLOWED_TYPES  # ALLOWED_TYPES может не использоваться здесь, но пусть будет для консистентности
def is_valid_identifier(identifier, var_type):
    """
    Проверяет корректность идентификатора с учетом типа переменной.
    """
    words = identifier.strip().split()
    if not words:
        return False
    # Проверяем, что первое слово не начинается с цифры
    first_word_match = re.match(r'^\d', words[0])
    if first_word_match:
        logger.debug(f"Identifier '{identifier}' rejected: first word '{words[0]}' starts with a digit.")
        return False
    for i, word in enumerate(words):
        word_lower = word.lower()
        # Проверка на зарезервированное слово
        if word_lower in RESERVED_KEYWORDS:
            # Исключение: 'не' допустимо для типа 'лог', если это не первое слово
            if var_type == "лог" and word_lower == "не" and i > 0:
                continue  # Допустимо 'лог переменная не простая'
            logger.debug(f"Identifier '{identifier}' rejected: word '{word}' is a reserved keyword.")
            return False
        # Проверка на допустимые символы (буквы, цифры, @, _) и начало слова
        if not re.match(r'^[A-Za-zА-Яа-яЁё@_][A-Za-zА-Яа-яЁё0-9@_]*$', word):
            logger.debug(
                f"Identifier '{identifier}' rejected: word '{word}' contains invalid characters or starts incorrectly.")
            return False
    # Если все проверки пройдены
    logger.debug(f"Identifier '{identifier}' is valid.")
    return True
# Функция convert_hex_constants остается без изменений
def convert_hex_constants(expr):
    """
    Заменяет шестнадцатеричные константы '$...' на формат Python '0x...'.
    """
    return re.sub(r'\$(?P<hex>[A-Fa-f0-9]+)', r'0x\g<hex>', expr)
# Добавим логгер, если его нет
import logging
logger = logging.getLogger('KumirIdentifiers')
# FILE END: identifiers.py
FILE END: identifiers.py

FILE START: interpreter.py

# FILE START: interpreter.py
import logging
import copy
import math # Добавлено для pow
import operator # Добавлено для операций
# Добавляем импорт TerminalNode
from antlr4.tree.Tree import TerminalNode 
# Импортируем все исключения из одного места
from .kumir_exceptions import (KumirExecutionError, DeclarationError, AssignmentError,
                               InputOutputError, KumirInputRequiredError, KumirEvalError,
                               RobotError)
# Импортируем остальные зависимости
from .declarations import (get_default_value, _validate_and_convert_value,
                           process_declaration, process_assignment, process_output,
                           process_input)  # Больше не импортируем исключения отсюда
from .execution import execute_lines  # Больше не импортируем KumirExecutionError отсюда
from .preprocessing import preprocess_code, separate_sections, parse_algorithm_header
from .robot_state import SimulatedRobot  # Больше не импортируем RobotError отсюда
from .generated.KumirVisitor import KumirVisitor
from .generated.KumirParser import KumirParser
from .generated.KumirLexer import KumirLexer # Импортируем лексер для имен токенов
# Добавляем ErrorListener
from antlr4.error.ErrorListener import ErrorListener
# Убрали импорт KumirEvalError из safe_eval
MAX_INT = 2147483647
МАКСЦЕЛ = MAX_INT
logger = logging.getLogger('KumirInterpreter')
# Словарь для маппинга токенов типа на строки
TYPE_MAP = {
    KumirLexer.K_CEL: 'цел',
    KumirLexer.K_VESH: 'вещ',
    KumirLexer.K_LOG: 'лог',
    KumirLexer.K_SIM: 'сим',
    KumirLexer.K_LIT: 'лит',
}
# Словари для операций
ARITHMETIC_OPS = {
    KumirLexer.PLUS: operator.add,
    KumirLexer.MINUS: operator.sub,
    KumirLexer.MUL: operator.mul,
    KumirLexer.DIV: operator.truediv, # Обычное деление -> вещ
    KumirLexer.K_DIV: operator.floordiv, # Целочисленное деление -> цел
    KumirLexer.K_MOD: operator.mod, # Остаток -> цел
    KumirLexer.POW: operator.pow,
}
COMPARISON_OPS = {
    KumirLexer.EQ: operator.eq,
    KumirLexer.NEQ: operator.ne,
    KumirLexer.LT: operator.lt,
    KumirLexer.GT: operator.gt,
    KumirLexer.LE: operator.le,
    KumirLexer.GE: operator.ge,
}
# Добавляем логические операции
LOGICAL_OPS = {
    KumirLexer.K_I: operator.and_,
    KumirLexer.K_ILI: operator.or_,
    # KumirLexer.K_NE handled in unaryExpr
}
# Класс для вывода подробных ошибок парсинга
class DiagnosticErrorListener(ErrorListener):
    def syntaxError(self, recognizer, offendingSymbol, line, column, msg, e):
        print(f"[DEBUG][Parser Error] Строка {line}:{column} около '{offendingSymbol.text if offendingSymbol else 'EOF'}' - {msg}")
def get_default_value(kumir_type):
    """Возвращает значение по умолчанию для данного типа Кумира."""
    if kumir_type == 'цел': return 0
    if kumir_type == 'вещ': return 0.0
    if kumir_type == 'лог': return False # В Кумире логические по умолчанию могут быть не инициализированы, но False безопаснее
    if kumir_type == 'сим': return ''    # Или может быть ошибка?
    if kumir_type == 'лит': return ""
    return None # Для таблиц или неизвестных типов
class KumirInterpreterVisitor(KumirVisitor):
    """Обходит дерево разбора Кумира и выполняет семантические действия."""
    def __init__(self):
        self.scopes = [{'global': {}}] # Стек областей видимости, [0] - глобальная
        self.current_scope_level = 0 # Уровень текущей области (0 - глобальная)
        # TODO: Добавить обработку возвращаемых значений функций
    # --- Управление областями видимости и символами ---
    def enter_scope(self):
        """Входит в новую локальную область видимости."""
        self.scopes.append({}) # Добавляем новый пустой словарь для локальной области
        self.current_scope_level += 1
        print(f"[DEBUG][Scope] Вошли в область уровня {self.current_scope_level}")
    def exit_scope(self):
        """Выходит из текущей локальной области видимости."""
        if self.current_scope_level > 0:
            print(f"[DEBUG][Scope] Вышли из области уровня {self.current_scope_level}")
            self.scopes.pop()
            self.current_scope_level -= 1
        else:
            print("[ERROR][Scope] Попытка выйти из глобальной области!")
    def declare_variable(self, name, kumir_type, is_table=False, dimensions=None):
        """Объявляет переменную в текущей области видимости."""
        current_scope = self.scopes[self.current_scope_level]
        if name in current_scope:
            # TODO: Использовать KumirExecutionError или DeclarationError
            raise Exception(f"Переменная '{name}' уже объявлена в этой области видимости.") 
        default_value = {} if is_table else get_default_value(kumir_type)
        current_scope[name] = {
            'type': kumir_type,
            'value': default_value,
            'is_table': is_table,
            'dimensions': dimensions if is_table else None
        }
        print(f"[DEBUG][Declare] Объявлена {'таблица' if is_table else 'переменная'} '{name}' тип {kumir_type} в области {self.current_scope_level}")
    def find_variable(self, name):
        """Ищет переменную, начиная с текущей области и поднимаясь к глобальной."""
        # Добавим проверку, что имя не пустое
        if not name or not isinstance(name, str):
             raise KumirEvalError(f"Некорректное имя переменной для поиска: {name}")
        for i in range(self.current_scope_level, -1, -1):
            scope = self.scopes[i]
            if name in scope:
                return scope[name], scope
        return None, None
    def update_variable(self, name, value):
        """Обновляет значение существующей переменной с проверкой типов."""
        var_info, scope = self.find_variable(name)
        if var_info is None:
            raise KumirExecutionError(f"Переменная '{name}' не найдена для присваивания.")
        if var_info['is_table']:
            # TODO: Обработка присваивания таблицам/элементам
            print(f"[WARN][Assign] Присваивание таблице '{name}' пока не реализовано.")
            pass # Пока ничего не делаем
        else:
            target_type = var_info['type']
            try:
                converted_value = self._validate_and_convert_value_for_assignment(value, target_type, name)
                var_info['value'] = converted_value
                print(f"[DEBUG][Assign] Переменной '{name}' присвоено значение: {converted_value} (тип: {type(converted_value).__name__})")
            except AssignmentError as e:
                # Перехватываем ошибку типа и добавляем контекст
                raise AssignmentError(f"Ошибка типа при присваивании переменной '{name}': {e}")
            except Exception as e:
                # Другие возможные ошибки
                raise KumirExecutionError(f"Ошибка при присваивании переменной '{name}': {e}")
    # --- Вспомогательные методы для проверки и конвертации типов при присваивании ---
    def _validate_and_convert_value_for_assignment(self, value, target_type, var_name="переменной"):
        """Проверяет тип значения и выполняет неявные преобразования для присваивания."""
        value_type = type(value)
        if target_type == 'цел':
            if value_type is int:
                # Проверка на МАКСЦЕЛ, если нужно
                # if not (-МАКСЦЕЛ - 1 <= value <= МАКСЦЕЛ):
                #    raise AssignmentError(f"Значение {value} выходит за допустимый диапазон для типа ЦЕЛ.", var_name=var_name)
                return value
            elif value_type is float:
                # Нельзя присвоить вещ переменной цел
                raise AssignmentError(f"Нельзя присвоить вещественное значение ({value}) переменной типа ЦЕЛ.")
            else:
                # Другие типы тоже нельзя
                raise AssignmentError(f"Нельзя присвоить значение типа {value_type.__name__} переменной типа ЦЕЛ.")
        elif target_type == 'вещ':
            if value_type is int:
                # Неявное преобразование цел -> вещ
                return float(value)
            elif value_type is float:
                # Тип совпадает
                return value
            else:
                raise AssignmentError(f"Нельзя присвоить значение типа {value_type.__name__} переменной типа ВЕЩ.")
        elif target_type == 'лог':
            if value_type is bool:
                return value
            else:
                raise AssignmentError(f"Нельзя присвоить значение типа {value_type.__name__} переменной типа ЛОГ.")
        elif target_type == 'сим':
            if value_type is str and len(value) == 1:
                return value
            elif value_type is str and len(value) != 1:
                raise AssignmentError(f"Нельзя присвоить строку \"{value}\" (длина {len(value)}) переменной типа СИМ (требуется длина 1).")
            else:
                 raise AssignmentError(f"Нельзя присвоить значение типа {value_type.__name__} переменной типа СИМ.")
        elif target_type == 'лит':
            if value_type is str:
                 # Неявное преобразование сим -> лит допускается (строка длины 1 - это тоже строка)
                return value
            else:
                raise AssignmentError(f"Нельзя присвоить значение типа {value_type.__name__} переменной типа ЛИТ.")
        else:
            # Неизвестный целевой тип (может быть таблица или ошибка)
            raise DeclarationError(f"Неизвестный или неподдерживаемый целевой тип '{target_type}' для переменной '{var_name}'.")
    # --- Вспомогательные методы для вычислений ---
    def get_full_identifier(self, ctx: KumirParser.CompoundIdentifierContext) -> str:
        """Возвращает полный текст многословного идентификатора, 
           собирая его из токенов WORD и K_NE."""
        parts_text = []
        parts_tokens = [] # Сохраняем токены для проверки
        if ctx.children: # Убедимся, что есть дети
            for child in ctx.children:
                # Проверяем, что это терминальный узел (токен), а не другое правило
                if isinstance(child, TerminalNode):
                    token_type = child.symbol.type
                    # Добавляем только WORD и K_NE
                    if token_type in (KumirLexer.WORD, KumirLexer.K_NE):
                        parts_text.append(child.getText())
                        parts_tokens.append(child.symbol)
                    # Игнорируем другие возможные токены (если вдруг появятся)
        full_name = ' '.join(parts_text)
        # Дополнительная проверка валидности имени:
        if parts_tokens and parts_tokens[-1].type == KumirLexer.K_NE:
            token = parts_tokens[-1]
            raise KumirEvalError(f"Строка {token.line}, столбец {token.column}: Идентификатор не может заканчиваться на 'не': '{full_name}'")
        # Проверка, что K_NE не идет первым (хотя грамматика должна это предотвращать)
        if parts_tokens and parts_tokens[0].type == KumirLexer.K_NE:
             token = parts_tokens[0]
             raise KumirEvalError(f"Строка {token.line}, столбец {token.column}: Идентификатор не может начинаться с 'не': '{full_name}'")
        # Проверка на два K_NE подряд (тоже должно ловиться грамматикой, но на всякий случай)
        for i in range(len(parts_tokens) - 1):
            if parts_tokens[i].type == KumirLexer.K_NE and parts_tokens[i+1].type == KumirLexer.K_NE:
                 token = parts_tokens[i+1]
                 raise KumirEvalError(f"Строка {token.line}, столбец {token.column}: Два 'не' подряд в идентификаторе недопустимы: '{full_name}'")
        # print(f"[DEBUG] Собрали идентификатор: '{full_name}' из {len(parts_text)} частей")
        return full_name
    # --- Вспомогательные методы для вычислений и проверки типов в выражениях ---
    def _check_numeric(self, value, operation_name):
        """Проверяет, является ли значение числом (цел или вещ)."""
        if not isinstance(value, (int, float)):
            raise KumirEvalError(f"Операция '{operation_name}' не применима к нечисловому типу {type(value).__name__}.")
        return value
    def _check_logical(self, value, operation_name):
        """Проверяет, является ли значение логическим."""
        if not isinstance(value, bool):
            raise KumirEvalError(f"Операция '{operation_name}' не применима к нелогическому типу {type(value).__name__}.")
        return value
    def _perform_binary_operation(self, ctx, ops_map, type_check_func=None):
        """Общая логика для выполнения бинарных операций."""
        left_ctx = ctx.getChild(0) # Левый операнд
        right_ctx = ctx.getChild(2) # Правый операнд
        op_token = ctx.getChild(1).symbol # Токен оператора
        left_val = self.visit(left_ctx)
        right_val = self.visit(right_ctx)
        # Выполняем проверку типов, если функция передана
        if type_check_func:
            left_val = type_check_func(left_val, op_token.text)
            right_val = type_check_func(right_val, op_token.text)
        else: # По умолчанию проверяем на числовой тип (для арифметики и сравнений)
            left_val = self._check_numeric(left_val, op_token.text)
            right_val = self._check_numeric(right_val, op_token.text)
        # Получаем функцию операции из словаря
        operation = ops_map.get(op_token.type)
        if not operation:
            raise KumirEvalError(f"Неизвестная или неподдерживаемая бинарная операция: {op_token.text}")
        # Особая обработка для деления, div, mod
        if op_token.type == KumirLexer.DIV: # Обычное деление
            if right_val == 0:
                raise KumirEvalError("Деление на ноль.")
            # Результат всегда вещ
            return float(left_val) / float(right_val)
        elif op_token.type in [KumirLexer.K_DIV, KumirLexer.K_MOD]: # div, mod
            if not isinstance(left_val, int) or not isinstance(right_val, int):
                 raise KumirEvalError(f"Операция '{op_token.text}' применима только к целым числам.")
            if right_val == 0:
                raise KumirEvalError(f"Целочисленное деление или остаток от деления на ноль ('{op_token.text}').")
            # Выполняем операцию (результат цел)
            return operation(left_val, right_val)
        # Выполняем остальные операции
        try:
            result = operation(left_val, right_val)
            # Для сравнений результат всегда лог
            # Для арифметики тип результата зависит от операции и операндов
            # (уже обрабатывается стандартными операторами Python)
            return result
        except TypeError as e:
            raise KumirEvalError(f"Ошибка типа при выполнении операции '{op_token.text}': {e}")
        except Exception as e:
             raise KumirEvalError(f"Ошибка при вычислении '{op_token.text}': {e}")
    # --- Переопределение методов visit --- 
    def visitStart(self, ctx: KumirParser.StartContext):
        print("[DEBUG][Visit] Начало программы (start)")
        # Глобальная область уже создана в __init__
        # Обходим все алгоритмы в файле
        result = self.visitChildren(ctx)
        print("[DEBUG][Visit] Конец программы (start)")
        return result
    def visitAlgorithm(self, ctx: KumirParser.AlgorithmContext):
        # Получение имени алгоритма, если оно есть
        alg_name = "<анонимный>"
        if ctx.algHeader().compoundIdentifier(): # Изменено на compoundIdentifier
            alg_name = self.get_full_identifier(ctx.algHeader().compoundIdentifier()) 
        print(f"[DEBUG][Visit] Вход в алгоритм '{alg_name}'") # Добавил имя в лог
        self.enter_scope() # Создаем локальную область для алгоритма
        # Посещаем объявления и блок команд
        self.visitChildren(ctx) 
        self.exit_scope() # Выходим из локальной области
        print(f"[DEBUG][Visit] Выход из алгоритма '{alg_name}'") # Добавил имя в лог
        return None
    # Обработка объявлений скалярных переменных
    def visitScalarDecl(self, ctx: KumirParser.ScalarDeclContext):
        print(f"[DEBUG][Visit] Обработка scalarDecl")
        type_token = ctx.typeKeyword().start 
        kumir_type = TYPE_MAP.get(type_token.type)
        if not kumir_type:
            raise Exception(f"Неизвестный тип переменной: {type_token.text}")
        # Обходим список имен переменных (variableNameList содержит compoundIdentifier)
        for var_id_ctx in ctx.variableNameList().compoundIdentifier(): # Изменено на compoundIdentifier
            var_name = self.get_full_identifier(var_id_ctx)
            self.declare_variable(var_name, kumir_type, is_table=False)
        return None
    # Обработка объявлений таблиц (пока без обработки диапазонов)
    def visitTableDecl(self, ctx: KumirParser.TableDeclContext):
        print(f"[DEBUG][Visit] Обработка tableDecl")
        type_token = ctx.typeKeyword().start
        kumir_type = TYPE_MAP.get(type_token.type)
        if not kumir_type:
            raise Exception(f"Неизвестный тип таблицы: {type_token.text}")
        table_name = self.get_full_identifier(ctx.compoundIdentifier()) # Изменено на compoundIdentifier
        dimensions = None 
        print(f"  -> Диапазоны для таблицы '{table_name}' пока не вычисляются.")
        self.declare_variable(table_name, kumir_type, is_table=True, dimensions=dimensions)
        return None
    # Обработка узла многословного идентификатора (переименован)
    def visitCompoundIdentifier(self, ctx: KumirParser.CompoundIdentifierContext):
        # Этот метод теперь вызывается для compoundIdentifier.
        # Вернем полный идентификатор, собранный нашим методом.
        return self.get_full_identifier(ctx)
    # Обработка узла переменной
    def visitVariable(self, ctx: KumirParser.VariableContext):
        var_name = self.get_full_identifier(ctx.compoundIdentifier()) # Изменено на compoundIdentifier
        print(f"[DEBUG][Visit] Обращение к переменной/таблице: '{var_name}'")
        var_info, _ = self.find_variable(var_name)
        if var_info is None:
            # Добавляем информацию о строке и столбце
            line = ctx.start.line
            column = ctx.start.column
            raise KumirExecutionError(f"Строка {line}, столбец {column}: Переменная '{var_name}' не найдена.")
        if ctx.expressionList():
            print(f"  -> Это обращение к таблице '{var_name}'")
            if not var_info['is_table']:
                line = ctx.start.line
                column = ctx.start.column
                raise KumirExecutionError(f"Строка {line}, столбец {column}: Попытка доступа по индексу к не табличной переменной '{var_name}'.")
            # TODO: Обработка индексов таблиц
            raise NotImplementedError(f"Обращение к элементу таблицы '{var_name}' пока не реализовано.")
        else:
            if var_info['is_table']:
                 print(f"  -> Это обращение ко всей таблице '{var_name}' (возвращаем словарь)")
                 return var_info['value']
            else:
                print(f"  -> Возвращаем значение переменной '{var_name}': {var_info['value']}")
                return var_info['value']
    # Обработка присваивания
    def visitAssignment(self, ctx: KumirParser.AssignmentContext):
        print("[DEBUG][Visit] Обработка assignment")
        value = self.visit(ctx.expression()) 
        print(f"[DEBUG][Visit] Вычислено значение для присваивания: {value} (тип: {type(value).__name__})")
        if ctx.variable():
            var_ctx = ctx.variable()
            target_name = self.get_full_identifier(var_ctx.compoundIdentifier()) # Изменено на compoundIdentifier
            if var_ctx.expressionList():
                print(f"  -> Присваивание элементу таблицы: '{target_name}[...]'")
                raise NotImplementedError(f"Присваивание элементу таблицы '{target_name}' пока не реализовано.")
            else:
                print(f"  -> Присваивание переменной/таблице: '{target_name}'")
                try:
                    self.update_variable(target_name, value) 
                except (AssignmentError, DeclarationError, KumirExecutionError) as e:
                    line = ctx.start.line
                    column = ctx.start.column
                    raise KumirExecutionError(f"Строка {line}, столбец {column}: Ошибка присваивания '{target_name}': {e}")
                except Exception as e: 
                    line = ctx.start.line
                    column = ctx.start.column
                    raise KumirExecutionError(f"Строка {line}, столбец {column}: Неожиданная ошибка при присваивании '{target_name}': {e}")
        elif ctx.K_ZNACH():
            print("  -> Присваивание результату функции (знач)")
            raise NotImplementedError("Присваивание результату функции (знач) пока не реализовано.")
        else:
            line = ctx.start.line
            column = ctx.start.column
            raise KumirExecutionError(f"Строка {line}, столбец {column}: Неизвестный тип цели присваивания.")
        return None 
    # --- Обработка выражений --- 
    def visitExpression(self, ctx:KumirParser.ExpressionContext):
        # Стартовое правило для выражения - просто передаем дальше
        return self.visitChildren(ctx)
    def visitLogicalOrExpr(self, ctx:KumirParser.LogicalOrExprContext):
        if ctx.K_ILI():
            # Теперь используем _perform_binary_operation
            return self._perform_binary_operation(ctx, LOGICAL_OPS, type_check_func=self._check_logical)
        else:
             return self.visit(ctx.logicalAndExpr(0))
    def visitLogicalAndExpr(self, ctx:KumirParser.LogicalAndExprContext):
        if ctx.K_I():
             # Теперь используем _perform_binary_operation
             return self._perform_binary_operation(ctx, LOGICAL_OPS, type_check_func=self._check_logical)
        else:
             return self.visit(ctx.comparisonExpr(0))
    def visitComparisonExpr(self, ctx:KumirParser.ComparisonExprContext):
        # В грамматике ComparisonExpr всегда содержит два AddSubExpr и оператор сравнения, если это бинарная операция
        if len(ctx.children) > 1: # Проверяем, есть ли оператор и второй операнд
            # Теперь используем _perform_binary_operation (проверка на числовой тип по умолчанию)
            return self._perform_binary_operation(ctx, COMPARISON_OPS)
        else:
            return self.visit(ctx.addSubExpr(0))
    def visitAddSubExpr(self, ctx:KumirParser.AddSubExprContext):
        # В грамматике AddSubExpr содержит нечетное число детей (>1), если есть операции
        if len(ctx.children) > 1: 
            # Теперь используем _perform_binary_operation (проверка на числовой тип по умолчанию)
            # Обрабатываем лево-ассоциативность: вычисляем слева направо
            result = self.visit(ctx.getChild(0)) # Вычисляем самый левый операнд
            i = 1
            while i < len(ctx.children):
                op_token = ctx.getChild(i).symbol
                right_val = self.visit(ctx.getChild(i+1))
                result = self._check_numeric(result, op_token.text)
                right_val = self._check_numeric(right_val, op_token.text)
                operation = ARITHMETIC_OPS.get(op_token.type)
                if not operation:
                    raise KumirEvalError(f"Неизвестная операция сложения/вычитания: {op_token.text}")
                try:
                    result = operation(result, right_val)
                except Exception as e:
                    raise KumirEvalError(f"Ошибка при вычислении '{op_token.text}': {e}")
                i += 2
            return result
        else:
            return self.visit(ctx.mulDivModExpr(0))
    def visitMulDivModExpr(self, ctx:KumirParser.MulDivModExprContext):
        # Аналогично AddSubExpr, обрабатываем лево-ассоциативность
        if len(ctx.children) > 1: 
            result = self.visit(ctx.getChild(0))
            i = 1
            while i < len(ctx.children):
                op_token = ctx.getChild(i).symbol
                right_val = self.visit(ctx.getChild(i+1))
                result = self._check_numeric(result, op_token.text)
                right_val = self._check_numeric(right_val, op_token.text)
                operation = ARITHMETIC_OPS.get(op_token.type)
                if not operation:
                     raise KumirEvalError(f"Неизвестная операция умножения/деления: {op_token.text}")
                # Особая обработка для деления, div, mod
                if op_token.type == KumirLexer.DIV:
                    if right_val == 0: raise KumirEvalError("Деление на ноль.")
                    result = float(result) / float(right_val)
                elif op_token.type in [KumirLexer.K_DIV, KumirLexer.K_MOD]:
                    if not isinstance(result, int) or not isinstance(right_val, int):
                        raise KumirEvalError(f"Операция '{op_token.text}' применима только к целым числам.")
                    if right_val == 0:
                        raise KumirEvalError(f"Целочисленное деление или остаток от деления на ноль ('{op_token.text}').")
                    result = operation(result, right_val)
                else: # Умножение
                    try:
                        result = operation(result, right_val)
                    except Exception as e:
                         raise KumirEvalError(f"Ошибка при вычислении '{op_token.text}': {e}")
                i += 2
            return result
        else:
            return self.visit(ctx.powerExpr(0))
    def visitPowerExpr(self, ctx:KumirParser.PowerExprContext):
        # Возведение в степень право-ассоциативно, обрабатываем справа налево
        operands_ctx = ctx.unaryExpr()
        if len(operands_ctx) == 1:
            return self.visit(operands_ctx[0]) # Нет операции POW
        # Вычисляем самый правый операнд
        right_val = self.visit(operands_ctx[-1])
        # Идем справа налево по операциям
        for i in range(len(operands_ctx) - 2, -1, -1):
            left_val = self.visit(operands_ctx[i])
            op_name = '**'
            left_val = self._check_numeric(left_val, op_name)
            right_val = self._check_numeric(right_val, op_name)
            try:
                # print(f"[DEBUG][Eval] {left_val} {op_name} {right_val}")
                result = math.pow(left_val, right_val)
                # print(f"[DEBUG][Eval]  = {result}")
                # В Кумире результат pow может быть целым, если возможно
                if result == int(result):
                    right_val = int(result)
                else:
                    right_val = float(result)
            except ValueError as e: # Например, 0**(-1) 
                 raise KumirEvalError(f"Ошибка при возведении в степень: {e}")
            except OverflowError:
                 raise KumirEvalError(f"Переполнение при возведении в степень")
            except Exception as e:
                 raise KumirEvalError(f"Ошибка при возведении в степень: {e}")
        return right_val # Конечный результат после всех возведений
    def visitUnaryExpr(self, ctx:KumirParser.UnaryExprContext):
       op = None
       if ctx.PLUS(): op = '+'
       if ctx.MINUS(): op = '-'
       if ctx.K_NE(): op = 'не'
       operand_value = self.visit(ctx.primaryExpr())
       if op == '+':
           return self._check_numeric(operand_value, "унарный плюс")
       elif op == '-':
           return -self._check_numeric(operand_value, "унарный минус")
       elif op == 'не':
           operand_value = self._check_logical(operand_value, "операция НЕ")
           return not operand_value # Выполняем логическое НЕ
       else:
           return operand_value
    def visitPrimaryExpr(self, ctx:KumirParser.PrimaryExprContext):
        if ctx.literal():
            return self.visit(ctx.literal())
        elif ctx.variable():
            return self.visit(ctx.variable())
        elif ctx.functionCall():
            # Получаем имя функции
            func_name = self.get_full_identifier(ctx.functionCall().compoundIdentifier()) # Изменено на compoundIdentifier
            print(f"[WARN][Expr] Вызов функции '{func_name}' пока не реализован")
            # TODO: Реализовать вызов функции (вычисление аргументов, поиск функции, выполнение)
            return None
        elif ctx.expression(): # Скобки
            return self.visit(ctx.expression())
        return None
    def visitLiteral(self, ctx:KumirParser.LiteralContext):
        if ctx.NUMBER():
            num_str = ctx.NUMBER().getText()
            if '.' in num_str or 'e' in num_str or 'E' in num_str:
                print(f"  -> Литерал ВЕЩ: {float(num_str)}")
                return float(num_str)
            elif num_str.startswith('$'):
                 print(f"  -> Литерал ЦЕЛ (hex): {int(num_str[1:], 16)}")
                 return int(num_str[1:], 16)
            else:
                print(f"  -> Литерал ЦЕЛ: {int(num_str)}")
                return int(num_str)
        elif ctx.STRING():
            # Убираем кавычки и обрабатываем escape-последовательности (пока просто убираем кавычки)
            str_val = ctx.STRING().getText()[1:-1] 
            # TODO: Правильная обработка escape sequences
            print(f"  -> Литерал ЛИТ: '{str_val}'")
            return str_val
        elif ctx.CHAR():
            # Убираем кавычки и обрабатываем escape-последовательности (пока просто убираем кавычки)
            char_val = ctx.CHAR().getText()[1:-1] 
             # TODO: Правильная обработка escape sequences
            print(f"  -> Литерал СИМ: '{char_val}'")
            return char_val
        elif ctx.K_DA(): 
            print(f"  -> Литерал ЛОГ: True")
            return True
        elif ctx.K_NET(): 
            print(f"  -> Литерал ЛОГ: False")
            return False
        return None
    # --- Метод visitForLoop --- 
    def visitForLoop(self, ctx: KumirParser.ForLoopContext):
        loop_var_id_ctx = ctx.compoundIdentifier()
        loop_var_name = self.get_full_identifier(loop_var_id_ctx)
        start_val_ctx = ctx.expression(0)
        end_val_ctx = ctx.expression(1)
        step_ctx = ctx.expression(2) # Может быть None
        # Вычисляем границы и шаг
        try:
            start_val = self.visit(start_val_ctx)
            end_val = self.visit(end_val_ctx)
            step_val = 1
            if step_ctx:
                step_val = self.visit(step_ctx)
        except Exception as e:
             line = start_val_ctx.start.line
             column = start_val_ctx.start.column
             raise KumirEvalError(f"Строка {line}, столбец {column}: Ошибка вычисления границ или шага цикла ДЛЯ: {e}")
        # Проверяем типы границ и шага
        if not isinstance(start_val, int):
            line = start_val_ctx.start.line
            column = start_val_ctx.start.column
            raise KumirEvalError(f"Строка {line}, столбец {column}: Начальное значение цикла ДЛЯ ('{start_val}') должно быть целым.")
        if not isinstance(end_val, int):
            line = end_val_ctx.start.line
            column = end_val_ctx.start.column
            raise KumirEvalError(f"Строка {line}, столбец {column}: Конечное значение цикла ДЛЯ ('{end_val}') должно быть целым.")
        if not isinstance(step_val, int):
             line = step_ctx.start.line if step_ctx else start_val_ctx.start.line # Приблизительно
             column = step_ctx.start.column if step_ctx else start_val_ctx.start.column
             raise KumirEvalError(f"Строка {line}, столбец {column}: Шаг цикла ДЛЯ ('{step_val}') должен быть целым.")
        if step_val == 0:
             line = step_ctx.start.line if step_ctx else start_val_ctx.start.line
             column = step_ctx.start.column if step_ctx else start_val_ctx.start.column
             raise KumirEvalError(f"Строка {line}, столбец {column}: Шаг цикла ДЛЯ не может быть равен нулю.")
        print(f"[DEBUG][Visit] Начало цикла ДЛЯ '{loop_var_name}' от {start_val} до {end_val} шаг {step_val}")
        # Находим информацию о переменной цикла в текущей или внешней области
        var_info, var_scope = self.find_variable(loop_var_name)
        if var_info is None:
            line = loop_var_id_ctx.start.line
            column = loop_var_id_ctx.start.column
            raise KumirExecutionError(f"Строка {line}, столбец {column}: Переменная цикла ДЛЯ '{loop_var_name}' не найдена.")
        if var_info.get('is_table'):
            line = loop_var_id_ctx.start.line
            column = loop_var_id_ctx.start.column
            raise KumirExecutionError(f"Строка {line}, столбец {column}: Переменная цикла ДЛЯ '{loop_var_name}' не может быть таблицей.")
        if var_info.get('type') != 'цел':
            line = loop_var_id_ctx.start.line
            column = loop_var_id_ctx.start.column
            raise KumirExecutionError(f"Строка {line}, столбец {column}: Переменная цикла ДЛЯ '{loop_var_name}' должна быть целого типа, а не '{var_info.get('type')}'.")
        # Определяем диапазон итераций
        # range() в Python не включает end_val, поэтому корректируем для шага > 0
        # Для шага < 0, range() также работает правильно с остановкой
        current_val = start_val
        iteration_count = 0
        try:
            # Итерация цикла
            if step_val > 0:
                while current_val <= end_val:
                    iteration_count += 1
                    if iteration_count > 100000: # Защита от бесконечных циклов
                         raise KumirExecutionError(f"Превышено максимальное число итераций цикла ДЛЯ ({iteration_count})")
                    # Обновляем значение переменной в ее области видимости
                    var_info['value'] = current_val 
                    print(f"  -> Итерация {iteration_count}: {loop_var_name} = {current_val}")
                    # Выполняем тело цикла
                    self.visit(ctx.block())
                    current_val += step_val
            elif step_val < 0:
                 while current_val >= end_val:
                    iteration_count += 1
                    if iteration_count > 100000:
                         raise KumirExecutionError(f"Превышено максимальное число итераций цикла ДЛЯ ({iteration_count})")
                    var_info['value'] = current_val
                    print(f"  -> Итерация {iteration_count}: {loop_var_name} = {current_val}")
                    self.visit(ctx.block())
                    current_val += step_val
            # Если start_val > end_val при step > 0 или start_val < end_val при step < 0, цикл не выполнится
        except Exception as loop_body_error:
             # Перехватываем ошибки из тела цикла и добавляем информацию
             # TODO: По возможности, получить номер строки из loop_body_error
             line = ctx.block().start.line
             column = ctx.block().start.column
             raise KumirExecutionError(f"Строка {line}, столбец {column}: Ошибка внутри цикла ДЛЯ: {loop_body_error}")
        print(f"[DEBUG][Visit] Конец цикла ДЛЯ '{loop_var_name}'. Итераций: {iteration_count}")
        return None
    # --- Метод visitWhileLoop --- 
    def visitWhileLoop(self, ctx: KumirParser.WhileLoopContext):
        condition_ctx = ctx.expression()
        block_ctx = ctx.block()
        print(f"[DEBUG][Visit] Начало цикла ПОКА")
        iteration_count = 0
        max_iterations = 100000 # Защита
        while True:
            iteration_count += 1
            if iteration_count > max_iterations:
                raise KumirExecutionError(f"Превышено максимальное число итераций цикла ПОКА ({iteration_count})")
            # Вычисляем условие
            try:
                condition_value = self.visit(condition_ctx)
            except Exception as e:
                line = condition_ctx.start.line
                column = condition_ctx.start.column
                raise KumirEvalError(f"Строка {line}, столбец {column}: Ошибка вычисления условия цикла ПОКА: {e}")
            # Проверяем тип условия
            if not isinstance(condition_value, bool):
                 line = condition_ctx.start.line
                 column = condition_ctx.start.column
                 raise KumirEvalError(f"Строка {line}, столбец {column}: Условие цикла ПОКА ('{condition_value}') должно быть логического типа, а не {type(condition_value).__name__}.")
            print(f"  -> Итерация {iteration_count}: Условие = {condition_value}")
            if not condition_value: # Если условие == нет (False)
                break # Выход из цикла
            # Выполняем тело цикла
            try:
                self.visit(block_ctx)
            except Exception as loop_body_error:
                 line = block_ctx.start.line
                 column = block_ctx.start.column
                 raise KumirExecutionError(f"Строка {line}, столбец {column}: Ошибка внутри цикла ПОКА: {loop_body_error}")
        print(f"[DEBUG][Visit] Конец цикла ПОКА. Итераций: {iteration_count - 1}") # -1 т.к. последняя проверка условия была лишней
        return None
    # --- Метод visitTimesLoop --- 
    def visitTimesLoop(self, ctx: KumirParser.TimesLoopContext):
        times_expr_ctx = ctx.expression()
        block_ctx = ctx.block()
        # Вычисляем количество повторений
        try:
            times_value = self.visit(times_expr_ctx)
        except Exception as e:
            line = times_expr_ctx.start.line
            column = times_expr_ctx.start.column
            raise KumirEvalError(f"Строка {line}, столбец {column}: Ошибка вычисления количества повторений цикла РАЗ: {e}")
        # Проверяем тип и значение
        if not isinstance(times_value, int):
            line = times_expr_ctx.start.line
            column = times_expr_ctx.start.column
            raise KumirEvalError(f"Строка {line}, столбец {column}: Количество повторений цикла РАЗ ('{times_value}') должно быть целым числом, а не {type(times_value).__name__}.")
        if times_value < 0:
            line = times_expr_ctx.start.line
            column = times_expr_ctx.start.column
            raise KumirEvalError(f"Строка {line}, столбец {column}: Количество повторений цикла РАЗ ('{times_value}') не может быть отрицательным.")
        max_iterations = 100000 # Защита
        if times_value > max_iterations:
             raise KumirExecutionError(f"Запрошено слишком большое число итераций цикла РАЗ ({times_value}), максимум {max_iterations}")
        print(f"[DEBUG][Visit] Начало цикла {times_value} РАЗ")
        for i in range(times_value):
            iteration_num = i + 1
            print(f"  -> Итерация {iteration_num} из {times_value}")
             # Выполняем тело цикла
            try:
                self.visit(block_ctx)
            except Exception as loop_body_error:
                 line = block_ctx.start.line
                 column = block_ctx.start.column
                 raise KumirExecutionError(f"Строка {line}, столбец {column}: Ошибка внутри цикла РАЗ (итерация {iteration_num}): {loop_body_error}")
        print(f"[DEBUG][Visit] Конец цикла РАЗ. Итераций: {times_value}")
        return None
# --- Функция для запуска интерпретации ---
def interpret_kumir(input_string):
    """Парсит и интерпретирует строку с кодом Кумира."""
    from antlr4 import InputStream, CommonTokenStream
    # from .generated.KumirLexer import KumirLexer # Уже импортирован выше
    # from .generated.KumirParser import KumirParser # Уже импортирован выше
    # Импортируем наш Visitor
    # from .interpreter import KumirInterpreterVisitor # Определен выше
    print(f"\n--- Запуск интерпретации для: ---\n{input_string}\n----------------------------------")
    input_stream = InputStream(input_string)
    lexer = KumirLexer(input_stream)
    stream = CommonTokenStream(lexer)
    parser = KumirParser(stream)
    # Удаляем стандартный консольный listener
    parser.removeErrorListeners()
    # Добавляем наш диагностический listener
    parser.addErrorListener(DiagnosticErrorListener())
    try:
        tree = parser.start() # Получаем дерево разбора
        # Проверяем наличие синтаксических ошибок ПОСЛЕ парсинга
        num_syntax_errors = parser.getNumberOfSyntaxErrors()
        if num_syntax_errors > 0:
            print(f"Обнаружено {num_syntax_errors} синтаксических ошибок. Интерпретация прервана.")
            return False # Возвращаем False при ошибках парсинга
        print("Парсинг успешен, начинаем обход дерева...")
        visitor = KumirInterpreterVisitor()
        # Убираем диагностический listener перед обходом (он нужен только для парсинга)
        # parser.removeErrorListeners() 
        # parser.addErrorListener(ErrorListener()) # Возвращаем стандартный, если нужно
        result = visitor.visit(tree)
        print("Обход дерева завершен.")
        return True
    except Exception as e:
        import traceback
        print(f"Ошибка во время парсинга или интерпретации: {e}")
        traceback.print_exc() 
        return False
class KumirLanguageInterpreter:
	"""Интерпретатор языка КУМИР с поддержкой вызова алгоритмов и ссылок."""
	# ... (Код __init__ и методов работы со стеком/ссылками остается тем же, что и в предыдущем ответе) ...
	def __init__(self, code, initial_field_state=None):
		"""Инициализирует интерпретатор."""
		self.code = code;
		self.global_env = {};
		self.algorithms = {};
		self.main_algorithm = None
		self.introduction = [];
		self.output = "";
		self.logger = logger;
		self.trace = []
		self.progress_callback = None;
		self.call_stack = []
		default_state = {'width': 7, 'height': 7, 'robotPos': {'x': 0, 'y': 0}, 'walls': set(), 'markers': {},
		                 'coloredCells': set(), 'symbols': {}, 'radiation': {}, 'temperature': {}}
		current_state = initial_field_state if initial_field_state else default_state
		self.width = current_state.get('width', default_state['width']);
		self.height = current_state.get('height', default_state['height'])
		if not isinstance(self.width, int) or self.width < 1: self.logger.warning(
			f"Invalid width: {self.width}. Using default."); self.width = default_state['width']
		if not isinstance(self.height, int) or self.height < 1: self.logger.warning(
			f"Invalid height: {self.height}. Using default."); self.height = default_state['height']
		self.robot = SimulatedRobot(width=self.width, height=self.height,
		                            initial_pos=current_state.get('robotPos', default_state['robotPos']),
		                            initial_walls=set(current_state.get('walls', [])),
		                            initial_markers=dict(current_state.get('markers', {})),
		                            initial_colored_cells=set(current_state.get('coloredCells', [])),
		                            initial_symbols=dict(current_state.get('symbols', {})),
		                            initial_radiation=dict(current_state.get('radiation', {})),
		                            initial_temperature=dict(current_state.get('temperature', {})))
		self.logger.info(
			f"Interpreter initialized. Field: {self.width}x{self.height}. Robot at: {self.robot.robot_pos}")
	def get_current_env_index(self):
		return len(self.call_stack) - 1
	def get_env_by_index(self, index):
		if index == -1:
			return self.global_env
		elif 0 <= index < len(self.call_stack):
			frame = self.call_stack[index];
			if 'env' in frame:
				return frame['env']
			else:
				self.logger.error(
					f"Internal error: 'env' key missing in call stack frame at index {index}"); raise KumirExecutionError(
					f"Внутренняя ошибка: отсутствует окружение в стеке вызовов ({index})")
		else:
			self.logger.error(f"Attempt to access invalid env index: {index}"); raise KumirExecutionError(
				f"Внутренняя ошибка: неверный индекс окружения {index}")
	def _resolve_reference(self, ref_info):
		if not isinstance(ref_info, dict) or ref_info.get('kind') != 'ref': self.logger.error(
			f"Invalid input to _resolve_reference: {ref_info}"); raise KumirExecutionError(
			"Внутренняя ошибка: неверные данные для разрешения ссылки.")
		visited_refs = set();
		current_info = ref_info;
		current_indices = ref_info.get('ref_indices')
		target_var_name = None  # Инициализируем
		target_env_index = None  # Инициализируем
		target_env = None  # Инициализируем
		while isinstance(current_info, dict) and current_info.get('kind') == 'ref':
			target_var_name = current_info.get('target_var_name');
			target_env_index = current_info.get('target_env_index')
			if target_var_name is None or target_env_index is None: raise KumirExecutionError(
				f"Внутренняя ошибка: некорректная структура ссылки для '{ref_info.get('target_var_name', '?')}'")
			ref_id = (target_env_index, target_var_name, current_indices)
			if ref_id in visited_refs: raise KumirExecutionError(
				f"Обнаружена циклическая ссылка на переменную '{target_var_name}'"); visited_refs.add(ref_id)
			try:
				target_env = self.get_env_by_index(target_env_index)
			except KumirExecutionError:
				raise KumirExecutionError(f"Ошибка разрешения ссылки: не найден контекст для '{target_var_name}'")
			if target_var_name not in target_env: raise KumirExecutionError(
				f"Ошибка разрешения ссылки: переменная '{target_var_name}' не найдена")
			next_info = target_env[target_var_name];
			next_ref_indices = next_info.get('ref_indices') if isinstance(next_info, dict) else None
			if next_info.get('kind') == 'ref' and next_ref_indices is not None: raise KumirExecutionError(
				f"Внутренняя ошибка: некорректная цепочка ссылок с индексами."); current_info = next_info
		if not isinstance(current_info, dict) or current_info.get('kind') != 'value': raise KumirExecutionError(
			f"Внутренняя ошибка: ссылка указывает на некорректный объект.")
		# target_env и target_var_name остались от последней итерации
		return target_env, target_var_name, current_indices
	def get_variable_info(self, var_name, env_index=None):
		if env_index is None: env_index = self.get_current_env_index()
		if env_index != -1:
			try:
				current_env = self.get_env_by_index(env_index);
				if var_name in current_env: return current_env[var_name]
			except KumirExecutionError:
				pass
		if var_name in self.global_env: return self.global_env[var_name]
		return None
	def resolve_variable_value(self, var_name, indices=None, env_index=None):
		if env_index is None: env_index = self.get_current_env_index()
		var_info = self.get_variable_info(var_name, env_index)
		if var_info is None: raise KumirExecutionError(f"Переменная '{var_name}' не найдена.")
		if not isinstance(var_info, dict): raise KumirExecutionError(
			f"Внутренняя ошибка: некорректная структура для переменной '{var_name}'.")
		if var_info.get('kind') == 'ref':
			try:
				target_env, target_var_name, ref_indices = self._resolve_reference(var_info)
				var_info_to_use = target_env.get(target_var_name)
				if var_info_to_use is None or var_info_to_use.get('kind') != 'value': raise KumirExecutionError(
					f"Внутренняя ошибка: целевая переменная '{target_var_name}' не найдена или некорректна после разрешения ссылки.")
				final_indices = indices if indices is not None else ref_indices
			except KumirExecutionError as e:
				raise e
		else:
			if indices is not None and var_info.get('kind') == 'ref': raise KumirExecutionError(
				"Внутренняя ошибка: некорректный доступ к элементу ссылки.")
			final_indices = indices;
			var_info_to_use = var_info
		final_var_info = var_info_to_use
		if final_indices is not None:
			if not final_var_info.get('is_table'): raise AssignmentError(
				f"Попытка доступа по индексу к не табличной переменной '{var_name}'.")
			dims = final_var_info.get('dimensions')
			if not dims or len(dims) != len(final_indices): raise AssignmentError(
				f"Неверное количество индексов ({len(final_indices)}) для таблицы '{var_name}', ожидалось {len(dims) if dims else '?'}.")
			for d_idx, idx_val in enumerate(final_indices):
				start, end = dims[d_idx];
				if not (start <= idx_val <= end): raise AssignmentError(
					f"Индекс #{d_idx + 1} ({idx_val}) вне диапазона [{start}:{end}] для '{var_name}'.")
			table_value_dict = final_var_info.get('value')
			if not isinstance(table_value_dict, dict): raise KumirExecutionError(
				f"Таблица '{var_name}' не инициализирована или повреждена.")
			element_value = table_value_dict.get(final_indices)
			if element_value is None: return get_default_value(final_var_info['type'])
			return element_value
		else:
			if final_var_info.get('is_table'):
				table_val = final_var_info.get('value'); return table_val if isinstance(table_val, dict) else {}
			else:
				scalar_val = final_var_info.get('value'); return get_default_value(
					final_var_info['type']) if scalar_val is None and final_var_info.get('type') else scalar_val
	def update_variable_value(self, var_name, value, indices=None, env_index=None):
		if env_index is None: env_index = self.get_current_env_index()
		var_info = self.get_variable_info(var_name, env_index)
		if var_info is None: raise KumirExecutionError(f"Переменная '{var_name}' не найдена для присваивания.")
		if not isinstance(var_info, dict): raise KumirExecutionError(
			f"Внутренняя ошибка: некорректная структура для переменной '{var_name}'.")
		if var_info.get('kind') == 'ref':
			try:
				target_env, target_var_name, ref_indices = self._resolve_reference(var_info)
				var_info_to_update = target_env.get(target_var_name)
				if var_info_to_update is None or var_info_to_update.get('kind') != 'value': raise KumirExecutionError(
					f"Внутренняя ошибка: целевая переменная '{target_var_name}' не найдена или некорректна после разрешения ссылки.")
				final_indices = indices if indices is not None else ref_indices;
				effective_var_name_for_error = target_var_name
			except KumirExecutionError as e:
				raise e
		else:
			if indices is not None and var_info.get('kind') == 'ref': raise KumirExecutionError(
				"Внутренняя ошибка: некорректное обновление элемента ссылки.")
			final_indices = indices;
			var_info_to_update = var_info;
			effective_var_name_for_error = var_name
		target_type = var_info_to_update['type'];
		is_table = var_info_to_update.get('is_table', False)
		try:
			if final_indices is None and is_table:
				if not isinstance(value, dict): raise AssignmentError(
					f"Попытка присвоить не таблицу (не словарь) табличной переменной '{effective_var_name_for_error}'")
				converted_value = value
			elif final_indices is not None and is_table:
				converted_value = _validate_and_convert_value(value, target_type,
				                                              f"{effective_var_name_for_error}[...]")
			elif not is_table:
				converted_value = _validate_and_convert_value(value, target_type, effective_var_name_for_error)
			else:
				raise KumirExecutionError(
					f"Неожиданное состояние при обновлении переменной '{effective_var_name_for_error}'")
		except (AssignmentError, TypeError) as e:
			raise AssignmentError(f"Ошибка типа при присваивании переменной '{effective_var_name_for_error}': {e}")
		if final_indices is not None:
			if not is_table: raise AssignmentError(
				f"Попытка присваивания по индексу не табличной переменной '{effective_var_name_for_error}'.")
			dims = var_info_to_update.get('dimensions')
			if not dims or len(dims) != len(final_indices): raise AssignmentError(
				f"Неверное количество индексов ({len(final_indices)}) для таблицы '{effective_var_name_for_error}', ожидалось {len(dims) if dims else '?'}.")
			for d_idx, idx_val in enumerate(final_indices):
				start, end = dims[d_idx];
				if not (start <= idx_val <= end): raise AssignmentError(
					f"Индекс #{d_idx + 1} ({idx_val}) вне диапазона [{start}:{end}] для '{effective_var_name_for_error}'.")
			if not isinstance(var_info_to_update.get('value'), dict): var_info_to_update['value'] = {}; logger.debug(
				f"Initialized table '{effective_var_name_for_error}' before setting element.")
			var_info_to_update['value'][final_indices] = converted_value;
			logger.debug(
				f"Updated table element {effective_var_name_for_error}{list(final_indices)} = {converted_value}")
		else:
			if is_table:
				var_info_to_update['value'] = converted_value; logger.debug(
					f"Updated entire table '{effective_var_name_for_error}'")
			else:
				var_info_to_update['value'] = converted_value; logger.debug(
					f"Updated scalar variable '{effective_var_name_for_error}' = {converted_value}")
	def push_call_stack(self, algo_name, local_env):
		caller_env_index = self.get_current_env_index()
		self.call_stack.append({'name': algo_name, 'env': local_env, 'caller_env_index': caller_env_index})
		self.logger.debug(
			f"Pushed '{algo_name}' onto call stack. Depth: {len(self.call_stack)}. Caller index: {caller_env_index}")
	def pop_call_stack(self):
		if not self.call_stack: self.logger.error("Attempted to pop from an empty call stack."); return None
		popped = self.call_stack.pop();
		self.logger.debug(f"Popped '{popped.get('name')}' from call stack. Depth: {len(self.call_stack)}");
		return popped
	def _get_env_for_frontend(self, env):
		resolved_env = {}
		if env:
			env_index = -1;
			if env is not self.global_env:
				for idx, frame in enumerate(self.call_stack):
					if frame.get('env') is env: env_index = idx; break
				if env_index == -1 and env: logger.warning(
					"_get_env_for_frontend received an unknown env object. Resolving from current scope."); env_index = self.get_current_env_index()
			for name in env.keys():
				try:
					value = self.resolve_variable_value(name, env_index=env_index); resolved_env[name] = value
				except KumirExecutionError as e:
					logger.warning(f"Skipping variable '{name}' for frontend state due to resolution error: {e}");
					resolved_env[name] = f"<ошибка: {e}>"
				except Exception as e:
					logger.error(f"Unexpected error resolving var '{name}' for frontend state: {e}"); resolved_env[
						name] = "<внутренняя ошибка>"
		return resolved_env
	def get_state(self):
		current_local_env_struct = self.call_stack[-1]['env'].copy() if self.call_stack else {};
		global_env_struct = self.global_env.copy()
		frontend_local_env = self._get_env_for_frontend(current_local_env_struct);
		frontend_global_env = self._get_env_for_frontend(global_env_struct)
		state = {"env": frontend_local_env, "global_env": frontend_global_env, "call_stack_depth": len(self.call_stack),
		         "width": self.width, "height": self.height, "robot": self.robot.robot_pos.copy(),
		         "walls": list(self.robot.walls),
		         "permanentWalls": list(self.robot.permanent_walls), "markers": self.robot.markers.copy(),
		         "coloredCells": list(self.robot.colored_cells),
		         "symbols": self.robot.symbols.copy(), "radiation": self.robot.radiation.copy(),
		         "temperature": self.robot.temperature.copy(), "output": self.output}
		return state
	def _get_resolved_env_for_evaluator(self):
		vars_only = {};
		current_env_index = self.get_current_env_index();
		current_env = self.get_env_by_index(current_env_index)
		env_keys_to_resolve = set(current_env.keys());
		if current_env_index != -1: env_keys_to_resolve.update(self.global_env.keys())
		for var_name in env_keys_to_resolve:
			try:
				value = self.resolve_variable_value(var_name); vars_only[var_name] = value
			except KumirExecutionError as e:
				logger.warning(f"Could not resolve value for variable '{var_name}' for evaluator: {e}. Skipping.")
			except Exception as e:
				logger.error(f"Unexpected error resolving variable '{var_name}' for evaluator: {e}. Skipping.",
				             exc_info=True)
		logger.debug(f"Resolved env vars for evaluator: {vars_only.keys()}")
		return vars_only
	def parse(self):
		# ... (код parse без изменений) ...
		self.logger.info("Starting code parsing...")
		try:
			lines = preprocess_code(self.code)
			if not lines: 
				self.logger.warning(
					"Code is empty after preprocessing.")
				self.introduction = []
				self.main_algorithm = None
				self.algorithms = {}
				return
			self.introduction, algo_sections = separate_sections(lines)
			self.logger.info(
				f"Separated into {len(self.introduction)} intro lines and {len(algo_sections)} algorithm sections.")
			if not algo_sections:
				self.logger.warning("No 'алг' sections found. Treating entire code as main algorithm body.")
				main_header = "алг main";
				self.main_algorithm = {"header": main_header, "body": self.introduction,
				                       "header_info": parse_algorithm_header(main_header)}
				self.introduction = [];
				self.algorithms = {}
			else:
				self.main_algorithm = algo_sections[0]
				try:
					self.main_algorithm["header_info"] = parse_algorithm_header(self.main_algorithm["header"])
					if not self.main_algorithm["header_info"].get("name"): self.main_algorithm["header_info"][
						"name"] = "__main__"; self.logger.debug("Assigning default name '__main__' to main algorithm.")
				except ValueError as header_err:
					raise KumirExecutionError(f"Ошибка в заголовке основного алгоритма: {header_err}")
				self.logger.debug(f"Parsed main algorithm header: {self.main_algorithm['header_info']}")
				self.algorithms = {}
				for alg_dict in algo_sections[1:]:
					try:
						header_info = parse_algorithm_header(alg_dict["header"]);
						alg_name = header_info.get("name")
						if alg_name:
							if alg_name in self.algorithms: self.logger.warning(f"Algorithm '{alg_name}' redefined.")
							self.algorithms[alg_name] = {"header_info": header_info, "body": alg_dict.get("body", [])}
							self.logger.debug(f"Parsed auxiliary algorithm '{alg_name}'.")
						else:
							self.logger.warning(
								f"Auxiliary algorithm without name found (header: '{header_info.get('raw', '')}'). Cannot be called.")
					except ValueError as header_err:
						self.logger.error(
							f"Error parsing aux algorithm header '{alg_dict.get('header', '')}': {header_err}"); self.logger.warning(
							f"Skipping aux algorithm due to header error.")
			self.logger.info("Code parsing completed successfully.")
		except (SyntaxError, KumirExecutionError) as e:
			self.logger.error(f"Parsing failed: {e}", exc_info=True); raise e
		except Exception as e:
			self.logger.error(f"Unexpected parsing error: {e}", exc_info=True); raise KumirExecutionError(
				f"Ошибка разбора программы: {e}")
	def interpret(self, progress_callback=None):
		"""Полный цикл: парсинг и выполнение кода Кумира."""
		# ... (код interpret без изменений, использует обновленные методы) ...
		self.trace = [];
		self.output = "";
		self.global_env = {};
		self.call_stack = []
		self.progress_callback = progress_callback;
		last_error_index = -1
		try:
			self.parse()
			if self.introduction:
				self.logger.info("Executing introduction (global scope)...")
				intro_indices = list(range(len(self.introduction)))
				execute_lines(self.introduction, self.global_env, self.robot, self, self.trace, self.progress_callback,
				              "introduction", intro_indices)
				self.logger.info("Introduction executed successfully.")
			else:
				self.logger.info("No introduction part to execute.")
			if self.main_algorithm and self.main_algorithm.get("body"):
				main_algo_name = self.main_algorithm.get("header_info", {}).get("name", "__main__")
				self.logger.info(f"Executing main algorithm '{main_algo_name}' (starting in global scope)...")
				main_body_indices = list(range(len(self.main_algorithm["body"])))
				execute_lines(self.main_algorithm["body"], self.global_env, self.robot, self, self.trace,
				              self.progress_callback, main_algo_name, main_body_indices)
				self.logger.info("Main algorithm executed successfully.")
			elif not self.main_algorithm:
				self.logger.warning("No main algorithm found after parsing.")
				if not self.introduction: raise KumirExecutionError("Программа не содержит исполняемого кода.")
			else:
				self.logger.info("Main algorithm body is empty.")
			if self.call_stack: self.logger.error(f"Execution finished but call stack is not empty: {self.call_stack}")
			self.logger.info("Interpretation completed successfully.")
			final_state = self.get_state();
			final_state["output"] = self.output
			return {"trace": self.trace, "finalState": final_state, "success": True}
		except KumirInputRequiredError as e:
			logger.info(f"Execution paused, input required for '{e.var_name}'.");
			self.output += f"Ожидание ввода для '{e.var_name}'...\n"
			state_at_input = self.get_state();
			state_at_input["output"] = self.output
			error_line_index = e.line_index if hasattr(e, 'line_index') else -1;
			last_error_index = error_line_index
			return {"trace": self.trace, "finalState": state_at_input, "success": False, "input_required": True,
			        "var_name": e.var_name, "prompt": e.prompt, "target_type": e.target_type,
			        "message": f"Требуется ввод для переменной '{e.var_name}'", "errorIndex": error_line_index}
		# Теперь обрабатываем все ожидаемые ошибки Кумира здесь
		except (
		KumirExecutionError, DeclarationError, AssignmentError, InputOutputError, KumirEvalError, RobotError) as e:
			error_msg = f"Ошибка выполнения: {str(e)}";
			error_line_index = getattr(e, 'line_index', -1);
			last_error_index = error_line_index
			self.logger.error(error_msg, exc_info=False);
			self.output += f"{error_msg}\n"
			try:
				state_on_error = self.get_state()
			except Exception as state_err:
				self.logger.error(f"Failed to get state after error: {state_err}");
				current_env_struct = self.call_stack[-1]['env'] if self.call_stack else self.global_env
				state_on_error = {"env": self._get_env_for_frontend(current_env_struct.copy()),
				                  "global_env": self._get_env_for_frontend(self.global_env.copy()), "robot": None,
				                  "output": self.output}
			state_on_error["output"] = self.output
			return {"trace": self.trace, "finalState": state_on_error, "success": False, "message": error_msg,
			        "errorIndex": error_line_index}
		except Exception as e:
			error_msg = f"Критическая внутренняя ошибка: {type(e).__name__} - {e}";
			self.logger.exception(error_msg);
			self.output += f"{error_msg}\n"
			try:
				state_on_error = self.get_state()
			except Exception as state_err:
				self.logger.error(f"Failed to get state after critical error: {state_err}");
				current_env_struct = self.call_stack[-1]['env'] if self.call_stack else self.global_env
				state_on_error = {"env": self._get_env_for_frontend(current_env_struct.copy()),
				                  "global_env": self._get_env_for_frontend(self.global_env.copy()), "robot": None,
				                  "output": self.output}
			state_on_error["output"] = self.output
			return {"trace": self.trace, "finalState": state_on_error, "success": False, "message": error_msg,
			        "errorIndex": last_error_index}
# FILE END: interpreter.py
FILE END: interpreter.py

FILE START: kumir_exceptions.py

# FILE START: kumir_exceptions.py
"""
Модуль для определения кастомных исключений интерпретатора Кумир.
Вынесен в отдельный файл для предотвращения циклических импортов.
"""
# Базовый класс для ошибок во время выполнения кода Кумира
class KumirExecutionError(Exception):
	def __init__(self, message, line_index=None, line_content=None):
		super().__init__(message)
		self.line_index = line_index
		self.line_content = line_content
	def __str__(self):
		base_message = super().__str__()
		context = ""
		if self.line_index is not None:
			context += f"строка {self.line_index + 1}"
		if self.line_content is not None:
			if self.line_index is not None:
				context += ":"
			context += f" '{self.line_content}'"
		return f"{base_message} ({context.strip()})" if context else base_message
# Ошибка, связанная с объявлениями
class DeclarationError(KumirExecutionError):
	pass
# Ошибка, связанная с присваиванием
class AssignmentError(KumirExecutionError):
	pass
# Ошибка, связанная с вводом/выводом
class InputOutputError(KumirExecutionError):
	pass
# Специальное исключение для запроса ввода
class KumirInputRequiredError(Exception):  # Не наследуем от KumirExecutionError, т.к. это не ошибка, а запрос
	def __init__(self, var_name, prompt, target_type):
		self.var_name = var_name
		self.prompt = prompt
		self.target_type = target_type
		message = f"Требуется ввод для переменной '{var_name}' (тип: {target_type}). Подсказка: {prompt}"
		# Сохраним line_index и line_content, если они будут добавлены
		self.line_index = None
		self.line_content = None
		super().__init__(message)
# Ошибка во время вычисления выражения (AST или safe_eval)
class KumirEvalError(KumirExecutionError):
	pass
# Ошибка, связанная с командами или состоянием робота
class RobotError(KumirExecutionError):
	pass
# Можно добавить другие специфичные ошибки при необходимости
# FILE END: kumir_exceptions.py
FILE END: kumir_exceptions.py

FILE START: kumir_globals.py

# FILE START: kumir_globals.py
"""
Модуль для определения глобально доступных функций и констант
в безопасном окружении вычисления выражений Кумира.
"""
import logging  # Добавим логгер и сюда, если нужно
import math
logger = logging.getLogger('KumirGlobals')
# Импорты функций из других модулей проекта
from .builtins import int_to_str, float_to_str, str_to_float, str_to_int, Int, Float, Bool
from .file_functions import (
	open_for_reading, open_for_writing, open_for_append, close_file, reset_reading, eof,
	has_data, set_encoding, can_open_for_reading, can_open_for_writing, exists, is_directory,
	create_directory, delete_file, delete_directory, full_path, WORKING_DIRECTORY,
	PROGRAM_DIRECTORY, set_input, set_output, console_file
)
from .math_functions import (sqrt, abs_val, iabs, sign, sin_val, cos_val, tan_val, cot, arcsin_val, arccos_val,
							 arctan_val, arccot, ln, lg, exp_val, min_val, max_val, imin, imax, div, mod, int_part, rnd,
							 rand, irnd, irand, max_int, max_float)
from .string_utils import (to_upper, to_lower, position, position_after, insert, replace_str,
						   delete_str)
from .system_functions import current_time  # , sleep_ms # sleep_ms все еще не рекомендуется
from .text_functions import length, char_code, unicode_code, char, unicode_char
# --->>> УДАЛЯЕМ ЭТУ СТРОКУ ИМПОРТА <<<---
# from .kumir_interpreter.interpreter import KumirLanguageInterpreter, KumirExecutionError, KumirEvalError # НЕ НУЖНО ЗДЕСЬ
# Глобальные переменные и функции, разрешенные для использования в выражениях Кумира.
SAFE_GLOBALS = {
	"__builtins__": None,  # Запрещаем встроенные функции Python по умолчанию
	# Математика
	"sin": sin_val, "cos": cos_val, "tan": tan_val, "cot": cot, "arcsin": arcsin_val, "arccos": arccos_val,
	"arctan": arctan_val, "arccot": arccot, "sqrt": sqrt, "ln": ln, "lg": lg, "exp": exp_val, "abs": abs_val,
	"iabs": iabs, "sign": sign, "int": int_part,  # 'int' теперь это KUMIR'овский int_part
	"min": min_val, "max": max_val, "imin": imin, "imax": imax, "div": div, "mod": mod,
	"rnd": rnd, "rand": rand, "irnd": irnd, "irand": irand,
	"МАКСЦЕЛ": max_int(), "MAX_INT": max_int(), "MAX_FLOAT": max_float(),
	"pi": math.pi, "e": math.e,
	# Встроенные Кумир (преобразования типов и т.д.)
	"цел_в_лит": int_to_str, "вещ_в_лит": float_to_str, "лит_в_цел": str_to_int, "лит_в_вещ": str_to_float,
	"Цел": Int, "Вещ": Float, "Лог": Bool,
	"да": True, "нет": False,
	# Строки
	"длин": length, "симв": char_code, "код": char_code, "юникод": unicode_code,
	"символ": char, "юнисимвол": unicode_char,
	"в_верхний_регистр": to_upper, "в_нижний_регистр": to_lower,
	"поз": position, "поз_после": position_after,
	"вставить": insert, "заменить": replace_str, "удалить": delete_str,
	# Система
	# "ждать": sleep_ms,
	"время": current_time,
	# Файловые функции (теперь безопасные внутри песочницы)
	"откр_для_чт": open_for_reading, "откр_для_зап": open_for_writing, "откр_для_доб": open_for_append,
	"закр": close_file, "сброс_чт": reset_reading, "eof": eof, "есть_данные": has_data,
	"уст_кодировку": set_encoding, "можно_откр_для_чт": can_open_for_reading,
	"можно_откр_для_зап": can_open_for_writing, "сущ": exists, "папка": is_directory,
	"создать_папку": create_directory, "удалить_файл": delete_file, "удалить_папку": delete_directory,
	"полный_путь": full_path, "РАБ_ПАПКА": WORKING_DIRECTORY, "ПАПКА_ПРОГРАММЫ": PROGRAM_DIRECTORY,
	"уст_ввод": set_input, "уст_вывод": set_output, "консоль": console_file,
	# Добавим базовые Python функции, которые могут быть полезны и безопасны
	"float": float,  # Для преобразования внутри выражений
	"int": int,  # Для преобразования внутри выражений (стандартный Python int)
	"str": str,  # Для преобразования в строку
}
logger.debug(f"SAFE_GLOBALS initialized with {len(SAFE_GLOBALS)} entries.")
# FILE END: kumir_globals.py
FILE END: kumir_globals.py

FILE START: main.py

"""
Модуль main.py
@description Основной исполняемый файл для интерпретатора языка KUMIR.
В этом модуле задается пример исходного кода программы на KUMIR, создается экземпляр интерпретатора,
выполняется интерпретация программы и выводятся результаты выполнения.
"""
from .interpreter import KumirLanguageInterpreter  # Импорт класса интерпретатора языка KUMIR
if __name__ == "__main__":
    # Пример исходного кода программы на языке KUMIR.
    # В примере присутствуют:
    #   - Вступительная часть с объявлениями переменных, присваиваниями и выводом.
    #   - Основной алгоритм (без имени) с вычислением площади, командами перемещения робота,
    #     циклическими конструкциями, командой паузы, прерыванием выполнения и остановкой.
    #   - Вспомогательный алгоритм (с именем "сумма"), который выводит сумму двух чисел.
    #   - Вызов вспомогательного алгоритма.
    sample_code = r'''
    | Это вступление
    цел длина, ширина, лог условие, лит мой текст
    длина := 10
    ширина := 15
    условие := да
    мой текст := "Пример текста"
    вывод "Вступление выполнено. Текст: ", мой текст, нс
    | Это основной алгоритм (без имени)
    алг
    нач
      вывод "Площадь равна: ", (длина * ширина), нс
      влево
      вправо
      вверх
      вниз
      закрасить
      нц 3 раз
         вывод "В цикле", нс
         пауза
         вывод "Циклический шаг", нс
         выход
      кц
      вывод "После цикла", нс
      вывод "Прерывание алгоритма", нс
      стоп
      вывод "Эта строка не выполнится", нс
    кон
    | Это вспомогательный алгоритм (вызовется из основного)
    алг сумма(вещ а, вещ б)
    нач
      вывод "Сумма = ", (а + б), нс
    кон
    | Вызов вспомогательной подпрограммы
    сумма(2.4, 7.6)
    '''
    # Создание экземпляра интерпретатора с примером исходного кода
    interpreter = KumirLanguageInterpreter(sample_code)
    # Интерпретация (парсинг и выполнение программы)
    result = interpreter.interpret()
    # Вывод результата работы интерпретатора:
    # результат включает обновленное окружение переменных, позицию робота и список закрашенных клеток.
    print("Результат:", result)
FILE END: main.py

FILE START: math_functions.py

import math
import random
import sys
"""
Модуль math_functions.py
@description Реализует математические функции для языка KUMIR.
В модуле представлены функции для вычисления квадратного корня, абсолютного значения, тригонометрических функций,
логарифмов, экспоненты, функций сравнения, целочисленного деления, генерации случайных чисел и другие.
Все функции снабжены подробными комментариями и докстрингами на русском языке.
"""
def sqrt(x):
    """
    Вычисляет квадратный корень числа x (при условии, что x >= 0).
    Параметры:
      x (float): Число, для которого необходимо вычислить квадратный корень.
    Возвращаемое значение:
      float: Квадратный корень числа x.
    Исключения:
      ValueError: Если x < 0, так как квадратный корень для отрицательных чисел не определён.
    """
    if x < 0:
        # Если аргумент отрицательный, генерируем ошибку
        raise ValueError("sqrt: argument must be non-negative")
    return math.sqrt(x)  # Вычисляем квадратный корень с использованием стандартной функции math.sqrt
def abs_val(x):
    """
    Вычисляет абсолютное значение числа x (подходит для чисел с плавающей точкой).
    Параметры:
      x (float): Число, для которого вычисляется абсолютное значение.
    Возвращаемое значение:
      float: Абсолютное значение x.
    """
    # Если x больше или равно 0, возвращаем его, иначе возвращаем -x
    return x if x >= 0 else -x
def iabs(x):
    """
    Вычисляет абсолютное значение целого числа x.
    Параметры:
      x (int): Число, для которого требуется вычислить абсолютное значение.
    Возвращаемое значение:
      int: Абсолютное значение числа x.
    """
    # Приводим значение к целому типу
    x = int(x)
    return x if x >= 0 else -x
def sign(x):
    """
    Определяет знак числа x.
    Параметры:
      x (float или int): Число, знак которого нужно определить.
    Возвращаемое значение:
      int: -1, если x < 0; 0, если x == 0; 1, если x > 0.
    """
    if x < 0:
        return -1
    elif x == 0:
        return 0
    else:
        return 1
def sin_val(x):
    """
    Вычисляет синус угла x (где x задается в радианах).
    Параметры:
      x (float): Значение угла в радианах.
    Возвращаемое значение:
      float: Синус угла x.
    """
    return math.sin(x)
def cos_val(x):
    """
    Вычисляет косинус угла x (где x задается в радианах).
    Параметры:
      x (float): Значение угла в радианах.
    Возвращаемое значение:
      float: Косинус угла x.
    """
    return math.cos(x)
def tan_val(x):
    """
    Вычисляет тангенс угла x (где x задается в радианах).
    Параметры:
      x (float): Значение угла в радианах.
    Возвращаемое значение:
      float: Тангенс угла x.
    """
    return math.tan(x)
def cot(x):
    """
    Вычисляет котангенс угла x (определён, если sin(x) != 0).
    Параметры:
      x (float): Значение угла в радианах.
    Возвращаемое значение:
      float: Котангенс угла x.
    Исключения:
      ValueError: Если sin(x) равен 0, так как операция не определена.
    """
    s = math.sin(x)
    if s == 0:
        raise ValueError("cot: sin(x) is 0, operation undefined")
    # Котангенс равен cos(x) / sin(x)
    return math.cos(x) / s
def arcsin_val(x):
    """
    Вычисляет арксинус числа x (при условии, что x принадлежит интервалу [-1, 1]).
    Параметры:
      x (float): Число, для которого вычисляется арксинус.
    Возвращаемое значение:
      float: Арксинус x в радианах.
    Исключения:
      ValueError: Если x не принадлежит интервалу [-1, 1].
    """
    if x < -1 or x > 1:
        raise ValueError("arcsin: x must belong to [-1,1]")
    return math.asin(x)
def arccos_val(x):
    """
    Вычисляет арккосинус числа x (при условии, что x принадлежит интервалу [-1, 1]).
    Параметры:
      x (float): Число, для которого вычисляется арккосинус.
    Возвращаемое значение:
      float: Арккосинус x в радианах.
    Исключения:
      ValueError: Если x не принадлежит интервалу [-1, 1].
    """
    if x < -1 or x > 1:
        raise ValueError("arccos: x must belong to [-1,1]")
    return math.acos(x)
def arctan_val(x):
    """
    Вычисляет арктангенс числа x.
    Параметры:
      x (float): Число, для которого вычисляется арктангенс.
    Возвращаемое значение:
      float: Арктангенс x в радианах.
    """
    return math.atan(x)
def arccot(x):
    """
    Вычисляет арккотангенс числа x.
    Для x = 0 возвращает π/2.
    Параметры:
      x (float): Число, для которого вычисляется арккотангенс.
    Возвращаемое значение:
      float: Арккотангенс x в радианах.
    """
    if x == 0:
        # При x == 0, определяем arccot как π/2
        return math.pi / 2
    if x > 0:
        # Для положительных x используем арктангенс обратного значения
        return math.atan(1 / x)
    else:
        # Для отрицательных x добавляем π, чтобы получить корректное значение
        return math.atan(1 / x) + math.pi
def ln(x):
    """
    Вычисляет натуральный логарифм числа x (x > 0).
    Параметры:
      x (float): Число, для которого вычисляется логарифм.
    Возвращаемое значение:
      float: Натуральный логарифм x.
    Исключения:
      ValueError: Если x <= 0.
    """
    if x <= 0:
        raise ValueError("ln: x must be > 0")
    return math.log(x)
def lg(x):
    """
    Вычисляет логарифм числа x по основанию 10 (x > 0).
    Параметры:
      x (float): Число, для которого вычисляется логарифм.
    Возвращаемое значение:
      float: Логарифм x по основанию 10.
    Исключения:
      ValueError: Если x <= 0.
    """
    if x <= 0:
        raise ValueError("lg: x must be > 0")
    return math.log10(x)
def exp_val(x):
    """
    Вычисляет экспоненту (e) в степени x.
    Параметры:
      x (float): Показатель степени.
    Возвращаемое значение:
      float: Значение exp(x), то есть e^x.
    """
    return math.exp(x)
def min_val(x, y):
    """
    Возвращает меньшее из двух чисел (с плавающей точкой).
    Параметры:
      x (float): Первое число.
      y (float): Второе число.
    Возвращаемое значение:
      float: Меньшее значение из x и y.
    """
    return x if x < y else y
def max_val(x, y):
    """
    Возвращает большее из двух чисел (с плавающей точкой).
    Параметры:
      x (float): Первое число.
      y (float): Второе число.
    Возвращаемое значение:
      float: Большее значение из x и y.
    """
    return x if x > y else y
def imin(x, y):
    """
    Возвращает меньшее из двух целых чисел.
    Параметры:
      x (int): Первое число.
      y (int): Второе число.
    Возвращаемое значение:
      int: Меньшее целое число из x и y.
    """
    return int(x) if int(x) < int(y) else int(y)
def imax(x, y):
    """
    Возвращает большее из двух целых чисел.
    Параметры:
      x (int): Первое число.
      y (int): Второе число.
    Возвращаемое значение:
      int: Большее целое число из x и y.
    """
    return int(x) if int(x) > int(y) else int(y)
def div(x, y):
    """
    Выполняет целочисленное деление x на y.
    Параметры:
      x (int или float): Делимое.
      y (int или float): Делитель.
    Возвращаемое значение:
      int: Результат целочисленного деления.
    Исключения:
      ZeroDivisionError: Если y равно 0.
    """
    if y == 0:
        raise ZeroDivisionError("div: division by zero")
    # Приводим аргументы к целому типу и выполняем целочисленное деление
    return int(x) // int(y)
def mod(x, y):
    """
    Вычисляет остаток от деления x на y.
    Параметры:
      x (int или float): Делимое.
      y (int или float): Делитель.
    Возвращаемое значение:
      int: Остаток от деления.
    Исключения:
      ZeroDivisionError: Если y равно 0.
    """
    if y == 0:
        raise ZeroDivisionError("mod: division by zero")
    return int(x) % int(y)
def int_part(x):
    """
    Возвращает целую часть числа x, то есть наибольшее целое число, не превышающее x.
    Параметры:
      x (float): Число, для которого требуется целая часть.
    Возвращаемое значение:
      int: Целая часть x.
    """
    return math.floor(x)
def rnd(x):
    """
    Возвращает случайное число с плавающей точкой из интервала [0, x].
    Параметры:
      x (float): Верхняя граница интервала.
    Возвращаемое значение:
      float: Случайное число от 0 до x.
    """
    # Функция random.random() возвращает число в диапазоне [0.0, 1.0)
    return random.random() * x
def rand(x, y):
    """
    Возвращает случайное число с плавающей точкой из интервала [x, y].
    Параметры:
      x (float): Нижняя граница интервала.
      y (float): Верхняя граница интервала.
    Возвращаемое значение:
      float: Случайное число от x до y.
    """
    return random.uniform(x, y)
def irnd(x):
    """
    Возвращает случайное целое число из интервала [0, x].
    Параметры:
      x (int или float): Верхняя граница интервала.
    Возвращаемое значение:
      int: Случайное целое число от 0 до x.
    """
    return random.randint(0, int(x))
def irand(x, y):
    """
    Возвращает случайное целое число из интервала [x, y].
    Параметры:
      x (int или float): Нижняя граница интервала.
      y (int или float): Верхняя граница интервала.
    Возвращаемое значение:
      int: Случайное целое число от x до y.
    """
    return random.randint(int(x), int(y))
def max_int():
    """
    Возвращает максимальное целое число, доступное в языке KUMIR.
    Возвращаемое значение:
      int: Максимальное значение 2147483647.
    """
    return 2147483647
def max_float():
    """
    Возвращает максимальное значение типа float, доступное в Python.
    Возвращаемое значение:
      float: Максимальное значение float из sys.float_info.max.
    """
    return sys.float_info.max
FILE END: math_functions.py

FILE START: robot_commands.py

# FILE START: robot_commands.py
"""
robot_commands.py
Описание: Обрабатывает и делегирует команды управления роботом.
"""
import logging
# Import RobotError from the new exceptions file
from .kumir_exceptions import RobotError
# SimulatedRobot нужен для проверки типа и вызова методов
from .robot_state import SimulatedRobot
logger = logging.getLogger('RobotCommands')
# Словарь для маппинга команд Кумира на методы объекта робота
ROBOT_ACTIONS = {
	"влево": "go_left",
	"вправо": "go_right",
	"вверх": "go_up",
	"вниз": "go_down",
	"закрасить": "do_paint"
	# "положить маркер": "put_marker", # Пример, если будет добавлено
	# "поднять маркер": "pick_marker", # Пример, если будет добавлено
}
def process_robot_command(line, robot):
	"""
	Пытается распознать и выполнить команду робота.
	Args:
		line (str): Строка кода, потенциально содержащая команду робота.
		robot (SimulatedRobot): Экземпляр симулированного робота.
	Returns:
		bool: True, если строка была распознана и (попытка) выполнения команды робота произведена, иначе False.
	Raises:
		RobotError: Если робот сообщает об ошибке (например, уперся в стену).
		AttributeError: Если команда найдена в словаре, но у робота нет такого метода.
	"""
	cmd = line.strip().lower()
	logger.debug(f"Attempting to process as robot command: '{cmd}'")
	if cmd in ROBOT_ACTIONS:
		method_name = ROBOT_ACTIONS[cmd]
		try:
			method_to_call = getattr(robot, method_name)
		except AttributeError:
			logger.error(f"Internal Error: Robot object lacks method '{method_name}' for command '{cmd}'")
			raise AttributeError(f"У объекта робота нет метода '{method_name}'")
		logger.info(f"Executing robot command: {cmd} (calling method {method_name})")
		try:
			method_to_call()  # Вызываем метод робота
			logger.debug(f"Robot command '{cmd}' executed successfully by robot object.")
			return True
		except RobotError as e:
			# Перехватываем и пробрасываем ошибки робота
			logger.warning(f"Robot command '{cmd}' failed: {e}")
			raise e  # Пробрасываем выше для обработки интерпретатором
		except Exception as e:
			# Перехватываем другие неожиданные ошибки
			logger.error(f"Unexpected error during robot command '{cmd}': {e}", exc_info=True)
			raise  # Пробрасываем выше
	else:
		logger.debug(f"'{cmd}' is not a known robot command.")
		return False
# FILE END: robot_commands.py
FILE END: robot_commands.py

FILE START: robot_state.py

# FILE START: robot_state.py
import logging
# Импортируем RobotError из нового файла
from .kumir_exceptions import RobotError
logger = logging.getLogger('SimulatedRobot')
# ... (остальной код логгера без изменений) ...
logger.propagate = False
if not logger.handlers:
	h = logging.StreamHandler()
	h.setFormatter(logging.Formatter('%(asctime)s - %(name)s:%(lineno)d - %(levelname)s - %(message)s'))
	logger.addHandler(h)
logger.setLevel(logging.INFO)  # Уровень можно настроить
# Определение RobotError УДАЛЕНО
class SimulatedRobot:
	""" Состояние и действия симулированного робота на поле. """
	def __init__(self, width, height, initial_pos=None, initial_walls=None, initial_markers=None,
	             initial_colored_cells=None, initial_symbols=None, initial_radiation=None,
	             initial_temperature=None):
		if not isinstance(width, int) or width < 1: raise ValueError("Width must be a positive integer")
		if not isinstance(height, int) or height < 1: raise ValueError("Height must be a positive integer")
		self.width = width
		self.height = height
		self.logger = logger
		# Используем _clamp_pos для инициализации, чтобы гарантировать корректность
		self.robot_pos = self._clamp_pos(initial_pos or {'x': 0, 'y': 0})
		# Гарантируем, что это множества
		self.walls = set(initial_walls) if initial_walls is not None else set()
		self.colored_cells = set(initial_colored_cells) if initial_colored_cells is not None else set()
		# Гарантируем, что это словари
		self.markers = dict(initial_markers) if initial_markers is not None else {}
		self.symbols = dict(initial_symbols) if initial_symbols is not None else {}
		self.radiation = dict(initial_radiation) if initial_radiation is not None else {}
		self.temperature = dict(initial_temperature) if initial_temperature is not None else {}
		self.permanent_walls = self._setup_permanent_walls()
		self.logger.info(
			f"Robot initialized: {width}x{height} at {self.robot_pos}. Walls: {len(self.walls)}, Markers: {len(self.markers)}, Colored: {len(self.colored_cells)}")
	def _clamp_pos(self, pos):
		# Гарантирует, что координаты находятся в пределах поля
		x = 0
		y = 0
		if isinstance(pos, dict):
			# Проверяем тип перед доступом
			raw_x = pos.get('x', 0)
			raw_y = pos.get('y', 0)
			try:
				x = int(raw_x)
			except (ValueError, TypeError):
				self.logger.warning(f"Invalid initial X position '{raw_x}', using 0.")
				x = 0
			try:
				y = int(raw_y)
			except (ValueError, TypeError):
				self.logger.warning(f"Invalid initial Y position '{raw_y}', using 0.")
				y = 0
		else:
			self.logger.warning(f"Invalid initial_pos format: {pos}. Using (0,0).")
		clamped_x = min(max(0, x), self.width - 1)
		clamped_y = min(max(0, y), self.height - 1)
		return {'x': clamped_x, 'y': clamped_y}
	def _setup_permanent_walls(self):
		# Создает множество строк, представляющих границы поля
		w = set()
		# Горизонтальные
		for x in range(self.width):
			w.add(f"{x},0,{x + 1},0")  # Верхняя граница
			w.add(f"{x},{self.height},{x + 1},{self.height}")  # Нижняя граница
		# Вертикальные
		for y in range(self.height):
			w.add(f"0,{y},0,{y + 1}")  # Левая граница
			w.add(f"{self.width},{y},{self.width},{y + 1}")  # Правая граница
		return w
	def reset(self, new_width=None, new_height=None):
		""" Resets robot state, optionally resizes. """
		# ... (код reset без изменений) ...
		if new_width is not None and isinstance(new_width, int) and new_width >= 1: self.width = new_width
		if new_height is not None and isinstance(new_height, int) and new_height >= 1: self.height = new_height
		self.robot_pos = {'x': 0, 'y': 0}
		self.walls.clear();
		self.markers.clear();
		self.colored_cells.clear()
		self.symbols.clear();
		self.radiation.clear();
		self.temperature.clear()
		self.permanent_walls = self._setup_permanent_walls()
		self.logger.info(f"Robot Reset: Field size {self.width}x{self.height}, Position {self.robot_pos}.")
	def _is_wall_between(self, x1, y1, x2, y2):
		""" Проверяет наличие стены (пользовательской или границы) между двумя соседними клетками. """
		wall_key = None
		# Определяем ключ стены в зависимости от направления
		if x2 > x1:  # Движение вправо
			wall_key = f"{x2},{y1},{x2},{y1 + 1}"  # Правая стена клетки (x1, y1)
		elif x1 > x2:  # Движение влево
			wall_key = f"{x1},{y1},{x1},{y1 + 1}"  # Левая стена клетки (x1, y1)
		elif y2 > y1:  # Движение вниз
			wall_key = f"{x1},{y2},{x1 + 1},{y2}"  # Нижняя стена клетки (x1, y1)
		elif y1 > y2:  # Движение вверх
			wall_key = f"{x1},{y1},{x1 + 1},{y1}"  # Верхняя стена клетки (x1, y1)
		if wall_key:
			# Проверяем наличие стены в пользовательских стенах и границах
			return wall_key in self.walls or wall_key in self.permanent_walls
		return False  # Нет движения или не соседние клетки
	def is_move_allowed(self, target_x, target_y):
		""" Проверяет, разрешено ли движение в целевую клетку. """
		# 1. Проверка выхода за границы поля
		if not (0 <= target_x < self.width and 0 <= target_y < self.height):
			self.logger.debug(
				f"Move denied: Target ({target_x},{target_y}) is outside field bounds (0..{self.width - 1}, 0..{self.height - 1}).")
			return False
		# 2. Проверка наличия стены между текущей и целевой клетками
		current_x, current_y = self.robot_pos["x"], self.robot_pos["y"]
		if self._is_wall_between(current_x, current_y, target_x, target_y):
			self.logger.debug(
				f"Move denied: Wall detected between ({current_x},{current_y}) and ({target_x},{target_y}).")
			return False
		# Если прошли все проверки - движение разрешено
		return True
	# --- Методы движения (используют is_move_allowed) ---
	def go_right(self):
		nx, ny = self.robot_pos["x"] + 1, self.robot_pos["y"]
		if self.is_move_allowed(nx, ny):
			self.robot_pos["x"] = nx
			self.logger.info(f"Moved Right -> ({nx},{ny})")
		else:
			raise RobotError("Стена/граница справа!")
	def go_left(self):
		nx, ny = self.robot_pos["x"] - 1, self.robot_pos["y"]
		if self.is_move_allowed(nx, ny):
			self.robot_pos["x"] = nx
			self.logger.info(f"Moved Left -> ({nx},{ny})")
		else:
			raise RobotError("Стена/граница слева!")
	def go_up(self):
		nx, ny = self.robot_pos["x"], self.robot_pos["y"] - 1
		if self.is_move_allowed(nx, ny):
			self.robot_pos["y"] = ny
			self.logger.info(f"Moved Up -> ({nx},{ny})")
		else:
			raise RobotError("Стена/граница сверху!")
	def go_down(self):
		nx, ny = self.robot_pos["x"], self.robot_pos["y"] + 1
		if self.is_move_allowed(nx, ny):
			self.robot_pos["y"] = ny
			self.logger.info(f"Moved Down -> ({nx},{ny})")
		else:
			raise RobotError("Стена/граница снизу!")
	# --- Метод закраски (без ошибки при повторе) ---
	def do_paint(self):
		""" Закрашивает текущую клетку. Не генерирует ошибку, если уже закрашена. """
		k = f"{self.robot_pos['x']},{self.robot_pos['y']}"
		if k in self.colored_cells:
			self.logger.debug(f"Cell {k} is already painted. No action taken.")  # Используем debug или info
		else:
			self.colored_cells.add(k)
			self.logger.info(f"Cell {k} painted.")
	# --- Сенсоры ---
	def check_direction(self, direction, status_to_check):
		"""
		Проверяет состояние в указанном направлении ('wall' или 'free').
		Использует _is_wall_between для проверки стен.
		"""
		cx, cy = self.robot_pos['x'], self.robot_pos['y']
		tx, ty = cx, cy  # Координаты целевой клетки
		if direction == "left":
			tx -= 1
		elif direction == "right":
			tx += 1
		elif direction == "up":
			ty -= 1
		elif direction == "down":
			ty += 1
		else:
			raise ValueError(f"Unknown direction for check: {direction}")
		# Проверяем, находится ли целевая клетка вне поля
		is_outside = not (0 <= tx < self.width and 0 <= ty < self.height)
		# Проверяем стену между текущей и целевой (если целевая в пределах поля)
		has_wall = False
		if not is_outside:
			has_wall = self._is_wall_between(cx, cy, tx, ty)
		# Определяем результат в зависимости от того, что проверяем
		if status_to_check == "wall":
			# Стена есть, если она существует ИЛИ если вышли за границу
			result = has_wall or is_outside
			self.logger.debug(
				f"Check '{direction} wall' from ({cx},{cy}): outside={is_outside}, wall_exists={has_wall} -> {result}")
			return result
		elif status_to_check == "free":
			# Свободно, только если НЕ вышли за границу И НЕТ стены
			result = not is_outside and not has_wall
			self.logger.debug(
				f"Check '{direction} free' from ({cx},{cy}): outside={is_outside}, wall_exists={has_wall} -> {result}")
			return result
		else:
			raise ValueError(f"Unknown status for check_direction: {status_to_check}")
	def check_cell(self, status_to_check):
		""" Проверяет состояние текущей клетки ('painted' или 'clear'). """
		k = f"{self.robot_pos['x']},{self.robot_pos['y']}"
		is_painted = k in self.colored_cells
		if status_to_check == "painted":
			self.logger.debug(f"Check 'cell painted' at {k}: {is_painted}")
			return is_painted
		elif status_to_check == "clear":
			self.logger.debug(f"Check 'cell clear' at {k}: {not is_painted}")
			return not is_painted
		else:
			raise ValueError(f"Unknown status for check_cell: {status_to_check}")
	def do_measurement(self, measure_type):
		""" Возвращает значение радиации или температуры в текущей клетке. """
		pos_key = f"{self.robot_pos['x']},{self.robot_pos['y']}"
		self.logger.debug(f"Measure '{measure_type}' at {pos_key}")
		if measure_type == "radiation":
			value = self.radiation.get(pos_key, 0.0)  # Default to 0.0
			self.logger.info(f"Radiation at {pos_key}: {value}")
			return float(value)
		elif measure_type == "temperature":
			value = self.temperature.get(pos_key, 0)  # Default to 0
			self.logger.info(f"Temperature at {pos_key}: {value}")
			return int(value)
		else:
			self.logger.warning(f"Unknown measurement type requested: {measure_type}. Returning 0.")
			# В оригинальном Кумире может быть ошибка, но возврат 0 безопаснее.
			# raise RobotError(f"Неизвестный тип измерения: {measure_type}")
			return 0
# FILE END: robot_state.py
FILE END: robot_state.py

FILE START: safe_eval.py

# FILE START: safe_eval.py
import ast
import logging
# Импортируем исключения из нового файла
from .kumir_exceptions import KumirEvalError, KumirExecutionError, RobotError
from .ast_evaluator import SafeEvaluator, EvaluationError
from .kumir_expression_translator import kumir_expr_to_python_expr, TranslationError
from .robot_state import SimulatedRobot
# УДАЛЯЕМ импорт KumirExecutionError из execution
# from .execution import KumirExecutionError
logger = logging.getLogger('KumirSafeEval')
# Определение KumirEvalError УДАЛЕНО отсюда
def get_robot_sensors(robot):
	"""Создает словарь функций-сенсоров робота для окружения."""
	if not robot or not isinstance(robot, SimulatedRobot):
		logger.warning("get_robot_sensors: Robot object is invalid or missing.")
		return {}
	sensors = {
		"слева_свободно": lambda: robot.check_direction("left", "free"),
		"справа_свободно": lambda: robot.check_direction("right", "free"),
		"сверху_свободно": lambda: robot.check_direction("up", "free"),
		"снизу_свободно": lambda: robot.check_direction("down", "free"),
		"слева_стена": lambda: robot.check_direction("left", "wall"),
		"справа_стена": lambda: robot.check_direction("right", "wall"),
		"сверху_стена": lambda: robot.check_direction("up", "wall"),
		"снизу_стена": lambda: robot.check_direction("down", "wall"),
		"клетка_закрашена": lambda: robot.check_cell("painted"),
		"клетка_чистая": lambda: robot.check_cell("clear"),
		"радиация": lambda: robot.do_measurement("radiation"),
		"температура": lambda: robot.do_measurement("temperature")
	}
	sensors["слевасвободно"] = sensors["слева_свободно"]
	sensors["справасвободно"] = sensors["справа_свободно"]
	sensors["сверхусвободно"] = sensors["сверху_свободно"]
	sensors["снизусвободно"] = sensors["снизу_свободно"]
	sensors["слевастена"] = sensors["слева_стена"]
	sensors["справастена"] = sensors["справа_стена"]
	sensors["сверхустена"] = sensors["сверху_стена"]
	sensors["снизустена"] = sensors["снизу_стена"]
	sensors["клетказакрашена"] = sensors["клетка_закрашена"]
	sensors["клеткачистая"] = sensors["клетка_чистая"]
	logger.debug(f"Generated robot sensors: {list(sensors.keys())}")
	return sensors
def safe_eval(kumir_expr, env, robot, interpreter):
	"""
	Безопасно вычисляет выражение Кумира через AST.
	Использует interpreter для получения разрешенного окружения.
	"""
	logger.info(f"Evaluating Kumir expression: '{kumir_expr}'")
	if interpreter is None:
		logger.error(f"safe_eval called without a valid interpreter instance for expression: '{kumir_expr}'")
		raise KumirEvalError("Внутренняя ошибка: отсутствует интерпретатор для вычисления выражения.")
	try:
		python_expr = kumir_expr_to_python_expr(kumir_expr)
		logger.debug(f"Translated to Python: '{python_expr}'")
		try:
			ast_node = ast.parse(python_expr, mode='eval')
		except SyntaxError as e:
			logger.error(
				f"Python Syntax Error after translation: {e}. Original: '{kumir_expr}', Translated: '{python_expr}'")
			raise KumirEvalError(
				f"Синтаксическая ошибка в выражении '{kumir_expr}' (транслировано в '{python_expr}'): {e}")
		except Exception as e:
			logger.exception(f"Unexpected error parsing translated expression '{python_expr}'")
			raise KumirEvalError(f"Ошибка разбора выражения '{python_expr}': {e}")
		env_vars = interpreter._get_resolved_env_for_evaluator()
		logger.debug(f"Environment variables provided to evaluator: {env_vars}")
		robot_sensors = get_robot_sensors(robot)
		evaluator = SafeEvaluator(env_vars=env_vars, robot_sensors=robot_sensors)
		result = evaluator.visit(ast_node)
		logger.info(f"Evaluation result for '{kumir_expr}': {result}")
		return result
	# Теперь KumirExecutionError импортируется из kumir_exceptions
	except (TranslationError, EvaluationError, RobotError, KumirExecutionError) as e:
		logger.error(f"Evaluation failed for '{kumir_expr}': {e}")
		raise KumirEvalError(str(e))
	except Exception as e:
		logger.exception(f"Unexpected error evaluating '{kumir_expr}'")
		raise KumirEvalError(f"Неожиданная ошибка при вычислении выражения '{kumir_expr}': {e}")
# FILE END: safe_eval.py
FILE END: safe_eval.py

FILE START: string_utils.py

"""
Модуль string_utils.py
@description Модуль для обработки строк в языке KUMIR.
Реализованы функции для преобразования регистра, поиска подстроки, вставки, замены и удаления символов в строках.
Функции соответствуют требованиям языка KUMIR и используются, например, в безопасном вычислении выражений.
"""
def upper_case(text):
    """
    Преобразует строку к верхнему регистру.
    Параметры:
      text (str): Исходная строка.
    Возвращаемое значение:
      str: Строка, в которой все символы приведены к верхнему регистру.
    """
    # Преобразуем текст в строку и вызываем метод upper() для получения строки в верхнем регистре
    return str(text).upper()
def lower_case(text):
    """
    Преобразует строку к нижнему регистру.
    Параметры:
      text (str): Исходная строка.
    Возвращаемое значение:
      str: Строка, в которой все символы приведены к нижнему регистру.
    """
    # Преобразуем текст в строку и вызываем метод lower() для получения строки в нижнем регистре
    return str(text).lower()
def position(substring, text):
    """
    Возвращает позицию (1-based) первого вхождения подстроки в текст.
    Если подстрока не найдена, возвращает 0.
    Параметры:
      substring (str): Искомая подстрока.
      text (str): Текст, в котором выполняется поиск.
    Возвращаемое значение:
      int: Позиция первого вхождения подстроки (начиная с 1) или 0, если подстрока не найдена.
    """
    # Преобразуем оба аргумента в строки
    s = str(text)
    sub = str(substring)
    # Используем метод find для поиска подстроки; возвращает индекс (начиная с 0) или -1, если не найдено
    idx = s.find(sub)
    # Если индекс не равен -1, прибавляем 1 для перехода к 1-based индексированию, иначе возвращаем 0
    return idx + 1 if idx != -1 else 0
# Alias для обратной совместимости: pos – альтернативное имя функции position
pos = position
def position_after(start, substring, text):
    """
    Ищет первое вхождение подстроки в тексте, начиная с заданной позиции (1-based).
    Если подстрока не найдена, возвращает 0.
    Параметры:
      start (int): Позиция, с которой начинается поиск (нумерация с 1).
      substring (str): Искомая подстрока.
      text (str): Текст, в котором выполняется поиск.
    Возвращаемое значение:
      int: Позиция первого вхождения подстроки (начиная с 1) после указанной позиции или 0, если подстрока не найдена.
    Исключения:
      ValueError: Если параметр start не является целым числом или выходит за пределы допустимого диапазона.
    """
    try:
        s_start = int(start)
    except Exception:
        raise ValueError("position_after: 'start' must be an integer")
    s = str(text)
    sub = str(substring)
    # Проверяем, что стартовая позиция находится в допустимом диапазоне
    if s_start < 1 or s_start > len(s) + 1:
        raise ValueError("position_after: 'start' is out of allowed range")
    # Метод find принимает второй аргумент – позицию, с которой начинать поиск (0-based)
    idx = s.find(sub, s_start - 1)
    return idx + 1 if idx != -1 else 0
def pos_after(start, substring, text):
    """
    Алиас для функции position_after.
    Параметры:
      start (int): Позиция, с которой начинается поиск.
      substring (str): Искомая подстрока.
      text (str): Текст, в котором выполняется поиск.
    Возвращаемое значение:
      int: Результат функции position_after.
    """
    return position_after(start, substring, text)
def insert(substring, text, start):
    """
    Вставляет подстроку в заданный текст, начиная с указанной позиции (1-based).
    Если значение start равно длине текста + 1, подстрока будет добавлена в конец.
    Генерирует ошибку, если значение start выходит за допустимый диапазон.
    Параметры:
      substring (str): Строка, которая будет вставлена.
      text (str): Исходный текст.
      start (int): Позиция (1-based), с которой начинается вставка.
    Возвращаемое значение:
      str: Результирующая строка после вставки.
    """
    s = str(text)
    sub = str(substring)
    try:
        s_start = int(start)
    except Exception:
        raise ValueError("insert: 'start' must be an integer")
    # Проверяем корректность позиции вставки: от 1 до len(s)+1
    if s_start < 1 or s_start > len(s) + 1:
        raise ValueError("insert: 'start' is out of allowed range")
    # Вставляем подстроку, разбивая исходный текст на две части
    return s[:s_start - 1] + sub + s[s_start - 1:]
def replace(text, old_sub, new_sub, every):
    """
    Заменяет подстроку old_sub на new_sub в тексте.
    Если параметр every (строка) равен "да" (без учета регистра) – заменяются все вхождения,
    если "нет" – заменяется только первое вхождение.
    Параметры:
      text (str): Исходный текст.
      old_sub (str): Подстрока, которую нужно заменить.
      new_sub (str): Подстрока-замена.
      every (str): Параметр, определяющий, заменять все вхождения ("да") или только первое ("нет").
    Возвращаемое значение:
      str: Результирующая строка после замены.
    Исключения:
      ValueError: Если параметр every не равен "да" или "нет".
    """
    s = str(text)
    old = str(old_sub)
    new = str(new_sub)
    # Приводим параметр every к нижнему регистру и убираем пробелы для сравнения
    if str(every).strip().lower() == "да":
        return s.replace(old, new)
    elif str(every).strip().lower() == "нет":
        return s.replace(old, new, 1)
    else:
        raise ValueError("replace: parameter 'every' must be 'да' or 'нет'")
def delete(text, start, count):
    """
    Удаляет указанное количество символов из текста, начиная с заданной позиции (1-based).
    Если сумма start и count превышает длину текста, удаляются все символы до конца строки.
    Генерирует ошибку, если значение start выходит за допустимый диапазон.
    Параметры:
      text (str): Исходный текст.
      start (int): Позиция (1-based), с которой начинается удаление.
      count (int): Количество символов для удаления.
    Возвращаемое значение:
      str: Результирующая строка после удаления.
    Исключения:
      ValueError: Если start или count не являются целыми числами или start выходит за допустимый диапазон.
    """
    s = str(text)
    try:
        s_start = int(start)
        cnt = int(count)
    except Exception:
        raise ValueError("delete: 'start' and 'count' must be integers")
    if s_start < 1 or s_start > len(s) + 1:
        raise ValueError("delete: 'start' is out of allowed range")
    # Если start+count превышает длину текста, возвращаем строку до start-1
    if s_start + cnt - 1 >= len(s) + 1:
        return s[:s_start - 1]
    else:
        # Удаляем count символов, объединяя оставшиеся части строки
        return s[:s_start - 1] + s[s_start - 1 + cnt:]
# Aliases для соответствия именам, ожидаемым в safe_eval.py
to_upper = upper_case
to_lower = lower_case
replace_str = replace
delete_str = delete
FILE END: string_utils.py

FILE START: system_functions.py

# FILE START: system_functions.py
import logging
import time
logger = logging.getLogger('KumirSystemFunctions')
def sleep_ms(x):
	"""
    Имитирует паузу. На сервере НЕ выполняет реальную задержку time.sleep(),
    чтобы не блокировать процесс. Просто логирует и возвращает None.
    Реальная пауза должна быть реализована на фронтенде при анимации трассировки.
    Параметры:
      x (int или число): Количество миллисекунд (игнорируется на бэкенде).
    Возвращаемое значение:
      None
    """
	try:
		ms = int(x)
		if ms < 0: ms = 0  # Отрицательная пауза не имеет смысла
	except Exception as e:
		# Если аргумент некорректен, логируем и считаем паузу нулевой
		logger.warning(f"sleep_ms: invalid argument '{x}', treating as 0ms. Error: {e}")
		ms = 0
	# НЕ ДЕЛАЕМ time.sleep() НА СЕРВЕРЕ
	logger.info(
		f"Kumir command 'ждать'/'sleep_ms'({ms}ms) encountered. Backend does nothing (handled by frontend animation).")
	# В Кумире это процедура, она ничего не возвращает
	return None
def current_time():
	"""
    Возвращает текущее время в миллисекундах, прошедших с полуночи (локальное время).
    Возвращаемое значение:
      int: Количество миллисекунд с начала текущего дня.
    """
	try:
		now = time.time()
		local = time.localtime(now)
		# Вычисляем секунды с полуночи
		seconds_since_midnight = local.tm_hour * 3600 + local.tm_min * 60 + local.tm_sec + (now - int(now))
		# Переводим в миллисекунды
		ms = int(seconds_since_midnight * 1000)
		return ms
	except Exception as e:
		logger.error(f"Error getting current time: {e}")
		return 0  # Возвращаем 0 в случае ошибки
# Алиасы для обратной совместимости (русские имена):
ждать = sleep_ms
время = current_time
# FILE END: system_functions.py
FILE END: system_functions.py

FILE START: text_functions.py

"""
Модуль text_functions.py
@description Модуль для функций обработки текста в языке KUMIR.
Реализованы следующие функции:
  - length(text): возвращает количество символов в строке.
  - char_code(c): возвращает порядковый номер символа c в кодировке CP-1251.
  - unicode_code(c): возвращает Unicode-код символа c.
  - char(n): возвращает символ, соответствующий коду CP-1251 n.
  - unicode_char(n): возвращает символ, соответствующий Unicode-коду n.
"""
def length(text):
    """
    Возвращает количество символов в строке.
    Пример:
      length("Привет") → 6
    Параметры:
      text (str): Исходная строка.
    Возвращаемое значение:
      int: Количество символов в строке.
    """
    # Приводим входной параметр к строковому типу и используем функцию len для подсчёта символов.
    return len(str(text))
# Alias для обратной совместимости:
длин = length
def char_code(c):
    """
    Возвращает порядковый номер символа c в кодировке CP-1251.
    Если c не является строкой длины 1, генерируется исключение.
    Пример:
      char_code("А") → 192  (в CP-1251 буква "А" имеет код 192)
    Параметры:
      c (str): Символ, для которого нужно получить код.
    Возвращаемое значение:
      int: Порядковый номер символа в кодировке CP-1251.
    Исключения:
      ValueError: Если входной аргумент не является строкой длины 1 или при ошибке кодирования.
    """
    s = str(c)
    if len(s) != 1:
        raise ValueError("Function 'char_code' expects a string of length 1")
    try:
        # Пробуем закодировать символ в кодировке CP-1251
        encoded = s.encode('cp1251')
    except Exception as e:
        raise ValueError(f"Error encoding character '{s}' in CP-1251: {e}")
    # Возвращаем первый байт, который и является кодом символа в данной кодировке
    return encoded[0]
# Alias для обратной совместимости:
код = char_code
def unicode_code(c):
    """
    Возвращает Unicode-код символа c.
    Пример:
      unicode_code("А") → 1040
    Параметры:
      c (str): Символ, для которого необходимо получить Unicode-код.
    Возвращаемое значение:
      int: Unicode-код символа.
    Исключения:
      ValueError: Если c не является строкой длины 1.
    """
    s = str(c)
    if len(s) != 1:
        raise ValueError("Function 'unicode_code' expects a string of length 1")
    # Используем встроенную функцию ord для получения Unicode-кода символа.
    return ord(s)
# Alias для обратной совместимости:
юникод = unicode_code
def char(n):
    """
    Возвращает символ, соответствующий коду n в кодировке CP-1251.
    Если число n не является корректным байтом, генерируется исключение.
    Пример:
      char(192) → "А"
    Параметры:
      n (int): Числовое значение, представляющее код символа в CP-1251.
    Возвращаемое значение:
      str: Символ, соответствующий заданному коду.
    Исключения:
      ValueError: Если число n не может быть корректно преобразовано в символ по CP-1251.
    """
    try:
        n_int = int(n)
        # Создаем объект bytes из одного байта и декодируем его с использованием кодировки CP-1251.
        b = bytes([n_int])
        return b.decode('cp1251')
    except Exception as e:
        raise ValueError(f"Error converting number {n} to a CP-1251 character: {e}")
# Alias для обратной совместимости:
символ = char
def unicode_char(n):
    """
    Возвращает символ, соответствующий Unicode-коду n.
    Пример:
      unicode_char(1040) → "А"
    Параметры:
      n (int): Числовое значение, представляющее Unicode-код символа.
    Возвращаемое значение:
      str: Символ, соответствующий заданному Unicode-коду.
    Исключения:
      ValueError: Если n не может быть корректно преобразовано в символ.
    """
    try:
        return chr(int(n))
    except Exception as e:
        raise ValueError(f"Error converting number {n} to a Unicode character: {e}")
# Alias для обратной совместимости:
юнисимвол = unicode_char
FILE END: text_functions.py
