# string_utils.py
"""
Модуль для алгоритмов обработки строк в языке Кумир.
Реализованы следующие функции:
  - верхний регистр(строка): возвращает строку, все символы которой приведены к верхнему регистру.
  - нижний регистр(строка): возвращает строку, все символы которой приведены к нижнему регистру.
  - позиция(фрагмент, строка) или поз(фрагмент, строка): возвращает позицию (1-based) первого символа подстроки,
      если не найдено — возвращает 0.
  - позиция после(начало, фрагмент, строка) или поз после(начало, фрагмент, строка): поиск подстроки начиная с указанной позиции.
  - вставить(фрагмент, строка, начало): вставляет фрагмент в строку начиная с указанной позиции (1-based).
  - заменить(строка, старый фрагмент, новый фрагмент, каждый): заменяет в строке старый фрагмент на новый;
      если параметр "каждый" равен "да" (без учета регистра) — заменяются все вхождения, если "нет" — только первое.
  - удалить(строка, начало, количество): удаляет из строки указанное количество символов, начиная с позиции (1-based).
"""


def верхний_регистр(строка):
    """Возвращает строку с приведёнными к верхнему регистру символами."""
    return str(строка).upper()


def нижний_регистр(строка):
    """Возвращает строку с приведёнными к нижнему регистру символами."""
    return str(строка).lower()


def позиция(фрагмент, строка):
    """
    Возвращает позицию первого символа подстроки фрагмент в строке строка (индексация с 1).
    Если фрагмент не найден, возвращает 0.
    """
    s = str(строка)
    sub = str(фрагмент)
    idx = s.find(sub)
    return idx + 1 if idx != -1 else 0


# Сокращённый вариант:
поз = позиция


def позиция_после(начало, фрагмент, строка):
    """
    Возвращает позицию первого символа подстроки фрагмент в строке строка,
    начиная поиск с позиции начало (индексация с 1).
    Если фрагмент не найден, возвращает 0.
    """
    try:
        start = int(начало)
    except Exception:
        raise ValueError("позиция после: 'начало' должно быть целым числом")
    s = str(строка)
    sub = str(фрагмент)
    if start < 1 or start > len(s) + 1:
        raise ValueError("позиция после: 'начало' вне допустимого диапазона")
    idx = s.find(sub, start - 1)
    return idx + 1 if idx != -1 else 0


def поз_после(начало, фрагмент, строка):
    """Сокращённый вариант функции 'позиция после'."""
    return позиция_после(начало, фрагмент, строка)


def вставить(фрагмент, строка, начало):
    """
    Вставляет фрагмент в строку, начиная с позиции начало (индексация с 1).
    Если начало равно длин(строка)+1, то фрагмент добавляется в конец строки.
    Если начало < 1 или начало > длин(строка)+1, возбуждается ошибка.
    """
    s = str(строка)
    sub = str(фрагмент)
    try:
        pos = int(начало)
    except Exception:
        raise ValueError("вставить: 'начало' должно быть целым числом")
    if pos < 1 or pos > len(s) + 1:
        raise ValueError("вставить: 'начало' вне допустимого диапазона")
    return s[:pos - 1] + sub + s[pos - 1:]


def заменить(строка, старый_фрагмент, новый_фрагмент, каждый):
    """
    Заменяет в строке все вхождения подстроки старый_фрагмент на новый_фрагмент, если параметр каждый равен "да"
    (без учета регистра). Если каждый равен "нет", заменяет только первое вхождение.
    """
    s = str(строка)
    old = str(старый_фрагмент)
    new = str(новый_фрагмент)
    if str(каждый).strip().lower() == "да":
        return s.replace(old, new)
    elif str(каждый).strip().lower() == "нет":
        return s.replace(old, new, 1)
    else:
        raise ValueError("заменить: параметр 'каждый' должен быть 'да' или 'нет'")


def удалить(строка, начало, количество):
    """
    Удаляет из строки указанное количество символов, начиная с позиции начало (индексация с 1).
    Если начало + количество > длин(строка)+1, то удаляется текст до конца строки.
    Если начало < 1 или начало > длин(строка)+1, возбуждается ошибка.
    """
    s = str(строка)
    try:
        pos = int(начало)
        count = int(количество)
    except Exception:
        raise ValueError("удалить: 'начало' и 'количество' должны быть целыми числами")
    if pos < 1 or pos > len(s) + 1:
        raise ValueError("удалить: 'начало' вне допустимого диапазона")
    if pos + count - 1 >= len(s) + 1:
        return s[:pos - 1]
    else:
        return s[:pos - 1] + s[pos - 1 + count:]
