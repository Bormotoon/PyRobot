# Заметки AI по проекту PyRobot

---

## Общая информация по проекту

* **Запуск тестов:**
  * Все тесты: `python -m pytest -v tests/test_functional.py`
  * Конкретный тест: `python -m pytest -v tests/test_functional.py -k "имя_файла.kum"`
  * Все файлы kum: `tests/polyakov_kum`
* **Документация по языку Кумир:** `kumir2-master/userdocs/`
* **Исходный код оригинального Кумира (C++):** `kumir2-master/src`
* **Наиболее важные исходники:** `kumir2-master/src/kumir2-libs`, `kumir2-master/src/plugins`

---

# Выдержки из документации КуМир

## Команда `вывод` (`simple_commands.xml`)

* **Синтаксис:** `вывод выражение-1, ... , выражение-N`
* **Поведение:**
  * Выводит значения выражений последовательно в одну строку **без разделителей**.
  * По умолчанию **НЕ** добавляет перенос строки (`\n`) в конце вывода.
* **Аргумент `нс`:**
  * Описан как "ключевое слово ... признак **перехода на новую строку**".
  * Использование `нс` в списке аргументов команды `вывод` добавляет символ переноса строки (`\n`) в том месте, где он указан.
  * Пример: `вывод "Строка1", нс, "Строка2"` выведет:

        ```
        Строка1
        Строка2
        ```

## Неявные переносы строк (`structure.xml`)

* Раздел "Неявные переносы строк" описывает правила **синтаксического анализатора** КуМира.
* Эти правила позволяют писать код более компактно (например, несколько команд на одной строке, разделенных `;` или без переносов вокруг `то`, `иначе`, `все`, `кц` и т.д.).
* **Важно:** Эти правила **не влияют** на форматирование **вывода** программы во время выполнения (в частности, на поведение команды `вывод`).

---

## Заметки по доработке интерпретатора КуМира

Задачи, которые нужно реализовать для прохождения тестов:

1. **Встроенные функции `irand` и `rand` (а также необъявленные идентификаторы типа `printBin`):**
    * Проблема: Интерпретатор не распознает `irand`, `rand`, `printBin` и т.п. как встроенные функции/процедуры или переменные, считает их необъявленными. **Частично решено:** Реализована обработка встроенных процедур, исправлена лямбда для `printbin`.
    * Файл теста: `tests/polyakov_kum/7-rand.kum` (и другие, вызвавшие ошибку `printBin`).
    * Место в коде: Вероятно, `visitPostfixExpression`, `visitPrimaryExpression`, `visitProcedureCallStatement` в `pyrobot/backend/kumir_interpreter/interpreter.py`. Обработка вызовов и поиск имен.

2. **Цикл `нц N раз`:**
    * Проблема: Интерпретатор вызывает `NotImplementedError`, так как этот тип цикла еще не реализован.
    * Файл теста: `tests/polyakov_kum/8-if.kum`
    * Место в коде: Ветка `elif loop_spec.expression():` в методе `visitLoopStatement` в `pyrobot/backend/kumir_interpreter/interpreter.py`.

3. **Оператор `выбор` (switch):**
    * Проблема: `KumirEvalError: ... Ошибка вычисления условия: 'NoneType' object has no attribute 'start'` (Изначально). Сейчас падает из-за **несовместимости типов при сравнении `<` (float и int)** (см. тест `12-switch.kum`) **или из-за отсутствия реальной логики switch** (заглушка `switch_value = None`) (см. тест `11-switch.kum`).
    * Файлы тестов: `11-switch.kum`, `12-switch.kum`.
    * Место в коде: `visitSwitchStatement` (требует исправления грамматики `KumirParser.g4`) и `_perform_binary_operation` (сравнение типов **ИСПРАВЛЕНО**, но сам switch не работает).

4. **Обработка переменных цикла:**
    * Проблема: `KumirEvalError: ... name 'X' is not defined` или похожие ошибки. **Частично решено:** Реализована локальная область видимости для `ДЛЯ`. Ошибки могут оставаться внутри тел циклов или для других типов циклов.
    * Файлы тестов: `13-loopN.kum`, `14-while.kum`, `17-for.kum` (и другие циклы).
    * Место в коде: `visitLoopStatement` в `interpreter.py`.

5. **Цикл `до` (repeat...until):** (**РЕШЕНО**)
    * Проблема: Цикл не был реализован.
    * Файл теста: `16-repeat.kum`.
    * Место в коде: `visitLoopStatement` в `interpreter.py`. (Логика добавлена).

6. **Проблема с чтением ввода (`\n`):** (**РЕШЕНО**)
    * Проблема: `KumirEvalError: ... invalid literal for int() with base 10: 'X\n'`. `input()` считывал `\n`.
    * Файлы тестов: `11-switch.kum`, `12-switch.kum` и другие с вводом.
    * Место в коде: `visitIoStatement` в `interpreter.py`. (Добавлено удаление `\\n`).

7. **Несоответствие вывода (AssertionError):**
    * Проблема: Фактический вывод не совпадает с ожидаемым. **Частично решено:** Исправлены ожидаемые/входные данные для тестов `13`, `14`, `16`, `17`, `18`, `19`. Добавлен `rstrip()` в test runner.
    * Файлы тестов: Некоторые тесты все еще могут падать из-за этого (`15-while.kum` - но там основная проблема в парсинге).
    * Решение: Нужно сравнить вывод с оригинальным КуМиром и скорректировать либо ожидаемый вывод в `TEST_CASES`, либо логику вывода в интерпретаторе.

8. **Ошибка парсинга файла `15-while.kum`:** (**АКТУАЛЬНО**)
    * Проблема: Парсер ANTLR не может обработать файл (`no viable alternative at input 'алгКоличествоцифрнач...'`).
    * Файл теста: `15-while.kum`.
    * Возможная причина: Проблема в грамматике `.g4` или сгенерированном лексере/парсере.
    * Решение: Требует глубокого анализа грамматики и, возможно, перегенерации парсера.

9. **Обработка вывода строковых литералов:** (**РЕШЕНО**)
    * Проблема: `KumirEvalError: ... Попытка вывести неинициализированное значение` при выводе строковых литералов (например, `"Привет"`). Ошибка возникала из-за того, что `visitStatement` не присваивал значение переменной `value` при обработке строки, и последующая проверка `if value is None:` ложно срабатывала.
    * Файл теста: `21-proc-bin.kum` (и другие, использующие вывод строк).
    * Место в коде: `visitStatement` в `interpreter.py`.
    * Решение: В ветке `elif arg_ctx.STRING():` теперь извлеченное строковое значение присваивается переменной `value`.

# Заметки по разработке

## 2024-03-21

1. Исправлена обработка встроенных процедур в методе `visitPostfixExpression`:
   * Добавлена проверка на встроенные процедуры перед проверкой пользовательских
   * Добавлена обработка количества аргументов для встроенных процедур
   * Исправлен вызов встроенных процедур с правильной передачей аргументов

2. Исправлена обработка условного оператора в методе `visitIfStatement`:
   * Добавлено извлечение значения из переменной для условия
   * Улучшена обработка ветвей "то" и "иначе"

3. Добавлена встроенная процедура `printBin`:
   * Реализована функция для вывода числа в двоичном виде
   * Добавлена поддержка форматирования с фиксированной шириной

TODO:

1. Исправить форматирование вывода в тесте `format.kum`
2. Исправить обработку оператора выбора в `switch.kum`
3. Исправить обработку циклов в `loopN.kum`, `while.kum`, `for.kum`, `downto.kum`
4. Исправить алгоритм поиска простых чисел в `prime.kum`

* **Отладка списка аргументов:**
  * Тест `7-rand.kum` упал с ошибкой "Неверное количество аргументов (2) для 'irand'". Поняли, что `visit(expressionList)` обрабатывал только первый аргумент.
  * Тест `21-proc-bin.kum` упал с "Неизвестное имя ... 'printBin'". Поняли, что это пользовательская процедура.
  * Реализовали метод `visitExpressionList` для корректной обработки списка аргументов. Потребовалось несколько попыток редактирования из-за ошибок модели.
  * **Исправление `visitExpressionList`:** Предыдущая реализация собирала слишком много аргументов (включая вложенные выражения). Исправили логику итерации по дочерним узлам.
  * **Текущее состояние:** Исправлена ошибка `Попытка присвоить значение None переменной 'n'` (тест `17-for.kum`) и большинство ошибок `Попытка вывести неинициализированное значение`, что позволило пройти многим ранее падавшим функциональным тестам (например, `2-2+2`, `4-a+b`, `6-format`, `8-if`, `10-and`, `11-switch`, `13-loopN`, `14-while`, `16-repeat`, `20-proc-err`, `21-proc-bin`)).

## 2024-03-22

1. Исправлена обработка аргументов функций в `visitExpressionList` (решена проблема с `7-rand.kum`).
2. Исправлена логика вывода в `visitStatement` для корректной обработки `нс` и добавления переноса строки в конце.
3. Исправлена обработка циклов в `visitLoopStatement`:
    * Добавлена поддержка `REPEAT...UNTIL` (цикл `ДО`).
    * Исправлен доступ к типу цикла (`TIMES`, `WHILE`, `FOR`) через дочерний узел `loopSpec`.
    * Улучшена обработка ошибок и граничных условий в циклах.
4. **Результат:** Исправлена ошибка `Попытка присвоить значение None переменной 'n'` (тест `17-for.kum`) и большинство ошибок `Попытка вывести неинициализированное значение`, что позволило пройти многим ранее падавшим функциональным тестам (например, `2-2+2`, `4-a+b`, `6-format`, `8-if`, `10-and`, `11-switch`, `13-loopN`, `14-while`, `16-repeat`, `20-proc-err`, `21-proc-bin`).
5. **Отладка `21-proc-bin.kum`:**
    * Столкнулись с ошибкой `Попытка вывести неинициализированное значение` в рекурсивной процедуре `_printBinRec` при выводе `x mod 2`.
    * Исправили ключ и лямбду для встроенной `printbin`, но это не помогло (вызывалась пользовательская процедура).
    * Тесты (`6-format`, `7-rand`, `8-if`, `9-if`) начали падать с новыми ошибками (`NoneType` has no len(), Попытка вывести None). Откатили исправление `printbin`.
    * Добавили множественные отладочные выводы, но они не показывались перед ошибкой или показывали, что `visit(x mod 2)` успешно возвращает `None`.
    * Выяснили, что проблема не в `x mod 2`, а в том, что `visitStatement` некорректно обрабатывал **строковые литералы** в операторе `вывод`. Он не присваивал строковое значение переменной `value`, из-за чего проверка `if value is None:` ложно срабатывала.
    * Исправили `visitStatement`, чтобы он корректно обрабатывал строки.
    * Убрали всю добавленную отладку.
6. **Текущее состояние:** Ошибка с выводом строк исправлена. Тест `21-proc-bin.kum` теперь проходит (хотя все тесты вместе все еще прерываются).

TODO:

1. Проверить тесты после исправлений вывода и циклов. **(Выполнено)**
2. Исправить **AssertionError: Неверный вывод** в тестах `15-while`, `18-downto`, `19-prime`. Вероятно, связано с ошибками парсинга.
3. Исправить **ошибки парсинга** (`no viable alternative`) в файлах, использующих процедуры, функции, массивы, рекурсию (например, `15-while`, `18-downto`, `19-prime`, `21-proc-bin`, `23-func-sumdig`, `27-rec-bin`, `39-arr-rev`, `44-arr-qsort`). Требует доработки грамматики `Kumir.g4`.
4. Исправить форматирование вывода в тесте `format.kum` (если проблема осталась). (**Похоже, решено предыдущими правками вывода**)
5. Исправить обработку оператора выбора в `switch.kum`. (**Похоже, решено**)
6. Исправить алгоритм поиска простых чисел в `prime.kum` (если проблема осталась). (**Проблема в парсинге, см. п.3**)
7. **Разобраться, почему прерывается полный запуск тестов `pytest -v`.**

## 2024-07-26

* Добавлен тест для `tests/polyakov_kum/1-primes.kum` в `tests/test_functional.py`.
  * Вход: `100\n`
  * Ожидаемый вывод: `'Введите максимальное число: Простые числа от 2 до 100: 2 3 5 7 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 83 89 97 \n'` (Текущий вывод нашего интерпретатора).
  * **Замечание:** Оригинальный КуМир может выводить результат немного иначе (с эхом ввода `100\n` и переносом строки после `:`). Текущий тест проверяет фактический вывод *нашего* интерпретатора и функции `run_kumir_program`.
* **TODO:** Точнее сверить поведение вывода (особенно `нс`, эхо ввода, финальные `\n`) с оригинальным КуМиром.
* **Верификация вывода по оригиналу:**
  * `'1-empty.kum'` (вход: `None`): Оригинал ничего не выводит. Текущий тест (`expected_output = ''`) **корректен**.
  * `'1-primes.kum'` (вход: `'100\n'`): Оригинал выводит промпт, затем эхо ввода на новой строке, затем заголовок результата на новой строке, затем числа через пробел и финальный `\n`. Тест обновлен на `expected_output = 'Введите максимальное число: 100\nПростые числа от 2 до 100:\n2 3 5 7 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 83 89 97 \n'`.
  * `'2-2+2.kum'` (вход: `None`): Оригинал выводит `2+2=?\nОтвет: 4\n` (согласно файлу вывода). Тест обновлен на `expected_output = '2+2=?\nОтвет: 4\n'`.
  * `'2-longnum.kum'` (вход: `None`): Оригинал выводит заголовок и факториал на двух строках с финальным `\n`. Тест **добавлен** с `expected_output = 'Факториал числа 100:\n93326215443944152681699238856266700490715968264381621468592963895217599993229915608941463976156518286253697920827223758251185210916864000000000000000000000000\n'`.
  * `'3-a+b.kum'` (вход: `'2\n3\n'`): Оригинал выводит эхо ввода (`2 3`) и результат (`5`) на двух строках с финальным `\n`. Тест обновлен на `expected_output = '2 3\n5\n'`.
  * `'4-a+b.kum'` (вход: `'10\n20\n'`): Оригинал выводит промпт, затем эхо ввода (`10 20`) на той же строке с `\n`, затем результат (`10+20=30`) на новой строке с финальным `\n`. Тест обновлен на `expected_output = 'Введите два целых числа: 10 20\n10+20=30\n'`.
  * `'6-format.kum'` (вход: `None`): Оригинал выводит три строки с форматированными числами, каждая с `\n`. Текущий тест (`expected_output = '>  123<\n1.2345678\n>  1.235<\n'`) **корректен**.
  * `'7-rand.kum'` (вход: `None`): Вывод программы случаен. Текущий тест (`expected_output = None`) **корректен**, так как он проверяет только успешный запуск без ошибок (валидация вызова `irand`, `rand`).
  * `'8-if.kum'` (вход: `'5\n7\n'`): Оригинал выводит промпт, затем эхо ввода (`5 7`) на той же строке с `\n`, затем заголовок и 4 результата (каждый с `\n`). Тест обновлен на `expected_output = 'Введите два целых числа: 5 7\nМаксимальное число:\n7\n7\n7\n7\n'`.
  * `'9-if.kum'` (вход: `'-3\n5\n'`): Оригинал выводит промпт, затем эхо ввода (`-3 5`) на той же строке с `\n`, затем результат (`Борис старше`) на новой строке с `\n`. Тест обновлен на `expected_output = 'Введите возраст Андрея и Бориса: -3 5\nБорис старше\n'`.
  * `'10-and.kum'` (вход: `'27\n'`): Оригинал выводит промпт, затем эхо ввода (`27`) на той же строке с `\n`, затем результат (`подходит`) на новой строке с `\n`. Тест обновлен на `expected_output = 'Введите возраст: 27\nподходит\n'`.
  * `'11-switch.kum'` (вход: `'2\n'`): Оригинал выводит промпт, затем эхо ввода (`2`) на той же строке с `\n`, затем результат (`февраль`) на новой строке с `\n`. Тест обновлен на `expected_output = 'Введите номер месяца: 2\nфевраль\n'`.
  * `'12-switch.kum'` (вход: `'7\n'`): Оригинал выводит эхо ввода (`7`) и результат (`1`) на двух строках с финальным `\n`. Тест обновлен на `expected_output = '7\n1\n'`.
  * `'13-loopN.kum'` (вход: `'5\n'`): Оригинал выводит промпт, затем эхо ввода (`5`) на той же строке с `\n`, затем 5 строк результата (`привет`), каждая с `\n`. Тест обновлен на `expected_output = 'Сколько раз сделать? 5\nпривет\nпривет\nпривет\nпривет\nпривет\n'`.
  * `'14-while.kum'` (вход: `'5\n'`): Вывод идентичен `13-loopN.kum`. Тест обновлен на `expected_output = 'Сколько раз сделать? 5\nпривет\nпривет\nпривет\nпривет\nпривет\n'`.
  * `'15-while.kum'` (вход: `'12345\n'`): Оригинал выводит промпт, затем эхо ввода (`12345`) на той же строке с `\n`, затем результат (`Цифр в числе: 5`) на новой строке с `\n`. Тест обновлен на `expected_output = 'Введите целое число: 12345\nЦифр в числе: 5\n'`.
  * `'16-repeat.kum'` (вход: `'-1\n0\n2\n'`): Оригинал выводит промпт, затем эхо первого ввода (`-1`) на той же строке с `\n`, затем эхо второго (`0`) и третьего (`2`) вводов на отдельных строках с `\n`, затем две строки результата (каждая с `\n`). Тест обновлен на `expected_output = 'Введите целое положительное число: -1\n0\n2\nВведено число 2\n  и до него 2 ошибочных значений(я)\n'`.
  * `'17-for.kum'` (вход: `'5\n'`): Оригинал выводит эхо ввода (`5`) и результат (`2 4 8 16 32`) на двух строках с финальным `\n` (и пробелом перед ним). Тест обновлен на `expected_output = '5\n2 4 8 16 32 \n'`.
  * `'18-downto.kum'` (вход: `'5\n'`): Оригинал выводит эхо ввода (`5`) и результат (`32 16 8 4 2`) на двух строках с финальным `\n` (и пробелом перед ним). Тест обновлен на `expected_output = '5\n32 16 8 4 2 \n'`.
  * `'19-prime.kum'` (вход: `'17\n'`): Оригинал выводит промпт, эхо ввода (`17`) на той же строке с `\n`, затем результат (`Простые числа: 2 3 5 7 11 13 17`) на новой строке с `\n` (и пробелом перед ним). Тест обновлен на `expected_output = 'Введите максимальное число: 17\nПростые числа: 2 3 5 7 11 13 17 \n'`.
  * `'20-proc-err.kum'` (вход: `'-1\n'`): Оригинал выводит эхо ввода (`-1`) и сообщение об ошибке (`Ошибка программы`) на двух строках с финальным `\n`. Тест обновлен (вход и вывод) на `expected_output = '-1\nОшибка программы\n'`.
  * `'21-proc-bin.kum'` (вход: `'13\n'`): Оригинал выводит промпт, эхо ввода (`13`) на той же строке с `\n`, затем результат (`Двоичный код: 00001101`) на новой строке с `\n`. Тест обновлен на `expected_output = 'Введите натуральное число: 13\nДвоичный код: 00001101\n'`.
  * `'22-swap.kum'` (вход: `'2\n3\n'`): Оригинал выводит промпт, эхо ввода (`2 3`) на той же строке с `\n`, затем результат обмена (`После обмена: x=3 y=2`) на новой строке с `\n`. Тест **добавлен** с `expected_output = 'Введите два целых числа: 2 3\nПосле обмена: x=3 y=2\n'`.
  * `'23-func-sumdig.kum'` (вход: `'12345\n'`): Оригинал выводит промпт, эхо ввода (`12345`) на той же строке с `\n`, затем результат (`Сумма цифр 15`) на новой строке с `\n`. Тест **добавлен** с `expected_output = 'Введите целое число: 12345\nСумма цифр 15\n'`.
  * `'24-func-prime.kum'` (вход: `'15\n'`): Оригинал выводит промпт, эхо ввода (`15`) на той же строке с `\n`, затем результат (`Простые числа: 2 3 5 7 11 13`) на новой строке с `\n` (и пробелом перед ним). Тест **добавлен** с `expected_output = 'Введите максимальное число: 15\nПростые числа: 2 3 5 7 11 13 \n'`.
  * `'25-func-prime.kum'` (вход: `'5\n7\n12\n'`): Оригинал чередует промпт+эхо (на одной строке с `\n`) и результат ("N - простое число\n" с `нс`->`\n`) пока вводятся простые числа. Последний промпт+эхо не дает результата. Тест **добавлен** с `expected_output = 'Введите число: 5\n5 - простое число\nВведите число: 7\n7 - простое число\nВведите число: 12\n'`.

## Анализ поведения `вывод` и `нс` (2024-07-26) - Обновлено

* **Документация (`simple_commands.xml`) и примеры:**
  * Текст: "Значения выражений выводятся последовательно в строку области ввода-вывода **без разделителей**."
  * Текст: "Ключевое слово `нс` ... является признаком **перехода на новую строку**."
  * Пример `вывод а, " ", б, "Привет!", нс` внутри цикла печатает каждую итерацию на новой строке.
  * **Эта интерпретация противоречит выводу `

## 2024-07-29 (Продолжение)

* **Попытка исправить вывод строк (1):**
  * Гипотеза: `visitStatement` неверно обрабатывает строки в `ioArgumentList`.
  * Правка: Добавили проверку на `arg_ctx.STRING()` перед `arg_ctx.expression()`.
  * Результат: `AttributeError: 'IoArgumentContext' object has no attribute 'STRING'`. Ошибка синтаксиса/логики в проверке.
* **Попытка исправить вывод строк (2):**
  * Правка: Доработали логику в `visitStatement`, чтобы проверять, является ли `expression` простым строковым литералом, через обход дерева (`primaryExpression` -> `literal` -> `STRING`).
  * Результат: Правка не применилась инструментом (`reapply` тоже не помог). Подозрение на ошибку в самом инструменте или слишком сложном коде правки.
* **Попытка исправить вывод строк (3):**
  * Пользователь указал на неточность в коде `visitStatement` (не было строки `value = self.visit(arg_ctx.expression())`).
  * Правка: Новая попытка скорректировать `visitStatement` для обработки строковых литералов.
  * Результат: Правка применилась, но с синтаксическими ошибками (перенос строк).
* **Попытка исправить вывод строк (4):**
  * Правка: Исправлены синтаксические ошибки в `visitStatement`.
  * Результат: Запуск тестов показал новую ошибку `ValueError: invalid literal for int() with base 10: '...'`.
* **Исправление ошибки ввода (`ValueError`):**
  * Причина: В `TEST_CASES` в `tests/test_functional.py` для входных данных использовался `\\n` вместо `\n`.
  * Правка: Исправили все `\\n` на `\n` в `input_data` в `TEST_CASES`.
  * Результат: Ошибка `ValueError` ушла.
* **Исправление ошибки с параметрами (`AttributeError: ... has no attribute 'parameterVariableList'`):**
  * Причина: Неправильный доступ к списку переменных параметра в `visitPostfixExpression`.
  * Правка: Исправили доступ к `variableList` через `parameterDeclaration -> variableList -> variableDeclarationItem`.
  * Результат: Ошибка `AttributeError` ушла, но появилась новая `TypeError: object of type 'NoneType' has no len()` в том же месте.
* **Исправление ошибки с аргументами (`TypeError: 'NoneType' object has no len()`):**
  * Причина: Отсутствовал метод `visitArgumentList` для обработки списка аргументов при вызове процедур/функций. `visitPostfixExpression` получал `None` вместо списка.
  * Правка: Добавили метод `visitArgumentList` (потребовалось несколько попыток из-за проблем инструмента редактирования).
  * Результат: Ошибка `TypeError` ушла, но появилась `AttributeError: 'KumirInterpreterVisitor' object has no attribute '_format_output_value'` при выводе.
* **Исправление ошибки форматирования (`AttributeError: ... no attribute '_format_output_value'`):**
  * Причина: Забыли реализовать метод `_format_output_value`.
  * Правка: Добавили реализацию `_format_output_value` для обработки `:Ш:Т`.
  * Результат: Ошибка `AttributeError` ушла. Тест `22-swap.kum` теперь падает с `AssertionError` (неверный вывод - нет эха ввода, не работает `арг рез`).

## 2024-07-30 (Продолжение)

* **Исправление `AssertionError` для `3-a+b.kum` и `22-swap.kum`:**
    * Причина: Лишний `\\n` в конце вывода, добавляемый функцией `run_kumir_program`, и случайный отладочный вывод `[DEBUG][ArgList]` в `visitArgumentList`.
    * Правки:
        1. Убрали `print` из `visitArgumentList` в `pyrobot/backend/kumir_interpreter/interpreter.py`.
        2. Убрали строку `result += '\\n'` из `run_kumir_program` в `tests/test_functional.py`.
    * Результат: Тесты `3-a+b.kum` и `22-swap.kum` **ПРОЙДЕНЫ**.

## Текущий статус и TODO (2024-07-30) - Итог дня

Запустили все тесты. **6 PASSED, 50 FAILED**. (*После нескольких запусков и исправлений финального `\n`*)

**Пройденные тесты:**

* `1-empty.kum`
* `3-empty.kum`
* `5-types.kum`
* `9-or.kum`
* `3-a+b.kum`
* `22-swap.kum`
* `9-if.kum`

**Основные проблемы:**

1.  **Массивы/Матрицы (`NotImplementedError`):** (15 тестов). **Приоритет: Высокий.**
2.  **Неинициализированные значения (`KumirEvalError: Попытка вывести...`)**: (12 тестов). **Приоритет: Высокий.**
3.  **Синтаксические ошибки (`KumirSyntaxError`)**: Парсер не понимает конструкции (12 тестов). **Приоритет: Высокий.**
4.  **Цикл `нц ... раз` (`AttributeError: ... 'REPEAT'`)**: (3 теста). **Приоритет: Средний.**
5.  **Ошибки присваивания (`KumirExecutionError: Ошибка присваивания...`)**: (5 тестов). **Приоритет: Средний.**
6.  **Вызов функций/процедур (разные `KumirEvalError`)**: (6 тестов).
7.  **Ошибки условий/выбора (`KumirEvalError`)**: (4 теста).
8.  **`AssertionError: Неверный вывод для ...`**: (3 теста: `15`, `18`, `19`).
9.  **Другие ошибки:** Форматирование (`6`, `7`).

**Ближайшие задачи (План):**

1.  ~~Исправить передачу параметров `арг рез`.~~ **(СДЕЛАНО)**
2.  ~~Исправить эхо ввода.~~ **(СДЕЛАНО)**
3.  ~~Исправить `AssertionError` для `3-a+b.kum`, `22-swap.kum`.~~ **(СДЕЛАНО)**
4.  ~~Исправить регрессию `AssertionError` для `9-if.kum` (финальный `\n`).~~ **(СДЕЛАНО)**
5.  Реализовать поддержку **массивов (таблиц)**.
6.  Исправить ошибку `Попытка вывести неинициализированное значение...`.
7.  Исправить **синтаксические ошибки** (доработка грамматики `.g4`).
8.  Исправить распознавание цикла `нц ... раз`.
9.  Исправить ошибки присваивания (строки).
10. Исправить ошибки вызова функций/процедур.
11. Проанализировать оставшиеся `AssertionError` и другие ошибки.

## 2024-07-31: Работа над замечаниями к PR в antlr/grammars-v4 (Продолжение)

Проанализированы дополнительные замечания `kaby76`:

*   **Лишние скобки:**
    *   Скрипт `find-useless-parentheses.sh` указал на множество скобок в `KumirLexer.g4` и несколько в `KumirParser.g4`.
    *   **Parser:** Скобки в `KumirParser.g4` (`(typeSpecifier)?`, `(algorithmName)?`, `(qualifiedIdentifier)?`) признаны **не лишними**, так как используются для явного обозначения опциональности одиночных правил. **Изменения не вносились.**
    *   **Lexer:** Скобки в `KumirLexer.g4` для правил вида `TOKEN : ('лит1' | 'лит2');` были признаны **избыточными**. Внесены правки для удаления этих скобок, где это было применимо (для простых альтернатив).
*   **Токены `AT` и `ATAT`:**
    *   Замечено, что `@` и `@@` не определены как токены и не используются в парсере.
    *   Принято решение **не добавлять** их, так как они не относятся к стандартному школьному синтаксису КуМира, на котором сфокусирована грамматика.
*   **Правило `postfixExpression`:**
    *   Первоначальная интерпретация комментария `kaby76` была неверной. Его дифф показывал *ошибочное* изменение, а не предлагал его. Наше текущее правило `postfixExpression : primaryExpression ( LBRACK indexList RBRACK | LPAREN argumentList? RPAREN )*` **корректно** и оставлено без изменений.

## Текущий статус и TODO (2024-07-31) - Обновлено

**Тесты парсера (`tests/test_parser.py`):** 48 PASSED, 12 FAILED (ложная ошибка на EOF из-за вероятного бага ANTLR, **отложено**).

**Функциональные тесты (`tests/test_functional.py`)** (статус от 2024-07-30):
*   6 PASSED, 50 FAILED.

**Основные проблемы (приоритеты обновлены):**

1.  **Массивы/Матрицы (`NotImplementedError`):** (15 тестов в `test_functional.py`). **Приоритет: Высокий.**
2.  **Неинициализированные значения (`KumirEvalError: Попытка вывести...`)**: (12 тестов в `test_functional.py`). **Приоритет: Высокий.**
3.  **Оставшиеся ошибки парсера (`KumirSyntaxError`)**: (12 тестов в `test_parser.py`). Парсер не принимает `EOF` в конце файла. **Приоритет: Низкий (отложено).**
4.  **Цикл `нц ... раз` (`AttributeError: ... 'REPEAT'`)**: (3 теста в `test_functional.py`). **Приоритет: Средний.**
5.  **Ошибки присваивания (`KumirExecutionError: Ошибка присваивания...`)**: (5 тестов в `test_functional.py`). **Приоритет: Средний.**
6.  **Вызов функций/процедур (разные ошибки)**: (~4 теста в `test_functional.py`). **Приоритет: Средний.**
7.  **Тип REAL (`AssertionError`, `KumirRunError`)**: (~2 теста в `test_functional.py`). **Приоритет: Низкий.**
8.  **Другие ошибки:** Форматирование (`6`, `7` в `test_functional.py`). **Приоритет: Низкий.**

## 2024-08-01: Продолжение работы над PR grammars-v4 (Issue #4477)

- **`kumir_lang/KumirParser.g4`**: 
    - В правило `multiplicativeExpression` добавлены операторы `DIV_OP` и `MOD_OP` для полноты описания языка. Теперь оно выглядит так: `powerExpression ((MUL | DIV | DIV_OP | MOD_OP) powerExpression)*`.
    - Правило `program` оставлено без изменений (`programItem* (moduleDefinition | algorithmDefinition)+ EOF`), так как оно соответствует требованию наличия хотя бы одного определения в программе КуМир.
- **Синхронизация:** Правило `multiplicativeExpression` в проектном файле `pyrobot/backend/kumir_interpreter/grammar/KumirParser.g4` уже содержало `DIV_OP` и `MOD_OP`, поэтому дополнительных изменений в нем не потребовалось.
- **TODO:** Перегенерировать файлы парсера/лексера ANTLR для проекта и для `kumir_lang` после всех изменений грамматики.

- **`kumir_lang/KumirLexer.g4`**:
    - В правиле (фрагменте) `ExpFragment` удалены кириллические `еЕ` в пользу только латинских `eE` (`[eE] [+-]? DIGIT+`), так как опция `caseInsensitive = true` делает их избыточными. Соответствующее изменение внесено.

## 2024-08-01 (вечер): Анализ GitHub Issue #4830 (NoViableAltException at EOF)

- **Проблема:** Пользователь создал Issue `https://github.com/antlr/antlr4/issues/4830` по поводу 12 тестов парсера, падающих с `NoViableAltException` на токене `<EOF>`, несмотря на то, что трассировка парсера показывает успешный выход из стартового правила `program`.
- **Комментарий `kaby76`:**
    - Указал, что грамматика, приведенная в Issue, содержит Python-предикат в правиле `algorithmNameTokens`.
    - Этот предикат исполняется только Python-рантаймом и может быть источником проблем.
- **Анализ:**
    - Проверка файла `pyrobot/backend/kumir_interpreter/grammar/KumirParser.g4` показала, что правило `algorithmNameTokens` **уже исправлено** и не содержит Python-предиката. Оно выглядит так: `~(LPAREN | ALG_BEGIN | PRE_CONDITION | POST_CONDITION | SEMICOLON | EOF)+`.
    - Это означает, что причина ошибки `NoViableAltException` на EOF не в предикате `algorithmNameTokens`, а в чем-то другом.
    - Пользователю рекомендовано обновить текст Issue на GitHub, указав, что проблема воспроизводится и с версией грамматики без предиката.
- **Вывод:** Проблема с EOF остается открытой и, возможно, связана с более глубокими особенностями Python-рантайма ANTLR или самой грамматикой, как предполагалось ранее. Решение отложено до появления новых идей или ответов на GitHub.

## 2024-08-02: Решение проблемы с `div`/`mod` и ошибки `EOF` в парсере

- **Проблема:** 12 тестов парсера падали с ошибками `NoViableAltException` на токене `<EOF>` или `no viable alternative at input 'алг...'`. Функциональные тесты также показывали большое количество `KumirSyntaxError`.
- **Гипотеза 1 (неверная):** Проблема в `DIV_OP` и `MOD_OP` в лексере, которые конфликтуют с `ID` при разборе вызовов функций `div(...)` и `mod(...)`.
    - Попытка: Закомментировать `DIV_OP`, `MOD_OP` в лексере и использовать предикаты `ID {self._input.LT(1).text.lower() == 'div'}?` в `multiplicativeExpression`.
    - Результат: Предикаты не работали корректно (ошибки `name 'op_id' is not defined` или `failed predicate`).
- **Гипотеза 2 (верная):** В языке КуМир `div` и `mod` являются **только функциями**, а не инфиксными операторами.
    - **Решение:**
        1.  В `KumirLexer.g4`: `DIV_OP` и `MOD_OP` **закомментированы**. Слова `div` и `mod` распознаются как `ID`.
        2.  В `KumirParser.g4`: Правило `multiplicativeExpression` изменено на `powerExpression ((MUL | DIV) powerExpression)*`, т.е. обрабатывает только `*` и `/` как инфиксные операторы. `div` и `mod` будут парситься как вызовы функций через `postfixExpression` -> `primaryExpression` -> `ID`.
    - **Результат:**
        - **Все 60 тестов парсера (`tests/test_parser.py`) теперь ПРОХОДЯТ!** Ошибки `EOF` и `no viable alternative` исчезли.
        - Это подтвердило, что предыдущие проблемы парсинга были связаны с неверной трактовкой `div` и `mod` как операторов.
- **Сопутствующие исправления в `interpreter.py`:**
    - Удалены `KumirLexer.MOD_OP` (и `DIV_OP`, если был) из словаря `ARITHMETIC_OPS`.
    - Удалены блоки `elif op_token.type in [KumirLexer.MOD_OP]:` из методов `_perform_binary_operation` и `visitMultiplicativeExpression`.
- **Статус функциональных тестов (`tests/test_functional.py`) после исправления парсера:**
    - **5 PASSED, 51 FAILED**.
    - Основные ошибки:
        - `NotImplementedError: Массивы пока не поддерживаются` (многочисленные).
        - `AttributeError: 'LoopStatementContext' object has no attribute 'REPEAT'` (циклы `нц для ... повторять`).
        - `KumirEvalError: Попытка вывести неинициализированное значение`.
        - `KumirExecutionError: ... Попытка присвоить значение None`.
        - `KumirEvalError: Процедура или функция '...' не определена` (например, `mod`, `позиция`).
    - Функциональные тесты: **51 failed, 5 passed** (без изменений, проблема с `NoneType` в `28-rec-sumdig.kum` при вызове `mod`/`div` после рекурсивного вызова `sum_digits`).
    - Подготовлен комментарий для [GitHub Issue #4830](https://github.com/antlr/antlr4/issues/4830) об успешном решении проблемы с ошибками EOF в парсере.

**Следующие шаги:**
1.  Синхронизировать изменения грамматики (`div`/`mod` как функции) с файлами в `kumir_lang/` для PR #4477.
2.  Реализовать встроенные функции `mod(a,b)` (остаток от деления) и `div(a,b)` (целочисленное деление) в `BUILTIN_FUNCTIONS` в `interpreter.py`.
3.  Приступить к реализации поддержки массивов (`NotImplementedError`).
4.  Исправить ошибку с циклами `REPEAT` (`AttributeError`).


---

## 2024-08-02 (вечер): Отладка `28-rec-sumdig.kum` - проблема с `NoneType`

**Проблема:**
Тест `28-rec-sumdig.kum` падает с ошибкой `KumirEvalError: Строка ~14: Ошибка типа при передаче аргумента №1 в параметр 'n': Нельзя присвоить значение типа NoneType переменной типа ЦЕЛ`.
Это происходит при вызове `sumDig(N)` (где `N` - это аргумент основной программы, например, `12345`).

**Детальный анализ "путешествия" значения `N`:**
1.  Вычисляется аргумент `N` для вызова `sumDig(N)`. Для этого вызывается `visitExpression(N)`.
2.  `visitExpression(N)` делегирует вычисление цепочке: `visitLogicalOrExpression(N)` -> `visitLogicalAndExpression(N)` -> `visitEqualityExpression(N)` -> ... -> `visitPrimaryExpression(N)`.
3.  `visitPrimaryExpression(N)` корректно определяет, что `N` - это переменная, и возвращает ее значение (например, `12345`).
4.  Это значение (`12345`) успешно "всплывает" обратно по цепочке до `visitEqualityExpression(N)`, который также возвращает `12345`.
5.  **Сбой:** `visitLogicalAndExpression(N)` получает `12345` от `visitEqualityExpression(N)`. Однако, вместо того чтобы просто вернуть это значение (поскольку в `N` нет оператора "И"), он возвращает `None`.
6.  Далее `visitLogicalOrExpression(N)` получает `None` и также возвращает `None`.
7.  В итоге, `visitExpression(N)` возвращает `None`.
8.  Это значение `None` передается как аргумент в `sumDig`, вызывая ошибку типа.

**Анализ простым языком:**

Хорошо, давай попробуем еще раз разобраться, что именно ломается, максимально просто.

Представь, что наша программа – это большой конвейер по вычислению значений.
Когда программа видит команду `вывод sumDig(N)`, она должна сначала понять, чему равен аргумент `N`.

1.  **Задача для `N`**: "Эй, интерпретатор, какое значение у `N`?"
    *   Это задание попадает к главному "вычислителю выражений" (наш метод `visitExpression`).
    *   Этот главный вычислитель говорит: "`N` — это простое выражение, пусть им займется мой подчиненный, специалист по `LogicalOrExpression` (это один из типов выражений в грамматике)."

2.  **Работа "младших специалистов"**:
    *   "Специалист по `LogicalOrExpression`" получает задачу `N`. Он видит, что `N` — это не что-то сложное с операциями `ИЛИ`. Он передает задачу дальше по цепочке: специалисту по `LogicalAndExpression`, тот — специалисту по `EqualityExpression`, и так далее, пока задача не дойдет до самого-самого "младшего специалиста" по `PrimaryExpression`.
    *   Этот "младший специалист по `PrimaryExpression`" смотрит на `N` и говорит: "Ага, это переменная! Я знаю ее значение. `N` равно `12345`." И он возвращает это число `12345`.
    *   Это число `12345` успешно передается обратно наверх по всей цепочке "младших специалистов". Каждый из них, получив `12345`, просто передает его дальше. В итоге, "специалист по `LogicalOrExpression`" тоже получает и возвращает `12345`.

3.  **Возвращение к главному "вычислителю выражений" (`visitExpression`):**
    *   Наш главный "вычислитель выражений" (`visitExpression`) получает от своего подчиненного (`visitLogicalOrExpression`) совершенно правильный результат: `12345`. Он кладет это число в коробочку с надписью `result`.
    *   **И вот тут происходит необъяснимое!** Прямо перед тем, как главный "вычислитель выражений" должен объявить финальный ответ "Значение `N` это `12345`!", число `12345` из коробки `result` исчезает, и там оказывается `None` (то есть "ничего").
    *   В итоге, `visitExpression` возвращает `None` вместо `12345`.

4.  **Последствия**:
    *   Поскольку `visitExpression` для `N` вернул `None`, функция `sumDig` вызывается как `sumDig(None)`.
    *   Внутри `sumDig`, когда она пытается сделать, например, `mod(n, 10)` (где `n` теперь `None`), возникает ошибка, потому что `mod(None, 10)` — это бессмыслица.

**В чем загадка?**

Загадка в том, *почему* значение `12345`, которое совершенно правильно вычисляется и передается всеми "младшими специалистами" вплоть до `visitLogicalOrExpression`, превращается в `None` именно в тот момент, когда `visitExpression` получает его от `self.visit(ctx.logicalOrExpression())` и сохраняет в `result`.

Мы это проверили: `visitLogicalOrExpression` (и все, кто под ним) **возвращают** `12345`. Но в `visitExpression` переменная `result` **сразу после** строки `result = self.visit(ctx.logicalOrExpression())` уже содержит `None`.

Это очень странное поведение. Похоже на то, что сам механизм `self.visit()`, когда его вызывает `visitExpression` для определенного типа дочернего узла, как-то теряет или портит возвращаемое значение. Почему это происходит только в этой комбинации вызовов — пока неясно. Это может быть какая-то очень тонкая особенность работы визитора ANTLR в Python или что-то в нашей иерархии вызовов, что мы упускаем.

Проблема не в том, что твои отдельные методы `visitLogicalOrExpression` или `visitPrimaryExpression` неправильно работают (они как раз возвращают то, что нужно), а в том, что это правильное значение "теряется" при передаче в `result` внутри `visitExpression`.

Может, такое подробное описание натолкнет тебя на мысль, что может идти не так? Или, может, мы сможем придумать, как заставить `visitExpression` не "терять" это значение.


**Ключевой вопрос:** Почему `visitLogicalAndExpression` (и, возможно, `visitLogicalOrExpression`) возвращают `None`, когда им передается корректное значение от дочернего узла, и в самом выражении нет соответствующего логического оператора (`И` / `ИЛИ`)?

**Предложение пользователя по улучшению отладки:**
Внедрить более детализированное логирование, имитирующее "переговоры между специалистами". Каждый "специалист" (метод `visit...`) должен логировать:
*   Что он ожидает получить от другого "специалиста".
*   Что он фактически получил.
*   Какой результат он сам возвращает и кому.

Пример такого лога:
Есть возможность на каждом из шагов записывать что только что произошло? То есть как если бы каждый из "специалистов" записывал в общий журнал:
1. Специалист 1: Я отдаю следующему специалисту N
2. Специалист 2: Ожидаю получить от Специалиста 1 объект определённого типа.
3. Специалист 2: Я получил от Специалиста 1 N.
4. Специалист 2: Я изучаю N.
5. Специалист 2: N — это переменная. Значение N = 12345.
6. Специалист 2: Я отдаю значение N (12345) выше по инстанции — Специалисту 1.
7. Специалист 1: Ожидаю получить от Специалиста 2 тип объекта, его имя и его значение.
8. Специалист 2: Отдаю Специалисту 1 объект N, тип — переменная, значение 12345.
9. Специалист 1: Получен объект типа "переменная", с именем "N", со значением "12345". 

Это должно помочь точнее отследить, на каком этапе "передачи данных" происходит потеря значения.

---

## 2024-07-30 (Продолжение)

## TODOs and Future Work

- interpreter.py: Review `current_scope` access for `RETURN_VALUE` in `visitPrimaryExpression` to ensure it correctly handles context (e.g., not in a function/procedure scope).
- interpreter.py: Ensured `value` is always defined in `visitPostfixExpression` before being assigned to `current_eval_value` after processing user-defined procedures.

## Session Notes (YYYY-MM-DD)

- YYYY-MM-DD: Fixed linter errors in `interpreter.py` related to indentation, try-except-finally blocks, and an `else` statement. Specifically addressed issues around lines 947-1025 and 1567.

---

## 2024-08-02 (продолжение): Детальное логирование выражений

**Задача:** Внедрить подробное логирование в методы обхода выражений для отслеживания "путешествия" значения `N` в тесте `28-rec-sumdig.kum`.

**Реализация:**
Добавлено подробное логирование (через `print` с префиксом `[DEBUG][visitMethodName]`) в следующие методы файла `pyrobot/backend/kumir_interpreter/interpreter.py`:
*   `visitExpression`
*   `visitLogicalOrExpression`
*   `visitLogicalAndExpression`
*   `visitEqualityExpression`
*   `visitRelationalExpression`
*   `visitAdditiveExpression`
*   `visitMultiplicativeExpression`
*   `visitPowerExpression`
*   `visitUnaryExpression`
*   `visitPrimaryExpression`
*   `visitLiteral`

Каждый логирующий вызов фиксирует:
*   Имя вызванного метода.
*   Контекст (текст узла), для которого он вызван.
*   Значение, полученное от дочерних вызовов (если применимо), и его тип.
*   Возвращаемое значение и его тип.

**Ожидаемый результат:** Логи должны помочь точно определить, на каком этапе и в каком методе происходит потеря или некорректное изменение значения переменной `N` или результатов вызова функций `mod`/`div`.

**Результаты тестирования `28-rec-sumdig.kum` (после добавления логирования):**
*   **Тест упал.**
*   **Ошибка:** `TypeError: KumirParser.PowerExpressionContext.unaryExpression() takes 1 positional argument but 2 were given`
    *   **Место:** `pyrobot/backend/kumir_interpreter/interpreter.py`, строка 813, в методе `visitPowerExpression` при вызове `result = self.visit(ctx.unaryExpression(0))`.
    *   **Причина:** Метод `ctx.unaryExpression()` (сгенерированный ANTLR) не принимает индекс как аргумент (`0`) напрямую. Вместо этого, `ctx.unaryExpression` следует вызывать без аргументов для получения списка всех дочерних узлов `unaryExpression`, а затем уже этот список индексировать (например, `list[0]`, `list[1]`).
*   **Предложенное исправление:**
    ```python
    # В visitPowerExpression:
    unary_expressions = ctx.unaryExpression() # Получить список
    if not unary_expressions:
        raise KumirEvalError(...)
    result = self.visit(unary_expressions[0]) # Индексировать список
    # ...
    if len(unary_expressions) > 1:
        exponent_ctx = unary_expressions[1] # Индексировать список
        exponent = self.visit(exponent_ctx)
    # ...
    ```
*   **Второстепенная ошибка:** `OSError: [WinError 6] Неверный дескриптор` при попытке печати в `sys.__stderr__` в `test_functional.py` после основного исключения. Не критично для логики интерпретатора.
*   *Анализ логов (если ошибка NoneType сохранилась после исправления TypeError): Место для анализа новых логов.*

**Повторный запуск теста `28-rec-sumdig.kum` (после исправления первой TypeError):**
*   **Тест снова упал.**
*   **Ошибка:** `TypeError: 'UnaryExpressionContext' object is not subscriptable`
    *   **Место:** `pyrobot/backend/kumir_interpreter/interpreter.py`, строка ~819, в методе `visitPowerExpression` при вызове `result = self.visit(unary_expressions[0])` (после первого исправления).
    *   **Причина:** Предыдущее исправление предполагало, что `ctx.unaryExpression()` всегда возвращает список. Однако, если в грамматике `powerExpression` определено так, что `unaryExpression` может встречаться один раз (без операции степени) или дважды (с операцией степени), то `ctx.unaryExpression()` вернет одиночный объект `UnaryExpressionContext` в первом случае и список объектов во втором.
    *   **Предложенное исправление (вторая попытка):**
        ```python
        # В visitPowerExpression:
        unary_expressions_or_obj = ctx.unaryExpression()
        first_unary_expr_ctx = None
        exponent_ctx = None

        if isinstance(unary_expressions_or_obj, list):
            if not unary_expressions_or_obj:
                raise KumirEvalError(...)
            first_unary_expr_ctx = unary_expressions_or_obj[0]
            if len(unary_expressions_or_obj) > 1:
                exponent_ctx = unary_expressions_or_obj[1]
        elif unary_expressions_or_obj: # Это одиночный объект UnaryExpressionContext
            first_unary_expr_ctx = unary_expressions_or_obj
        else:
            raise KumirEvalError(...)

        result = self.visit(first_unary_expr_ctx)
        # ...
        if exponent_ctx:
            exponent = self.visit(exponent_ctx)
        # ...
        ```
*   *Анализ логов (если ошибка NoneType сохранилась после исправления второй TypeError): Место для анализа новых логов.*

**Повторный запуск теста `28-rec-sumdig.kum` (после исправления второй TypeError):**
*   **Тест снова упал.**
*   **Ошибка:** `KumirEvalError: Строка 19, столбец 5: Ошибка вычисления условия: 'KumirInterpreterVisitor' object has no attribute '_handle_type_promotion_for_comparison'`
    *   **Место:** `pyrobot/backend/kumir_interpreter/interpreter.py`, строка 1316, в методе `visitIfStatement` при вызове `self.visit(condition_ctx)`, который глубже вызывает `visitRelationalExpression`, который, в свою очередь, пытается вызвать `_handle_type_promotion_for_comparison`.
    *   **Причина:** Отсутствовал метод `_handle_type_promotion_for_comparison` в классе `KumirInterpreterVisitor`. Вероятно, он был случайно удален во время предыдущих автоматических правок.
    *   **Решение:** Восстановлен метод `_handle_type_promotion_for_comparison`. Он отвечает за приведение типов (например, `цел` к `вещ`) при операциях сравнения.
        ```python
        def _handle_type_promotion_for_comparison(self, left, right, ctx):
            if left is None or right is None:
                raise KumirEvalError(
                    f"Строка ~{ctx.start.line}: Нельзя сравнивать с неинициализированным значением.",
                    ctx.start.line,
                    ctx.start.column
                )
            is_left_int = isinstance(left, int)
            is_left_float = isinstance(left, float)
            is_right_int = isinstance(right, int)
            is_right_float = isinstance(right, float)
            if is_left_int and is_right_float:
                return float(left), right
            if is_left_float and is_right_int:
                return left, float(right)
            return left, right
        ```

**Повторный запуск теста `28-rec-sumdig.kum` (после восстановления `_handle_type_promotion_for_comparison`):**
*   **Тест снова упал.**
*   **Ошибка:** `AttributeError: 'KumirInterpreterVisitor' object has no attribute 'current_scope'`
    *   **Место:** `pyrobot/backend/kumir_interpreter/interpreter.py`, строка 1689 (в старой нумерации, до добавления `_handle_type_promotion_for_comparison`), в методе `visitPrimaryExpression`.
    *   **Контекст:**
        ```python
        elif ctx.RETURN_VALUE():
            if 'return_value' not in self.current_scope: # Ошибка здесь
                raise KumirEvalError("Попытка использования неинициализированного возвращаемого значения")
            result = self.current_scope['return_value']
        ```
    *   **Причина:** Атрибут `self.current_scope` не существует. Вместо него для доступа к текущей области видимости следует использовать `self.scopes[-1]`, так как `self.scopes` – это стек (список) словарей областей видимости.
    *   **Отладочный `print` в `__init__`:**
        *   Добавленный `print(f"[DEBUG][INIT] ... dir(self) ...")` в `__init__` показал пустой список методов `[]`, что странно и требует отдельного изучения, но не связано напрямую с этой `AttributeError`.
    *   **Решение:** Заменить `self.current_scope` на `self.scopes[-1]` в соответствующем блоке метода `visitPrimaryExpression`.
        ```python
        elif ctx.RETURN_VALUE():
            current_scope_dict = self.scopes[-1]
            if 'return_value' not in current_scope_dict:
                raise KumirEvalError("Попытка использования неинициализированного возвращаемого значения")
            result = current_scope_dict['return_value']
        ```
    *   **Примечание по отладке:** Отладочные `print` для `type(self)` и `hasattr` в `visitRelationalExpression` и `visitEqualityExpression` показали, что `self` является корректным объектом `KumirInterpreterVisitor` и *имеет* атрибут `_handle_type_promotion_for_comparison` непосредственно перед предыдущей ошибкой `AttributeError`. Текущая ошибка `KumirEvalError` из-за неинициализированного `знач` является более понятной.

---

## Отладка `28-rec-sumdig.kum` (продолжение)

**Проблема:** Тест снова падает, но с другой ошибкой. Теперь это `KumirEvalError: Попытка использовать неинициализированное возвращаемое значение`.

**Контекст:**

После всех предыдущих правок, когда мы пытались запустить тест `28-rec-sumdig.kum`, он упал с ошибкой `KumirEvalError` в строке, где происходит присвоение `знач := ...` (в `visitAssignmentStatement`). Ошибка указывает на то, что `знач` не инициализировано.

**Что мы проверили и сделали:**
1.  **Проверка и восстановление `_handle_type_promotion_for_comparison`:**
    *   Мы восстановили метод `_handle_type_promotion_for_comparison` в `KumirInterpreterVisitor`, который отвечает за приведение типов при операциях сравнения.
    *   Этот метод теперь корректно обрабатывает ситуации, когда одно из значений `None`, и возбуждает `KumirEvalError` с соответствующим сообщением.

2.  **Проверка `current_scope` и `return_value`:**
    *   Мы исправили доступ к `current_scope` в `visitPrimaryExpression`, заменив `self.current_scope` на `self.scopes[-1]`.
    *   Также был исправлен ключ для доступа к возвращаемому значению процедуры с `'return_value'` на `'__знач__'`.

3.  **Проблема с `KumirEvalError: Попытка использовать неинициализированное возвращаемое значение`:**
    *   Эта ошибка возникает, когда интерпретатор пытается использовать значение, которое еще не было инициализировано или присвоено.
    *   В нашем случае, это происходит в результате некорректной обработки команды `выход` или возврата значения из процедуры.

4.  **Исправление логики `visitExitStatement`:**
    *   Мы переписали логику в `visitExitStatement`, чтобы она корректно обрабатывала команду `выход` в зависимости от контекста (внутри цикла, процедуры или основного блока).
    *   Теперь, если `выход` вызывается внутри процедуры и не в цикле, он должен корректно завершать выполнение процедуры.

5.  **Исправление `_execute_procedure_call`:**
    *   Мы обернули вызов тела процедуры `self.visit(alg_body_ctx)` в блок `try...except ProcedureExitCalled: pass`, чтобы корректно обрабатывать выход из процедуры.

6.  **Проверка и исправление теста `28-rec-sumdig.kum`:**
    *   Мы добавили подробное логирование в тест `28-rec-sumdig.kum`, чтобы отслеживать, на каком этапе происходит потеря значения.
    *   Логирование показало, что значение `N` корректно передается и не теряется в процессе вычисления.

**Решение проблемы с `KumirEvalError`:**
Мы добавили дополнительную проверку на `None` в метод `_handle_type_promotion_for_comparison`, чтобы избежать ситуации, когда `None` передается в операцию сравнения.

---

## Рефакторинг `DeclarationVisitorMixin` (Август 2024)

- **Задача:** Вынести логику обработки объявлений (переменных, процедур, функций) из `KumirInterpreterVisitor` в отдельный миксин `DeclarationVisitorMixin`.
- **Создан файл:** `pyrobot/backend/kumir_interpreter/interpreter_components/declaration_visitors.py`.
- **Основные изменения и решения в `declaration_visitors.py`:**
    - **Проблема `TypeError` (циклическая типизация):**
        - Изначальная попытка типизировать `self` в методах миксина как `'KumirInterpreterVisitor'` приводила к ошибке.
        - **Решение:** Использовать `kiv_self = cast('KumirInterpreterVisitor', self)` в начале методов, где нужен доступ к основному классу, и `from typing import cast`.
    - **Проблема `AttributeError` (неверные имена контекстов ANTLR):**
        - После исправления `TypeError` возникли `AttributeError` из-за неправильных имен контекстов ANTLR в type hints (например, `Var_declare_statementContext` вместо `VariableDeclarationContext`).
        - **Решение:** Имена контекстов были исправлены согласно грамматике `KumirParser.g4` (например, `KumirParser.VariableDeclarationContext`, `KumirParser.TypeSpecifierContext`, `KumirParser.AlgorithmDefinitionContext`).
    - **Импорты:**
        - Добавлены: `DeclarationError`, `AssignmentError` из `..kumir_exceptions`.
## Отладка `28-rec-sumdig.kum` (продолжение)

**Проблема:** Тест снова падает, но с другой ошибкой. Теперь это `KumirEvalError: Попытка использовать неинициализированное возвращаемое значение`.

**Контекст:**

После всех предыдущих правок, когда мы пытались запустить тест `28-rec-sumdig.kum`, он упал с ошибкой `KumirEvalError` в строке, где происходит присвоение `знач := ...` (в `visitAssignmentStatement`). Ошибка указывает на то, что `знач` не инициализировано.

**Что мы проверили и сделали:**
1.  **Проверка и восстановление `_handle_type_promotion_for_comparison`:**
    *   Мы восстановили метод `_handle_type_promotion_for_comparison` в `KumirInterpreterVisitor`, который отвечает за приведение типов при операциях сравнения.
    *   Этот метод теперь корректно обрабатывает ситуации, когда одно из значений `None`, и возбуждает `KumirEvalError` с соответствующим сообщением.

2.  **Проверка `current_scope` и `return_value`:**
    *   Мы исправили доступ к `current_scope` в `visitPrimaryExpression`, заменив `self.current_scope` на `self.scopes[-1]`.
    *   Также был исправлен ключ для доступа к возвращаемому значению процедуры с `'return_value'` на `'__знач__'`.

3.  **Проблема с `KumirEvalError: Попытка использовать неинициализированное возвращаемое значение`:**
    *   Эта ошибка возникает, когда интерпретатор пытается использовать значение, которое еще не было инициализировано или присвоено.
    *   В нашем случае, это происходит в результате некорректной обработки команды `выход` или возврата значения из процедуры.

4.  **Исправление логики `visitExitStatement`:**
    *   Мы переписали логику в `visitExitStatement`, чтобы она корректно обрабатывала команду `выход` в зависимости от контекста (внутри цикла, процедуры или основного блока).
    *   Теперь, если `выход` вызывается внутри процедуры и не в цикле, он должен корректно завершать выполнение процедуры.

5.  **Исправление `_execute_procedure_call`:**
    *   Мы обернули вызов тела процедуры `self.visit(alg_body_ctx)` в блок `try...except ProcedureExitCalled: pass`, чтобы корректно обрабатывать выход из процедуры.

6.  **Проверка и исправление теста `28-rec-sumdig.kum`:**
    *   Мы добавили подробное логирование в тест `28-rec-sumdig.kum`, чтобы отслеживать, на каком этапе происходит потеря значения.
    *   Логирование показало, что значение `N` корректно передается и не теряется в процессе вычисления.

**Решение проблемы с `KumirEvalError`:**
Мы добавили дополнительную проверку на `None` в метод `_handle_type_promotion_for_comparison`, чтобы избежать ситуации, когда `None` передается в операцию сравнения.

---

## Рефакторинг `DeclarationVisitorMixin` (Август 2024)

- **Задача:** Вынести логиию обработки объявлений (переменных, процедур, функций) из `KumirInterpreterVisitor` в отдельный миксин `DeclarationVisitorMixin`.
- **Создан файл:** `pyrobot/backend/kumir_interpreter/interpreter_components/declaration_visitors.py`.
- **Основные изменения и решения в `declaration_visitors.py`:**
    - **Проблема `TypeError` (циклическая типизация):**
        - Изначальная попытка типизировать `self` в методах миксина как `'KumirInterpreterVisitor'` приводила к ошибке.
        - **Решение:** Использовать `kiv_self = cast('KumirInterpreterVisitor', self)` в начале методов, где нужен доступ к основному классу, и `from typing import cast`.
    - **Проблема `AttributeError` (неверные имена контекстов ANTLR):**
        - После исправления `TypeError` возникли `AttributeError` из-за неправильных имен контекстов ANTLR в type hints (например, `Var_declare_statementContext` вместо `VariableDeclarationContext`).
        - **Решение:** Имена контекстов были исправлены согласно грамматике `KumirParser.g4` (например, `KumirParser.VariableDeclarationContext`, `KumirParser.TypeSpecifierContext`, `KumirParser.AlgorithmDefinitionContext`).
    - **Импорты:**
        - Добавлены: `DeclarationError`, `AssignmentError` из `..kumir_exceptions`.
## Отладка `28-rec-sumdig.kum` (продолжение)

**Проблема:** Тест снова падает, но с другой ошибкой. Теперь это `KumirEvalError: Попытка использовать неинициализированное возвращаемое значение`.

**Контекст:**

После всех предыдущих правок, когда мы пытались запустить тест `28-rec-sumdig.kum`, он упал с ошибкой `KumirEvalError` в строке, где происходит присвоение `знач := ...` (в `visitAssignmentStatement`). Ошибка указывает на то, что `знач` не инициализировано.

**Что мы проверили и сделали:**
1.  **Проверка и восстановление `_handle_type_promotion_for_comparison`:**
    *   Мы восстановили метод `_handle_type_promotion_for_comparison` в `KumirInterpreterVisitor`, который отвечает за приведение типов при операциях сравнения.
    *   Этот метод теперь корректно обрабатывает ситуации, когда одно из значений `None`, и возбуждает `KumirEvalError` с соответствующим сообщением.

2.  **Проверка `current_scope` и `return_value`:**
    *   Мы исправили доступ к `current_scope` в `visitPrimaryExpression`, заменив `self.current_scope` на `self.scopes[-1]`.
    *   Также был исправлен ключ для доступа к возвращаемому значению процедуры с `'return_value'` на `'__знач__'`.

3.  **Проблема с `KumirEvalError: Попытка использовать неинициализированное возвращаемое значение`:**
    *   Эта ошибка возникает, когда интерпретатор пытается использовать значение, которое еще не было инициализировано или присвоено.
    *   В нашем случае, это происходит в результате некорректной обработки команды `выход` или возврата значения из процедуры.

4.  **Исправление логики `visitExitStatement`:**
    *   Мы переписали логику в `visitExitStatement`, чтобы она корректно обрабатывала команду `выход` в зависимости от контекста (внутри цикла, процедуры или основного блока).
    *   Теперь, если `выход` вызывается внутри процедуры и не в цикле, он должен корректно завершать выполнение процедуры.

5.  **Исправление `_execute_procedure_call`:**
    *   Мы обернули вызов тела процедуры `self.visit(alg_body_ctx)` в блок `try...except ProcedureExitCalled: pass`, чтобы корректно обрабатывать выход из процедуры.

6.  **Проверка и исправление теста `28-rec-sumdig.kum`:**
    *   Мы добавили подробное логирование в тест `28-rec-sumdig.kum`, чтобы отслеживать, на каком этапе происходит потеря значения.
    *   Логирование показало, что значение `N` корректно передается и не теряется в процессе вычисления.

**Решение проблемы с `KumirEvalError`:**
Мы добавили дополнительную проверку на `None` в метод `_handle_type_promotion_for_comparison`, чтобы избежать ситуации, когда `None` передается в операцию сравнения.

---

## Рефакторинг `DeclarationVisitorMixin` (Август 2024)

- **Задача:** Вынести логику обработки объявлений (переменных, процедур, функций) из `KumirInterpreterVisitor` в отдельный миксин `DeclarationVisitorMixin`.
- **Создан файл:** `pyrobot/backend/kumir_interpreter/interpreter_components/declaration_visitors.py`.
- **Основные изменения и решения в `declaration_visitors.py`:**
    - **Проблема `TypeError` (циклическая типизация):**
        - Изначальная попытка типизировать `self` в методах миксина как `'KumirInterpreterVisitor'` приводила к ошибке.
        - **Решение:** Использовать `kiv_self = cast('KumirInterpreterVisitor', self)` в начале методов, где нужен доступ к основному классу, и `from typing import cast`.
    - **Проблема `AttributeError` (неверные имена контекстов ANTLR):**
        - После исправления `TypeError` возникли `AttributeError` из-за неправильных имен контекстов ANTLR в type hints (например, `Var_declare_statementContext` вместо `VariableDeclarationContext`).
        - **Решение:** Имена контекстов были исправлены согласно грамматике `KumirParser.g4` (например, `KumirParser.VariableDeclarationContext`, `KumirParser.TypeSpecifierContext`, `KumirParser.AlgorithmDefinitionContext`).
    - **Импорты:**
        - Добавлены: `DeclarationError`, `AssignmentError` из `..kumir_exceptions`.
## Отладка `28-rec-sumdig.kum` (продолжение)

**Проблема:** Тест снова падает, но с другой ошибкой. Теперь это `KumirEvalError: Попытка использовать неинициализированное возвращаемое значение`.

**Контекст:**

После всех предыдущих правок, когда мы пытались запустить тест `28-rec-sumdig.kum`, он упал с ошибкой `KumirEvalError` в строке, где происходит присвоение `знач := ...` (в `visitAssignmentStatement`). Ошибка указывает на то, что `знач` не инициализировано.

**Что мы проверили и сделали:**
1.  **Проверка и восстановление `_handle_type_promotion_for_comparison`:**
    *   Мы восстановили метод `_handle_type_promotion_for_comparison` в `KumirInterpreterVisitor`, который отвечает за приведение типов при операциях сравнения.
    *   Этот метод теперь корректно обрабатывает ситуации, когда одно из значений `None`, и возбуждает `KumirEvalError` с соответствующим сообщением.

2.  **Проверка `current_scope` и `return_value`:**
    *   Мы исправили доступ к `current_scope` в `visitPrimaryExpression`, заменив `self.current_scope` на `self.scopes[-1]`.
    *   Также был исправлен ключ для доступа к возвращаемому значению процедуры с `'return_value'` на `'__знач__'`.

3.  **Проблема с `KumirEvalError: Попытка использовать неинициализированное возвращаемое значение`:**
    *   Эта ошибка возникает, когда интерпретатор пытается использовать значение, которое еще не было инициализировано или присвоено.
    *   В нашем случае, это происходит в результате некорректной обработки команды `выход` или возврата значения из процедуры.

4.  **Исправление логики `visitExitStatement`:**
    *   Мы переписали логику в `visitExitStatement`, чтобы она корректно обрабатывала команду `выход` в зависимости от контекста (внутри цикла, процедуры или основного блока).
    *   Теперь, если `выход` вызывается внутри процедуры и не в цикле, он должен корректно завершать выполнение процедуры.

5.  **Исправление `_execute_procedure_call`:**
    *   Мы обернули вызов тела процедуры `self.visit(alg_body_ctx)` в блок `try...except ProcedureExitCalled: pass`, чтобы корректно обрабатывать выход из процедуры.

6.  **Проверка и исправление теста `28-rec-sumdig.kum`:**
    *   Мы добавили подробное логирование в тест `28-rec-sumdig.kum`, чтобы отслеживать, на каком этапе происходит потеря значения.
    *   Логирование показало, что значение `N` корректно передается и не теряется в процессе вычисления.

**Решение проблемы с `KumirEvalError`:**
Мы добавили дополнительную проверку на `None` в метод `_handle_type_promotion_for_comparison`, чтобы избежать ситуации, когда `None` передается в операцию сравнения.

---

## Рефакторинг `DeclarationVisitorMixin` (Август 2024)

- **Задача:** Вынести логику обработки объявлений (переменных, процедур, функций) из `KumirInterpreterVisitor` в отдельный миксин `DeclarationVisitorMixin`.
- **Создан файл:** `pyrobot/backend/kumir_interpreter/interpreter_components/declaration_visitors.py`.
- **Основные изменения и решения в `declaration_visitors.py`:**
    - **Проблема `TypeError` (циклическая типизация):**
        - Изначальная попытка типизировать `self` в методах миксина как `'KumirInterpreterVisitor'` приводила к ошибке.
        - **Решение:** Использовать `kiv_self = cast('KumirInterpreterVisitor', self)` в начале методов, где нужен доступ к основному классу, и `from typing import cast`.
    - **Проблема `AttributeError` (неверные имена контекстов ANTLR):**
        - После исправления `TypeError` возникли `AttributeError` из-за неправильных имен контекстов ANTLR в type hints (например, `Var_declare_statementContext` вместо `VariableDeclarationContext`).
        - **Решение:** Имена контекстов были исправлены согласно грамматике `KumirParser.g4` (например, `KumirParser.VariableDeclarationContext`, `KumirParser.TypeSpecifierContext`, `KumirParser.AlgorithmDefinitionContext`).
    - **Импорты:**
        - Добавлены: `DeclarationError`, `AssignmentError` из `..kumir_exceptions`.
## Отладка `28-rec-sumdig.kum` (продолжение)

**Проблема:** Тест снова падает, но с другой ошибкой. Теперь это `KumirEvalError: Попытка использовать неинициализированное возвращаемое значение`.

**Контекст:**

После всех предыдущих правок, когда мы пытались запустить тест `28-rec-sumdig.kum`, он упал с ошибкой `KumirEvalError` в строке, где происходит присвоение `знач := ...` (в `visitAssignmentStatement`). Ошибка указывает на то, что `знач` не инициализировано.

**Что мы проверили и сделали:**
1.  **Проверка и восстановление `_handle_type_promotion_for_comparison`:**
    *   Мы восстановили метод `_handle_type_promotion_for_comparison` в `KumirInterpreterVisitor`, который отвечает за приведение типов при операциях сравнения.
    *   Этот метод теперь корректно обрабатывает ситуации, когда одно из значений `None`, и возбуждает `KumirEvalError` с соответствующим сообщением.

2.  **Проверка `current_scope` и `return_value`:**
    *   Мы исправили доступ к `current_scope` в `visitPrimaryExpression`, заменив `self.current_scope` на `self.scopes[-1]`.
    *   Также был исправлен ключ для доступа к возвращаемому значению процедуры с `'return_value'` на `'__знач__'`.

3.  **Проблема с `KumirEvalError: Попытка использовать неинициализированное возвращаемое значение`:**
    *   Эта ошибка возникает, когда интерпретатор пытается использовать значение, которое еще не было инициализировано или присвоено.
    *   В нашем случае, это происходит в результате некорректной обработки команды `выход` или возврата значения из процедуры.

4.  **Исправление логики `visitExitStatement`:**
    *   Мы переписали логику в `visitExitStatement`, чтобы она корректно обрабатывала команду `выход` в зависимости от контекста (внутри цикла, процедуры или основного блока).
    *   Теперь, если `выход` вызывается внутри процедуры и не в цикле, он должен корректно завершать выполнение процедуры.

5.  **Исправление `_execute_procedure_call`:**
    *   Мы обернули вызов тела процедуры `self.visit(alg_body_ctx)` в блок `try...except ProcedureExitCalled: pass`, чтобы корректно обрабатывать выход из процедуры.

6.  **Проверка и исправление теста `28-rec-sumdig.kum`:**
    *   Мы добавили подробное логирование в тест `28-rec-sumdig.kum`, чтобы отслеживать, на каком этапе происходит потеря значения.
    *   Логирование показало, что значение `N` корректно передается и не теряется в процессе вычисления.

**Решение проблемы с `KumirEvalError`:**
Мы добавили дополнительную проверку на `None` в метод `_handle_type_promotion_for_comparison`, чтобы избежать ситуации, когда `None` передается в операцию сравнения.

---

## Рефакторинг: ExpressionEvaluator (Продолжение ~2025-05-23)

**Цель:** Вынести логику вычисления выражений из `KumirInterpreterVisitor` (`interpreter.py`) в отдельный класс `ExpressionEvaluator` (`interpreter_components/expression_evaluator.py`).

**Текущий статус (2025-05-23):**
*   Файл `expression_evaluator.py` создан и частично заполнен.
*   Продолжается адаптация перенесенных `visit...` методов для выражений.
*   Основные вызовы: корректный доступ к токенам ANTLR (через `.symbol`), контекстам дочерних узлов, и взаимодействие с основным `visitor` (экземпляром `KumirInterpreterVisitor`).
*   **Ключевые незавершенные методы в `ExpressionEvaluator`:**
    *   `visitUnaryExpression`: Пустой.
    *   `visitPowerExpression`: Пустой.
    *   `visitMultiplicativeExpression`: Каркас есть, операционная логика отсутствует.
    *   `visitAdditiveExpression`: Каркас есть, операционная логика отсутствует.
*   Методы для сравнений (`Relational`, `Equality`) и логических операций (`LogicalAnd`, `LogicalOr`) имеют базовую реализацию, но потребуют тщательного тестирования и возможной доработки после того, как основные арифметические операции будут работать.

**Ближайшие шаги по `ExpressionEvaluator`:**
1.  **Реализовать `visitUnaryExpression`:** Обработка унарных операторов (`+`, `-`, `не`).
2.  **Реализовать `visitPowerExpression`:** Обработка оператора возведения в степень (`^`).
3.  **Завершить `visitMultiplicativeExpression`:** Реализовать логику для `*`, `/`. (Помнить, что `DIV_INT` и `MOD` обрабатываются как вызовы функций).
4.  **Завершить `visitAdditiveExpression`:** Реализовать логику для `+`, `-`.
5.  После реализации этих методов, провести интеграционное тестирование с `KumirInterpreterVisitor` и исправить возникающие ошибки.
