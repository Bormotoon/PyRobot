# Заметки AI по проекту PyRobot

---

## Общая информация по проекту

* **Запуск тестов:**
  * Все тесты: `pytest -v`
  * Конкретный тест: `pytest -v tests/test_functional.py -k "имя_файла.kum"` или `python -m pytest -v tests/test_functional.py -k "имя_файла.kum"`
  * Все файлы kum: `tests/polyakov_kum`
* **Документация по языку Кумир:** `kumir2-master/userdocs/`
* **Исходный код оригинального Кумира (C++):** `kumir2-master/src`
* **Наиболее важные исходники:** `kumir2-master/src/kumir2-libs`, `kumir2-master/src/plugins`

---

# Выдержки из документации КуМир

## Команда `вывод` (`simple_commands.xml`)

* **Синтаксис:** `вывод выражение-1, ... , выражение-N`
* **Поведение:**
  * Выводит значения выражений последовательно в одну строку **без разделителей**.
  * По умолчанию **НЕ** добавляет перенос строки (`\n`) в конце вывода.
* **Аргумент `нс`:**
  * Описан как "ключевое слово ... признак **перехода на новую строку**".
  * Использование `нс` в списке аргументов команды `вывод` добавляет символ переноса строки (`\n`) в том месте, где он указан.
  * Пример: `вывод "Строка1", нс, "Строка2"` выведет:

        ```
        Строка1
        Строка2
        ```

## Неявные переносы строк (`structure.xml`)

* Раздел "Неявные переносы строк" описывает правила **синтаксического анализатора** КуМира.
* Эти правила позволяют писать код более компактно (например, несколько команд на одной строке, разделенных `;` или без переносов вокруг `то`, `иначе`, `все`, `кц` и т.д.).
* **Важно:** Эти правила **не влияют** на форматирование **вывода** программы во время выполнения (в частности, на поведение команды `вывод`).

---

## Заметки по доработке интерпретатора КуМира

Задачи, которые нужно реализовать для прохождения тестов:

1. **Встроенные функции `irand` и `rand` (а также необъявленные идентификаторы типа `printBin`):**
    * Проблема: Интерпретатор не распознает `irand`, `rand`, `printBin` и т.п. как встроенные функции/процедуры или переменные, считает их необъявленными. **Частично решено:** Реализована обработка встроенных процедур, исправлена лямбда для `printbin`.
    * Файл теста: `tests/polyakov_kum/7-rand.kum` (и другие, вызвавшие ошибку `printBin`).
    * Место в коде: Вероятно, `visitPostfixExpression`, `visitPrimaryExpression`, `visitProcedureCallStatement` в `pyrobot/backend/kumir_interpreter/interpreter.py`. Обработка вызовов и поиск имен.

2. **Цикл `нц N раз`:**
    * Проблема: Интерпретатор вызывает `NotImplementedError`, так как этот тип цикла еще не реализован.
    * Файл теста: `tests/polyakov_kum/8-if.kum`
    * Место в коде: Ветка `elif loop_spec.expression():` в методе `visitLoopStatement` в `pyrobot/backend/kumir_interpreter/interpreter.py`.

3. **Оператор `выбор` (switch):**
    * Проблема: `KumirEvalError: ... Ошибка вычисления условия: 'NoneType' object has no attribute 'start'` (Изначально). Сейчас падает из-за **несовместимости типов при сравнении `<` (float и int)** (см. тест `12-switch.kum`) **или из-за отсутствия реальной логики switch** (заглушка `switch_value = None`) (см. тест `11-switch.kum`).
    * Файлы тестов: `11-switch.kum`, `12-switch.kum`.
    * Место в коде: `visitSwitchStatement` (требует исправления грамматики `KumirParser.g4`) и `_perform_binary_operation` (сравнение типов **ИСПРАВЛЕНО**, но сам switch не работает).

4. **Обработка переменных цикла:**
    * Проблема: `KumirEvalError: ... name 'X' is not defined` или похожие ошибки. **Частично решено:** Реализована локальная область видимости для `ДЛЯ`. Ошибки могут оставаться внутри тел циклов или для других типов циклов.
    * Файлы тестов: `13-loopN.kum`, `14-while.kum`, `17-for.kum` (и другие циклы).
    * Место в коде: `visitLoopStatement` в `interpreter.py`.

5. **Цикл `до` (repeat...until):** (**РЕШЕНО**)
    * Проблема: Цикл не был реализован.
    * Файл теста: `16-repeat.kum`.
    * Место в коде: `visitLoopStatement` в `interpreter.py`. (Логика добавлена).

6. **Проблема с чтением ввода (`\n`):** (**РЕШЕНО**)
    * Проблема: `KumirEvalError: ... invalid literal for int() with base 10: 'X\n'`. `input()` считывал `\n`.
    * Файлы тестов: `11-switch.kum`, `12-switch.kum` и другие с вводом.
    * Место в коде: `visitIoStatement` в `interpreter.py`. (Добавлено удаление `\\n`).

7. **Несоответствие вывода (AssertionError):**
    * Проблема: Фактический вывод не совпадает с ожидаемым. **Частично решено:** Исправлены ожидаемые/входные данные для тестов `13`, `14`, `16`, `17`, `18`, `19`. Добавлен `rstrip()` в test runner.
    * Файлы тестов: Некоторые тесты все еще могут падать из-за этого (`15-while.kum` - но там основная проблема в парсинге).
    * Решение: Нужно сравнить вывод с оригинальным КуМиром и скорректировать либо ожидаемый вывод в `TEST_CASES`, либо логику вывода в интерпретаторе.

8. **Ошибка парсинга файла `15-while.kum`:** (**АКТУАЛЬНО**)
    * Проблема: Парсер ANTLR не может обработать файл (`no viable alternative at input 'алгКоличествоцифрнач...'`).
    * Файл теста: `15-while.kum`.
    * Возможная причина: Проблема в грамматике `.g4` или сгенерированном лексере/парсере.
    * Решение: Требует глубокого анализа грамматики и, возможно, перегенерации парсера.

9. **Обработка вывода строковых литералов:** (**РЕШЕНО**)
    * Проблема: `KumirEvalError: ... Попытка вывести неинициализированное значение` при выводе строковых литералов (например, `"Привет"`). Ошибка возникала из-за того, что `visitStatement` не присваивал значение переменной `value` при обработке строки, и последующая проверка `if value is None:` ложно срабатывала.
    * Файл теста: `21-proc-bin.kum` (и другие, использующие вывод строк).
    * Место в коде: `visitStatement` в `interpreter.py`.
    * Решение: В ветке `elif arg_ctx.STRING():` теперь извлеченное строковое значение присваивается переменной `value`.

# Заметки по разработке

## 2024-03-21

1. Исправлена обработка встроенных процедур в методе `visitPostfixExpression`:
   * Добавлена проверка на встроенные процедуры перед проверкой пользовательских
   * Добавлена обработка количества аргументов для встроенных процедур
   * Исправлен вызов встроенных процедур с правильной передачей аргументов

2. Исправлена обработка условного оператора в методе `visitIfStatement`:
   * Добавлено извлечение значения из переменной для условия
   * Улучшена обработка ветвей "то" и "иначе"

3. Добавлена встроенная процедура `printBin`:
   * Реализована функция для вывода числа в двоичном виде
   * Добавлена поддержка форматирования с фиксированной шириной

TODO:

1. Исправить форматирование вывода в тесте `format.kum`
2. Исправить обработку оператора выбора в `switch.kum`
3. Исправить обработку циклов в `loopN.kum`, `while.kum`, `for.kum`, `downto.kum`
4. Исправить алгоритм поиска простых чисел в `prime.kum`

* **Отладка списка аргументов:**
  * Тест `7-rand.kum` упал с ошибкой "Неверное количество аргументов (2) для 'irand'". Поняли, что `visit(expressionList)` обрабатывал только первый аргумент.
  * Тест `21-proc-bin.kum` упал с "Неизвестное имя ... 'printBin'". Поняли, что это пользовательская процедура.
  * Реализовали метод `visitExpressionList` для корректной обработки списка аргументов. Потребовалось несколько попыток редактирования из-за ошибок модели.
  * **Исправление `visitExpressionList`:** Предыдущая реализация собирала слишком много аргументов (включая вложенные выражения). Исправили логику итерации по дочерним узлам.
  * **Текущее состояние:** Исправлена ошибка `Попытка присвоить значение None переменной 'n'` (тест `17-for.kum`) и большинство ошибок `Попытка вывести неинициализированное значение`, что позволило пройти многим ранее падавшим функциональным тестам (например, `2-2+2`, `4-a+b`, `6-format`, `8-if`, `10-and`, `11-switch`, `13-loopN`, `14-while`, `16-repeat`, `20-proc-err`, `21-proc-bin`).

## 2024-03-22

1. Исправлена обработка аргументов функций в `visitExpressionList` (решена проблема с `7-rand.kum`).
2. Исправлена логика вывода в `visitStatement` для корректной обработки `нс` и добавления переноса строки в конце.
3. Исправлена обработка циклов в `visitLoopStatement`:
    * Добавлена поддержка `REPEAT...UNTIL` (цикл `ДО`).
    * Исправлен доступ к типу цикла (`TIMES`, `WHILE`, `FOR`) через дочерний узел `loopSpec`.
    * Улучшена обработка ошибок и граничных условий в циклах.
4. **Результат:** Исправлена ошибка `Попытка присвоить значение None переменной 'n'` (тест `17-for.kum`) и большинство ошибок `Попытка вывести неинициализированное значение`, что позволило пройти многим ранее падавшим функциональным тестам (например, `2-2+2`, `4-a+b`, `6-format`, `8-if`, `10-and`, `11-switch`, `13-loopN`, `14-while`, `16-repeat`, `20-proc-err`, `21-proc-bin`).
5. **Отладка `21-proc-bin.kum`:**
    * Столкнулись с ошибкой `Попытка вывести неинициализированное значение` в рекурсивной процедуре `_printBinRec` при выводе `x mod 2`.
    * Исправили ключ и лямбду для встроенной `printbin`, но это не помогло (вызывалась пользовательская процедура).
    * Тесты (`6-format`, `7-rand`, `8-if`, `9-if`) начали падать с новыми ошибками (`NoneType` has no len(), Попытка вывести None). Откатили исправление `printbin`.
    * Добавили множественные отладочные выводы, но они не показывались перед ошибкой или показывали, что `visit(x mod 2)` успешно возвращает `None`.
    * Выяснили, что проблема не в `x mod 2`, а в том, что `visitStatement` некорректно обрабатывал **строковые литералы** в операторе `вывод`. Он не присваивал строковое значение переменной `value`, из-за чего проверка `if value is None:` ложно срабатывала.
    * Исправили `visitStatement`, чтобы он корректно обрабатывал строки.
    * Убрали всю добавленную отладку.
6. **Текущее состояние:** Ошибка с выводом строк исправлена. Тест `21-proc-bin.kum` теперь проходит (хотя все тесты вместе все еще прерываются).

TODO:

1. Проверить тесты после исправлений вывода и циклов. **(Выполнено)**
2. Исправить **AssertionError: Неверный вывод** в тестах `15-while`, `18-downto`, `19-prime`. Вероятно, связано с ошибками парсинга.
3. Исправить **ошибки парсинга** (`no viable alternative`) в файлах, использующих процедуры, функции, массивы, рекурсию (например, `15-while`, `18-downto`, `19-prime`, `21-proc-bin`, `23-func-sumdig`, `27-rec-bin`, `39-arr-rev`, `44-arr-qsort`). Требует доработки грамматики `Kumir.g4`.
4. Исправить форматирование вывода в тесте `format.kum` (если проблема осталась). (**Похоже, решено предыдущими правками вывода**)
5. Исправить обработку оператора выбора в `switch.kum`. (**Похоже, решено**)
6. Исправить алгоритм поиска простых чисел в `prime.kum` (если проблема осталась). (**Проблема в парсинге, см. п.3**)
7. **Разобраться, почему прерывается полный запуск тестов `pytest -v`.**

## 2024-07-26

* Добавлен тест для `tests/polyakov_kum/1-primes.kum` в `tests/test_functional.py`.
  * Вход: `100\n`
  * Ожидаемый вывод: `'Введите максимальное число: Простые числа от 2 до 100: 2 3 5 7 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 83 89 97 \n'` (Текущий вывод нашего интерпретатора).
  * **Замечание:** Оригинальный КуМир может выводить результат немного иначе (с эхом ввода `100\n` и переносом строки после `:`). Текущий тест проверяет фактический вывод *нашего* интерпретатора и функции `run_kumir_program`.
* **TODO:** Точнее сверить поведение вывода (особенно `нс`, эхо ввода, финальные `\n`) с оригинальным КуМиром.
* **Верификация вывода по оригиналу:**
  * `'1-empty.kum'` (вход: `None`): Оригинал ничего не выводит. Текущий тест (`expected_output = ''`) **корректен**.
  * `'1-primes.kum'` (вход: `'100\n'`): Оригинал выводит промпт, затем эхо ввода на новой строке, затем заголовок результата на новой строке, затем числа через пробел и финальный `\n`. Тест обновлен на `expected_output = 'Введите максимальное число: 100\nПростые числа от 2 до 100:\n2 3 5 7 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 83 89 97 \n'`.
  * `'2-2+2.kum'` (вход: `None`): Оригинал выводит `2+2=?\nОтвет: 4\n` (согласно файлу вывода). Тест обновлен на `expected_output = '2+2=?\nОтвет: 4\n'`.
  * `'2-longnum.kum'` (вход: `None`): Оригинал выводит заголовок и факториал на двух строках с финальным `\n`. Тест **добавлен** с `expected_output = 'Факториал числа 100:\n93326215443944152681699238856266700490715968264381621468592963895217599993229915608941463976156518286253697920827223758251185210916864000000000000000000000000\n'`.
  * `'3-a+b.kum'` (вход: `'2\n3\n'`): Оригинал выводит эхо ввода (`2 3`) и результат (`5`) на двух строках с финальным `\n`. Тест обновлен на `expected_output = '2 3\n5\n'`.
  * `'4-a+b.kum'` (вход: `'10\n20\n'`): Оригинал выводит промпт, затем эхо ввода (`10 20`) на той же строке с `\n`, затем результат (`10+20=30`) на новой строке с финальным `\n`. Тест обновлен на `expected_output = 'Введите два целых числа: 10 20\n10+20=30\n'`.
  * `'6-format.kum'` (вход: `None`): Оригинал выводит три строки с форматированными числами, каждая с `\n`. Текущий тест (`expected_output = '>  123<\n1.2345678\n>  1.235<\n'`) **корректен**.
  * `'7-rand.kum'` (вход: `None`): Вывод программы случаен. Текущий тест (`expected_output = None`) **корректен**, так как он проверяет только успешный запуск без ошибок (валидация вызова `irand`, `rand`).
  * `'8-if.kum'` (вход: `'5\n7\n'`): Оригинал выводит промпт, затем эхо ввода (`5 7`) на той же строке с `\n`, затем заголовок и 4 результата (каждый с `\n`). Тест обновлен на `expected_output = 'Введите два целых числа: 5 7\nМаксимальное число:\n7\n7\n7\n7\n'`.
  * `'9-if.kum'` (вход: `'-3\n5\n'`): Оригинал выводит промпт, затем эхо ввода (`-3 5`) на той же строке с `\n`, затем результат (`Борис старше`) на новой строке с `\n`. Тест обновлен на `expected_output = 'Введите возраст Андрея и Бориса: -3 5\nБорис старше\n'`.
  * `'10-and.kum'` (вход: `'27\n'`): Оригинал выводит промпт, затем эхо ввода (`27`) на той же строке с `\n`, затем результат (`подходит`) на новой строке с `\n`. Тест обновлен на `expected_output = 'Введите возраст: 27\nподходит\n'`.
  * `'11-switch.kum'` (вход: `'2\n'`): Оригинал выводит промпт, затем эхо ввода (`2`) на той же строке с `\n`, затем результат (`февраль`) на новой строке с `\n`. Тест обновлен на `expected_output = 'Введите номер месяца: 2\nфевраль\n'`.
  * `'12-switch.kum'` (вход: `'7\n'`): Оригинал выводит эхо ввода (`7`) и результат (`1`) на двух строках с финальным `\n`. Тест обновлен на `expected_output = '7\n1\n'`.
  * `'13-loopN.kum'` (вход: `'5\n'`): Оригинал выводит промпт, затем эхо ввода (`5`) на той же строке с `\n`, затем 5 строк результата (`привет`), каждая с `\n`. Тест обновлен на `expected_output = 'Сколько раз сделать? 5\nпривет\nпривет\nпривет\nпривет\nпривет\n'`.
  * `'14-while.kum'` (вход: `'5\n'`): Вывод идентичен `13-loopN.kum`. Тест обновлен на `expected_output = 'Сколько раз сделать? 5\nпривет\nпривет\nпривет\nпривет\nпривет\n'`.
  * `'15-while.kum'` (вход: `'12345\n'`): Оригинал выводит промпт, затем эхо ввода (`12345`) на той же строке с `\n`, затем результат (`Цифр в числе: 5`) на новой строке с `\n`. Тест обновлен на `expected_output = 'Введите целое число: 12345\nЦифр в числе: 5\n'`.
  * `'16-repeat.kum'` (вход: `'-1\n0\n2\n'`): Оригинал выводит промпт, затем эхо первого ввода (`-1`) на той же строке с `\n`, затем эхо второго (`0`) и третьего (`2`) вводов на отдельных строках с `\n`, затем две строки результата (каждая с `\n`). Тест обновлен на `expected_output = 'Введите целое положительное число: -1\n0\n2\nВведено число 2\n  и до него 2 ошибочных значений(я)\n'`.
  * `'17-for.kum'` (вход: `'5\n'`): Оригинал выводит эхо ввода (`5`) и результат (`2 4 8 16 32`) на двух строках с финальным `\n` (и пробелом перед ним). Тест обновлен на `expected_output = '5\n2 4 8 16 32 \n'`.
  * `'18-downto.kum'` (вход: `'5\n'`): Оригинал выводит эхо ввода (`5`) и результат (`32 16 8 4 2`) на двух строках с финальным `\n` (и пробелом перед ним). Тест обновлен на `expected_output = '5\n32 16 8 4 2 \n'`.
  * `'19-prime.kum'` (вход: `'17\n'`): Оригинал выводит промпт, эхо ввода (`17`) на той же строке с `\n`, затем результат (`Простые числа: 2 3 5 7 11 13 17`) на новой строке с `\n` (и пробелом перед ним). Тест обновлен на `expected_output = 'Введите максимальное число: 17\nПростые числа: 2 3 5 7 11 13 17 \n'`.
  * `'20-proc-err.kum'` (вход: `'-1\n'`): Оригинал выводит эхо ввода (`-1`) и сообщение об ошибке (`Ошибка программы`) на двух строках с финальным `\n`. Тест обновлен (вход и вывод) на `expected_output = '-1\nОшибка программы\n'`.
  * `'21-proc-bin.kum'` (вход: `'13\n'`): Оригинал выводит промпт, эхо ввода (`13`) на той же строке с `\n`, затем результат (`Двоичный код: 00001101`) на новой строке с `\n`. Тест обновлен на `expected_output = 'Введите натуральное число: 13\nДвоичный код: 00001101\n'`.
  * `'22-swap.kum'` (вход: `'2\n3\n'`): Оригинал выводит промпт, эхо ввода (`2 3`) на той же строке с `\n`, затем результат обмена (`После обмена: x=3 y=2`) на новой строке с `\n`. Тест **добавлен** с `expected_output = 'Введите два целых числа: 2 3\nПосле обмена: x=3 y=2\n'`.
  * `'23-func-sumdig.kum'` (вход: `'12345\n'`): Оригинал выводит промпт, эхо ввода (`12345`) на той же строке с `\n`, затем результат (`Сумма цифр 15`) на новой строке с `\n`. Тест **добавлен** с `expected_output = 'Введите целое число: 12345\nСумма цифр 15\n'`.
  * `'24-func-prime.kum'` (вход: `'15\n'`): Оригинал выводит промпт, эхо ввода (`15`) на той же строке с `\n`, затем результат (`Простые числа: 2 3 5 7 11 13`) на новой строке с `\n` (и пробелом перед ним). Тест **добавлен** с `expected_output = 'Введите максимальное число: 15\nПростые числа: 2 3 5 7 11 13 \n'`.
  * `'25-func-prime.kum'` (вход: `'5\n7\n12\n'`): Оригинал чередует промпт+эхо (на одной строке с `\n`) и результат ("N - простое число\n" с `нс`->`\n`) пока вводятся простые числа. Последний промпт+эхо не дает результата. Тест **добавлен** с `expected_output = 'Введите число: 5\n5 - простое число\nВведите число: 7\n7 - простое число\nВведите число: 12\n'`.

## Анализ поведения `вывод` и `нс` (2024-07-26) - Обновлено

* **Документация (`simple_commands.xml`) и примеры:**
  * Текст: "Значения выражений выводятся последовательно в строку области ввода-вывода **без разделителей**."
  * Текст: "Ключевое слово `нс` ... является признаком **перехода на новую строку**."
  * Пример `вывод а, " ", б, "Привет!", нс` внутри цикла печатает каждую итерацию на новой строке.
  * **Эта интерпретация противоречит выводу `

## 2024-07-29 (Продолжение)

* **Попытка исправить вывод строк (1):**
  * Гипотеза: `visitStatement` неверно обрабатывает строки в `ioArgumentList`.
  * Правка: Добавили проверку на `arg_ctx.STRING()` перед `arg_ctx.expression()`.
  * Результат: `AttributeError: 'IoArgumentContext' object has no attribute 'STRING'`. Ошибка синтаксиса/логики в проверке.
* **Попытка исправить вывод строк (2):**
  * Правка: Доработали логику в `visitStatement`, чтобы проверять, является ли `expression` простым строковым литералом, через обход дерева (`primaryExpression` -> `literal` -> `STRING`).
  * Результат: Правка не применилась инструментом (`reapply` тоже не помог). Подозрение на ошибку в самом инструменте или слишком сложном коде правки.
* **Попытка исправить вывод строк (3):**
  * Пользователь указал на неточность в коде `visitStatement` (не было строки `value = self.visit(arg_ctx.expression())`).
  * Правка: Новая попытка скорректировать `visitStatement` для обработки строковых литералов.
  * Результат: Правка применилась, но с синтаксическими ошибками (перенос строк).
* **Попытка исправить вывод строк (4):**
  * Правка: Исправлены синтаксические ошибки в `visitStatement`.
  * Результат: Запуск тестов показал новую ошибку `ValueError: invalid literal for int() with base 10: '...'`.
* **Исправление ошибки ввода (`ValueError`):**
  * Причина: В `TEST_CASES` в `tests/test_functional.py` для входных данных использовался `\\n` вместо `\n`.
  * Правка: Исправили все `\\n` на `\n` в `input_data` в `TEST_CASES`.
  * Результат: Ошибка `ValueError` ушла.
* **Исправление ошибки с параметрами (`AttributeError: ... has no attribute 'parameterVariableList'`):**
  * Причина: Неправильный доступ к списку переменных параметра в `visitPostfixExpression`.
  * Правка: Исправили доступ к `variableList` через `parameterDeclaration -> variableList -> variableDeclarationItem`.
  * Результат: Ошибка `AttributeError` ушла, но появилась новая `TypeError: object of type 'NoneType' has no len()` в том же месте.
* **Исправление ошибки с аргументами (`TypeError: 'NoneType' object has no len()`):**
  * Причина: Отсутствовал метод `visitArgumentList` для обработки списка аргументов при вызове процедур/функций. `visitPostfixExpression` получал `None` вместо списка.
  * Правка: Добавили метод `visitArgumentList` (потребовалось несколько попыток из-за проблем инструмента редактирования).
  * Результат: Ошибка `TypeError` ушла, но появилась `AttributeError: 'KumirInterpreterVisitor' object has no attribute '_format_output_value'` при выводе.
* **Исправление ошибки форматирования (`AttributeError: ... no attribute '_format_output_value'`):**
  * Причина: Забыли реализовать метод `_format_output_value`.
  * Правка: Добавили реализацию `_format_output_value` для обработки `:Ш:Т`.
  * Результат: Ошибка `AttributeError` ушла. Тест `22-swap.kum` теперь падает с `AssertionError` (неверный вывод - нет эха ввода, не работает `арг рез`).

## 2024-07-30 (Продолжение)

* **Исправление `AssertionError` для `3-a+b.kum` и `22-swap.kum`:**
    * Причина: Лишний `\\n` в конце вывода, добавляемый функцией `run_kumir_program`, и случайный отладочный вывод `[DEBUG][ArgList]` в `visitArgumentList`.
    * Правки:
        1. Убрали `print` из `visitArgumentList` в `pyrobot/backend/kumir_interpreter/interpreter.py`.
        2. Убрали строку `result += '\\n'` из `run_kumir_program` в `tests/test_functional.py`.
    * Результат: Тесты `3-a+b.kum` и `22-swap.kum` **ПРОЙДЕНЫ**.

## Текущий статус и TODO (2024-07-30) - Итог дня

Запустили все тесты. **6 PASSED, 50 FAILED**. (*После нескольких запусков и исправлений финального `\n`*)

**Пройденные тесты:**

* `1-empty.kum`
* `3-empty.kum`
* `5-types.kum`
* `9-or.kum`
* `3-a+b.kum`
* `22-swap.kum`
* `9-if.kum`

**Основные проблемы:**

1.  **Массивы/Матрицы (`NotImplementedError`):** (15 тестов). **Приоритет: Высокий.**
2.  **Неинициализированные значения (`KumirEvalError: Попытка вывести...`)**: (12 тестов). **Приоритет: Высокий.**
3.  **Синтаксические ошибки (`KumirSyntaxError`)**: Парсер не понимает конструкции (12 тестов). **Приоритет: Высокий.**
4.  **Цикл `нц ... раз` (`AttributeError: ... 'REPEAT'`)**: (3 теста). **Приоритет: Средний.**
5.  **Ошибки присваивания (`KumirExecutionError: Ошибка присваивания...`)**: (5 тестов). **Приоритет: Средний.**
6.  **Вызов функций/процедур (разные `KumirEvalError`)**: (6 тестов).
7.  **Ошибки условий/выбора (`KumirEvalError`)**: (4 теста).
8.  **`AssertionError: Неверный вывод для ...`**: (3 теста: `15`, `18`, `19`).
9.  **Другие ошибки:** Форматирование (`6`, `7`).

**Ближайшие задачи (План):**

1.  ~~Исправить передачу параметров `арг рез`.~~ **(СДЕЛАНО)**
2.  ~~Исправить эхо ввода.~~ **(СДЕЛАНО)**
3.  ~~Исправить `AssertionError` для `3-a+b.kum`, `22-swap.kum`.~~ **(СДЕЛАНО)**
4.  ~~Исправить регрессию `AssertionError` для `9-if.kum` (финальный `\n`).~~ **(СДЕЛАНО)**
5.  Реализовать поддержку **массивов (таблиц)**.
6.  Исправить ошибку `Попытка вывести неинициализированное значение...`.
7.  Исправить **синтаксические ошибки** (доработка грамматики `.g4`).
8.  Исправить распознавание цикла `нц ... раз`.
9.  Исправить ошибки присваивания (строки).
10. Исправить ошибки вызова функций/процедур.
11. Проанализировать оставшиеся `AssertionError` и другие ошибки.

## 2024-07-31: Работа над замечаниями к PR в antlr/grammars-v4 (Продолжение)

Проанализированы дополнительные замечания `kaby76`:

*   **Лишние скобки:**
    *   Скрипт `find-useless-parentheses.sh` указал на множество скобок в `KumirLexer.g4` и несколько в `KumirParser.g4`.
    *   **Parser:** Скобки в `KumirParser.g4` (`(typeSpecifier)?`, `(algorithmName)?`, `(qualifiedIdentifier)?`) признаны **не лишними**, так как используются для явного обозначения опциональности одиночных правил. **Изменения не вносились.**
    *   **Lexer:** Скобки в `KumirLexer.g4` для правил вида `TOKEN : ('лит1' | 'лит2');` были признаны **избыточными**. Внесены правки для удаления этих скобок, где это было применимо (для простых альтернатив).
*   **Токены `AT` и `ATAT`:**
    *   Замечено, что `@` и `@@` не определены как токены и не используются в парсере.
    *   Принято решение **не добавлять** их, так как они не относятся к стандартному школьному синтаксису КуМира, на котором сфокусирована грамматика.
*   **Правило `postfixExpression`:**
    *   Первоначальная интерпретация комментария `kaby76` была неверной. Его дифф показывал *ошибочное* изменение, а не предлагал его. Наше текущее правило `postfixExpression : primaryExpression ( LBRACK indexList RBRACK | LPAREN argumentList? RPAREN )*` **корректно** и оставлено без изменений.

## Текущий статус и TODO (2024-07-31) - Обновлено

**Тесты парсера (`tests/test_parser.py`):** 48 PASSED, 12 FAILED (ложная ошибка на EOF из-за вероятного бага ANTLR, **отложено**).

**Функциональные тесты (`tests/test_functional.py`)** (статус от 2024-07-30):
*   6 PASSED, 50 FAILED.

**Основные проблемы (приоритеты обновлены):**

1.  **Массивы/Матрицы (`NotImplementedError`):** (15 тестов в `test_functional.py`). **Приоритет: Высокий.**
2.  **Неинициализированные значения (`KumirEvalError: Попытка вывести...`)**: (12 тестов в `test_functional.py`). **Приоритет: Высокий.**
3.  **Оставшиеся ошибки парсера (`KumirSyntaxError`)**: (12 тестов в `test_parser.py`). Парсер не принимает `EOF` в конце файла. **Приоритет: Низкий (отложено).**
4.  **Цикл `нц ... раз` (`AttributeError: ... 'REPEAT'`)**: (3 теста в `test_functional.py`). **Приоритет: Средний.**
5.  **Ошибки присваивания (`KumirExecutionError: Ошибка присваивания...`)**: (5 тестов в `test_functional.py`). **Приоритет: Средний.**
6.  **Вызов функций/процедур (разные ошибки)**: (~4 теста в `test_functional.py`). **Приоритет: Средний.**
7.  **Тип REAL (`AssertionError`, `KumirRunError`)**: (~2 теста в `test_functional.py`). **Приоритет: Низкий.**
8.  **Другие ошибки:** Форматирование (`6`, `7` в `test_functional.py`). **Приоритет: Низкий.**

## 2024-07-30: grammars-v4 PR Ready, Parser EOF Postponed, Project Sync

**Summary of Current State:**
- Изменения для PR в `antlr/grammars-v4` (issue #4477) завершены. Вся обратная связь учтена.
    - `kumir_lang/desc.xml` создан.
    - `kumir_lang/KumirParser.g4` обновлен (правило `algorithmNameTokens`).
    - Отсутствие UTF-8 BOM в примерах подтверждено.
    - Файлы `.kum` скопированы в `kumir_lang/examples/` (числовые префиксы удалены).
    - `kumir_lang/README.md` обновлен.
    - Удалены лишние скобки из `kumir_lang/KumirLexer.g4`.
    - Опция `options { caseInsensitive = true; }` добавлена в оба файла `KumirLexer.g4` (в проекте и в `kumir_lang`). Правила для ключевых слов, типов, констант упрощены в лексере.
- Файлы грамматики ANTLR проекта (`pyrobot/backend/kumir_interpreter/grammar/`) синхронизированы с изменениями, сделанными в `kumir_lang/`. Файлы парсера/лексера перегенерированы.
- **Тесты парсера (`tests/test_parser.py`):**
    - Статус: 48 тестов проходит, 12 падает.
    - 12 падений связаны с проблемой `EOF` (`NoViableAltException` на `<EOF>`), которая возникает даже после того, как трассировка парсера показывает успешный выход из правила `program`.
    - Предполагается, что это ошибка в Python рантайме ANTLR или `ErrorListener`.
    - **Решение:** Эти 12 ошибок парсера отложены. Черновик отчета об ошибке для ANTLR GitHub подготовлен.
- **Функциональные тесты (`tests/test_functional.py`)** (статус от 2024-07-30):
    - Некоторые проблемы `AssertionError`, связанные с форматированием вывода, исправлены.
    - Оставшиеся падения в основном связаны с:
        1.  Обработкой массивов.
        2.  Ошибками из-за неинициализированных переменных.
        3.  Другими различиями в парсинге/интерпретации.
- **Дальнейшие шаги (ожидается решение пользователя):**
    - Сделать коммит и пуш изменений для PR `grammars-v4`.
    - Устранить оставшиеся падения функциональных тестов (массивы, неинициализированные значения).
    - Вернуться к 12 отложенным ошибкам парсера с EOF, если появятся новые идеи.

## 2024-08-01: Продолжение работы над PR grammars-v4 (Issue #4477)

- **`kumir_lang/KumirParser.g4`**: 
    - В правило `multiplicativeExpression` добавлены операторы `DIV_OP` и `MOD_OP` для полноты описания языка. Теперь оно выглядит так: `powerExpression ((MUL | DIV | DIV_OP | MOD_OP) powerExpression)*`.
    - Правило `program` оставлено без изменений (`programItem* (moduleDefinition | algorithmDefinition)+ EOF`), так как оно соответствует требованию наличия хотя бы одного определения в программе КуМир.
- **Синхронизация:** Правило `multiplicativeExpression` в проектном файле `pyrobot/backend/kumir_interpreter/grammar/KumirParser.g4` уже содержало `DIV_OP` и `MOD_OP`, поэтому дополнительных изменений в нем не потребовалось.
- **TODO:** Перегенерировать файлы парсера/лексера ANTLR для проекта и для `kumir_lang` после всех изменений грамматики.

- **`kumir_lang/KumirLexer.g4`**:
    - В правиле (фрагменте) `ExpFragment` удалены кириллические `еЕ` в пользу только латинских `eE` (`[eE] [+-]? DIGIT+`), так как опция `caseInsensitive = true` делает их избыточными. Соответствующее изменение внесено.

## 2024-08-01 (вечер): Анализ GitHub Issue #4830 (NoViableAltException at EOF)

- **Проблема:** Пользователь создал Issue `https://github.com/antlr/antlr4/issues/4830` по поводу 12 тестов парсера, падающих с `NoViableAltException` на токене `<EOF>`, несмотря на то, что трассировка парсера показывает успешный выход из стартового правила `program`.
- **Комментарий `kaby76`:**
    - Указал, что грамматика, приведенная в Issue, содержит Python-предикат в правиле `algorithmNameTokens`.
    - Этот предикат исполняется только Python-рантаймом и может быть источником проблем.
- **Анализ:**
    - Проверка файла `pyrobot/backend/kumir_interpreter/grammar/KumirParser.g4` показала, что правило `algorithmNameTokens` **уже исправлено** и не содержит Python-предиката. Оно выглядит так: `~(LPAREN | ALG_BEGIN | PRE_CONDITION | POST_CONDITION | SEMICOLON | EOF)+`.
    - Это означает, что причина ошибки `NoViableAltException` на EOF не в предикате `algorithmNameTokens`, а в чем-то другом.
    - Пользователю рекомендовано обновить текст Issue на GitHub, указав, что проблема воспроизводится и с версией грамматики без предиката.
- **Вывод:** Проблема с EOF остается открытой и, возможно, связана с более глубокими особенностями Python-рантайма ANTLR или самой грамматикой, как предполагалось ранее. Решение отложено до появления новых идей или ответов на GitHub.

## 2024-08-02: Решение проблемы с `div`/`mod` и ошибки `EOF` в парсере

- **Проблема:** 12 тестов парсера падали с ошибками `NoViableAltException` на токене `<EOF>` или `no viable alternative at input 'алг...'`. Функциональные тесты также показывали большое количество `KumirSyntaxError`.
- **Гипотеза 1 (неверная):** Проблема в `DIV_OP` и `MOD_OP` в лексере, которые конфликтуют с `ID` при разборе вызовов функций `div(...)` и `mod(...)`.
    - Попытка: Закомментировать `DIV_OP`, `MOD_OP` в лексере и использовать предикаты `ID {self._input.LT(1).text.lower() == 'div'}?` в `multiplicativeExpression`.
    - Результат: Предикаты не работали корректно (ошибки `name 'op_id' is not defined` или `failed predicate`).
- **Гипотеза 2 (верная):** В языке КуМир `div` и `mod` являются **только функциями**, а не инфиксными операторами.
    - **Решение:**
        1. В `KumirLexer.g4`: `DIV_OP` и `MOD_OP` **закомментированы**. Слова `div` и `mod` распознаются как `ID`.
        2. В `KumirParser.g4`: Правило `multiplicativeExpression` изменено на `powerExpression ((MUL | DIV) powerExpression)*`, т.е. обрабатывает только `*` и `/` как инфиксные операторы. `div` и `mod` будут парситься как вызовы функций через `postfixExpression` -> `primaryExpression` -> `ID`.
    - **Результат:**
        - **Все 60 тестов парсера (`tests/test_parser.py`) теперь ПРОХОДЯТ!** Ошибки `EOF` и `no viable alternative` исчезли.
        - Это подтвердило, что предыдущие проблемы парсинга были связаны с неверной трактовкой `div` и `mod` как операторов.
- **Сопутствующие исправления в `interpreter.py`:**
    - Удалены `KumirLexer.MOD_OP` (и `DIV_OP`, если был) из словаря `ARITHMETIC_OPS`.
    - Удалены блоки `elif op_token.type in [KumirLexer.MOD_OP]:` из методов `_perform_binary_operation` и `visitMultiplicativeExpression`.
- **Статус функциональных тестов (`tests/test_functional.py`) после исправления парсера:**
    - **5 PASSED, 51 FAILED**.
    - Основные ошибки:
        - `NotImplementedError: Массивы пока не поддерживаются` (многочисленные).
        - `AttributeError: 'LoopStatementContext' object has no attribute 'REPEAT'` (циклы `нц для ... повторять`).
        - `KumirEvalError: Попытка вывести неинициализированное значение`.
        - `KumirExecutionError: ... Попытка присвоить значение None`.
        - `KumirEvalError: Процедура или функция '...' не определена` (например, `mod`, `позиция`).
    - Функциональные тесты: **51 failed, 5 passed** (без изменений, проблема с `NoneType` в `28-rec-sumdig.kum` при вызове `mod`/`div` после рекурсивного вызова `sum_digits`).
    - Подготовлен комментарий для [GitHub Issue #4830](https://github.com/antlr/antlr4/issues/4830) об успешном решении проблемы с ошибками EOF в парсере.

**Следующие шаги:**
1.  Синхронизировать изменения грамматики (`div`/`mod` как функции) с файлами в `kumir_lang/` для PR #4477.
2.  Реализовать встроенные функции `mod(a,b)` (остаток от деления) и `div(a,b)` (целочисленное деление) в `BUILTIN_FUNCTIONS` в `interpreter.py`.
3.  Приступить к реализации поддержки массивов (`NotImplementedError`).
4.  Исправить ошибку с циклами `REPEAT` (`AttributeError`).


---

## 2024-08-02 (вечер): Отладка `28-rec-sumdig.kum` - проблема с `NoneType`

**Проблема:**
Тест `28-rec-sumdig.kum` падает с ошибкой `KumirEvalError: Строка ~14: Ошибка типа при передаче аргумента №1 в параметр 'n': Нельзя присвоить значение типа NoneType переменной типа ЦЕЛ`.
Это происходит при вызове `sumDig(N)` (где `N` - это аргумент основной программы, например, `12345`).

**Детальный анализ "путешествия" значения `N`:**
1.  Вычисляется аргумент `N` для вызова `sumDig(N)`. Для этого вызывается `visitExpression(N)`.
2.  `visitExpression(N)` делегирует вычисление цепочке: `visitLogicalOrExpression(N)` -> `visitLogicalAndExpression(N)` -> `visitEqualityExpression(N)` -> ... -> `visitPrimaryExpression(N)`.
3.  `visitPrimaryExpression(N)` корректно определяет, что `N` - это переменная, и возвращает ее значение (например, `12345`).
4.  Это значение (`12345`) успешно "всплывает" обратно по цепочке до `visitEqualityExpression(N)`, который также возвращает `12345`.
5.  **Сбой:** `visitLogicalAndExpression(N)` получает `12345` от `visitEqualityExpression(N)`. Однако, вместо того чтобы просто вернуть это значение (поскольку в `N` нет оператора "И"), он возвращает `None`.
6.  Далее `visitLogicalOrExpression(N)` получает `None` и также возвращает `None`.
7.  В итоге, `visitExpression(N)` возвращает `None`.
8.  Это значение `None` передается как аргумент в `sumDig`, вызывая ошибку типа.

**Анализ простым языком:**

Хорошо, давай попробуем еще раз разобраться, что именно ломается, максимально просто.

Представь, что наша программа – это большой конвейер по вычислению значений.
Когда программа видит команду `вывод sumDig(N)`, она должна сначала понять, чему равен аргумент `N`.

1.  **Задача для `N`**: "Эй, интерпретатор, какое значение у `N`?"
    *   Это задание попадает к главному "вычислителю выражений" (наш метод `visitExpression`).
    *   Этот главный вычислитель говорит: "`N` — это простое выражение, пусть им займется мой подчиненный, специалист по `LogicalOrExpression` (это один из типов выражений в грамматике)."

2.  **Работа "младших специалистов"**:
    *   "Специалист по `LogicalOrExpression`" получает задачу `N`. Он видит, что `N` — это не что-то сложное с операциями `ИЛИ`. Он передает задачу дальше по цепочке: специалисту по `LogicalAndExpression`, тот — специалисту по `EqualityExpression`, и так далее, пока задача не дойдет до самого-самого "младшего специалиста" по `PrimaryExpression`.
    *   Этот "младший специалист по `PrimaryExpression`" смотрит на `N` и говорит: "Ага, это переменная! Я знаю ее значение. `N` равно `12345`." И он возвращает это число `12345`.
    *   Это число `12345` успешно передается обратно наверх по всей цепочке "младших специалистов". Каждый из них, получив `12345`, просто передает его дальше. В итоге, "специалист по `LogicalOrExpression`" тоже получает и возвращает `12345`.

3.  **Возвращение к главному "вычислителю выражений" (`visitExpression`):**
    *   Наш главный "вычислитель выражений" (`visitExpression`) получает от своего подчиненного (`visitLogicalOrExpression`) совершенно правильный результат: `12345`. Он кладет это число в коробочку с надписью `result`.
    *   **И вот тут происходит необъяснимое!** Прямо перед тем, как главный "вычислитель выражений" должен объявить финальный ответ "Значение `N` это `12345`!", число `12345` из коробочки `result` исчезает, и там оказывается `None` (то есть "ничего").
    *   В итоге, `visitExpression` возвращает `None` вместо `12345`.

4.  **Последствия**:
    *   Поскольку `visitExpression` для `N` вернул `None`, функция `sumDig` вызывается как `sumDig(None)`.
    *   Внутри `sumDig`, когда она пытается сделать, например, `mod(n, 10)` (где `n` теперь `None`), возникает ошибка, потому что `mod(None, 10)` — это бессмыслица.

**В чем загадка?**

Загадка в том, *почему* значение `12345`, которое совершенно правильно вычисляется и передается всеми "младшими специалистами" вплоть до `visitLogicalOrExpression`, превращается в `None` именно в тот момент, когда `visitExpression` получает его от `self.visit(ctx.logicalOrExpression())` и сохраняет в `result`.

Мы это проверили: `visitLogicalOrExpression` (и все, кто под ним) **возвращают** `12345`. Но в `visitExpression` переменная `result` **сразу после** строки `result = self.visit(ctx.logicalOrExpression())` уже содержит `None`.

Это очень странное поведение. Похоже на то, что сам механизм `self.visit()`, когда его вызывает `visitExpression` для определенного типа дочернего узла, как-то теряет или портит возвращаемое значение. Почему это происходит только в этой комбинации вызовов — пока неясно. Это может быть какая-то очень тонкая особенность работы визитора ANTLR в Python или что-то в нашей иерархии вызовов, что мы упускаем.

Проблема не в том, что твои отдельные методы `visitLogicalOrExpression` или `visitPrimaryExpression` неправильно работают (они как раз возвращают то, что нужно), а в том, что это правильное значение "теряется" при передаче в `result` внутри `visitExpression`.

Может, такое подробное описание натолкнет тебя на мысль, что может идти не так? Или, может, мы сможем придумать, как заставить `visitExpression` не "терять" это значение.


**Ключевой вопрос:** Почему `visitLogicalAndExpression` (и, возможно, `visitLogicalOrExpression`) возвращают `None`, когда им передается корректное значение от дочернего узла, и в самом выражении нет соответствующего логического оператора (`И` / `ИЛИ`)?

**Предложение пользователя по улучшению отладки:**
Внедрить более детализированное логирование, имитирующее "переговоры между специалистами". Каждый "специалист" (метод `visit...`) должен логировать:
*   Что он ожидает получить от другого "специалиста".
*   Что он фактически получил.
*   Какой результат он сам возвращает и кому.

Пример такого лога:
Есть возможность на каждом из шагов записывать что только что произошло? То есть как если бы каждый из "специалистов" записывал в общий журнал:
1. Специалист 1: Я отдаю следующему специалисту N
2. Специалист 2: Ожидаю получить от Специалиста 1 объект определённого типа.
3. Специалист 2: Я получил от Специалиста 1 N.
4. Специалист 2: Я изучаю N.
5. Специалист 2: N — это переменная. Значение N = 12345.
6. Специалист 2: Я отдаю значение N (12345) выше по инстанции — Специалисту 1.
7. Специалист 1: Ожидаю получить от Специалиста 2 тип объекта, его имя и его значение.
8. Специалист 2: Отдаю Специалисту 1 объект N, тип — переменная, значение 12345.
9. Специалист 1: Получен объект типа "переменная", с именем "N", со значением "12345". 

Это должно помочь точнее отследить, на каком этапе "передачи данных" происходит потеря значения.

---

## 2024-07-30 (Продолжение)

## TODOs and Future Work

- interpreter.py: Review `current_scope` access for `RETURN_VALUE` in `visitPrimaryExpression` to ensure it correctly handles context (e.g., not in a function/procedure scope).
- interpreter.py: Ensured `value` is always defined in `visitPostfixExpression` before being assigned to `current_eval_value` after processing user-defined procedures.

## Session Notes (YYYY-MM-DD)

- YYYY-MM-DD: Fixed linter errors in `interpreter.py` related to indentation, try-except-finally blocks, and an `else` statement. Specifically addressed issues around lines 947-1025 and 1567.

---

## 2024-08-02 (продолжение): Детальное логирование выражений

**Задача:** Внедрить подробное логирование в методы обхода выражений для отслеживания "путешествия" значения `N` в тесте `28-rec-sumdig.kum`.

**Реализация:**
Добавлено подробное логирование (через `print` с префиксом `[DEBUG][visitMethodName]`) в следующие методы файла `pyrobot/backend/kumir_interpreter/interpreter.py`:
*   `visitExpression`
*   `visitLogicalOrExpression`
*   `visitLogicalAndExpression`
*   `visitEqualityExpression`
*   `visitRelationalExpression`
*   `visitAdditiveExpression`
*   `visitMultiplicativeExpression`
*   `visitPowerExpression`
*   `visitUnaryExpression`
*   `visitPrimaryExpression`
*   `visitLiteral`

Каждый логирующий вызов фиксирует:
*   Имя вызванного метода.
*   Контекст (текст узла), для которого он вызван.
*   Значение, полученное от дочерних вызовов (если применимо), и его тип.
*   Возвращаемое значение и его тип.

**Ожидаемый результат:** Логи должны помочь точно определить, на каком этапе и в каком методе происходит потеря или некорректное изменение значения переменной `N` или результатов вызова функций `mod`/`div`.

**Результаты тестирования `28-rec-sumdig.kum` (после добавления логирования):**
*   **Тест упал.**
*   **Ошибка:** `TypeError: KumirParser.PowerExpressionContext.unaryExpression() takes 1 positional argument but 2 were given`
    *   **Место:** `pyrobot/backend/kumir_interpreter/interpreter.py`, строка 813, в методе `visitPowerExpression` при вызове `result = self.visit(ctx.unaryExpression(0))`.
    *   **Причина:** Метод `ctx.unaryExpression()` (сгенерированный ANTLR) не принимает индекс как аргумент (`0`) напрямую. Вместо этого, `ctx.unaryExpression()` следует вызывать без аргументов для получения списка всех дочерних узлов `unaryExpression`, а затем уже этот список индексировать (например, `list[0]`, `list[1]`).
*   **Предложенное исправление:**
    ```python
    # В visitPowerExpression:
    unary_expressions = ctx.unaryExpression() # Получить список
    if not unary_expressions:
        raise KumirEvalError(...)
    result = self.visit(unary_expressions[0]) # Индексировать список
    # ...
    if len(unary_expressions) > 1:
        exponent_ctx = unary_expressions[1] # Индексировать список
        exponent = self.visit(exponent_ctx)
    # ...
    ```
*   **Второстепенная ошибка:** `OSError: [WinError 6] Неверный дескриптор` при попытке печати в `sys.__stderr__` в `test_functional.py` после основного исключения. Не критично для логики интерпретатора.
*   *Анализ логов (если ошибка NoneType сохранилась после исправления TypeError): Место для анализа новых логов.*

**Повторный запуск теста `28-rec-sumdig.kum` (после исправления первой TypeError):**
*   **Тест снова упал.**
*   **Ошибка:** `TypeError: 'UnaryExpressionContext' object is not subscriptable`
    *   **Место:** `pyrobot/backend/kumir_interpreter/interpreter.py`, строка ~819, в методе `visitPowerExpression` при вызове `result = self.visit(unary_expressions[0])` (после первого исправления).
    *   **Причина:** Предыдущее исправление предполагало, что `ctx.unaryExpression()` всегда возвращает список. Однако, если в грамматике `powerExpression` определено так, что `unaryExpression` может встречаться один раз (без операции степени) или дважды (с операцией степени), то `ctx.unaryExpression()` вернет одиночный объект `UnaryExpressionContext` в первом случае и список объектов во втором.
    *   **Предложенное исправление (вторая попытка):**
        ```python
        # В visitPowerExpression:
        unary_expressions_or_obj = ctx.unaryExpression()
        first_unary_expr_ctx = None
        exponent_ctx = None

        if isinstance(unary_expressions_or_obj, list):
            if not unary_expressions_or_obj:
                raise KumirEvalError(...)
            first_unary_expr_ctx = unary_expressions_or_obj[0]
            if len(unary_expressions_or_obj) > 1:
                exponent_ctx = unary_expressions_or_obj[1]
        elif unary_expressions_or_obj: # Это одиночный объект UnaryExpressionContext
            first_unary_expr_ctx = unary_expressions_or_obj
        else:
            raise KumirEvalError(...)

        result = self.visit(first_unary_expr_ctx)
        # ...
        if exponent_ctx:
            exponent = self.visit(exponent_ctx)
        # ...
        ```
*   *Анализ логов (если ошибка NoneType сохранилась после исправления второй TypeError): Место для анализа новых логов.*

**Повторный запуск теста `28-rec-sumdig.kum` (после исправления второй TypeError):**
*   **Тест снова упал.**
*   **Ошибка:** `KumirEvalError: Строка 19, столбец 5: Ошибка вычисления условия: 'KumirInterpreterVisitor' object has no attribute '_handle_type_promotion_for_comparison'`
    *   **Место:** `pyrobot/backend/kumir_interpreter/interpreter.py`, строка 1316, в методе `visitIfStatement` при вызове `self.visit(condition_ctx)`, который глубже вызывает `visitRelationalExpression`, который, в свою очередь, пытается вызвать `_handle_type_promotion_for_comparison`.
    *   **Причина:** Отсутствовал метод `_handle_type_promotion_for_comparison` в классе `KumirInterpreterVisitor`. Вероятно, он был случайно удален во время предыдущих автоматических правок.
    *   **Решение:** Восстановлен метод `_handle_type_promotion_for_comparison`. Он отвечает за приведение типов (например, `цел` к `вещ`) при операциях сравнения.
        ```python
        def _handle_type_promotion_for_comparison(self, left, right, ctx):
            if left is None or right is None:
                raise KumirEvalError(
                    f"Строка ~{ctx.start.line}: Нельзя сравнивать с неинициализированным значением.",
                    ctx.start.line,
                    ctx.start.column
                )
            is_left_int = isinstance(left, int)
            is_left_float = isinstance(left, float)
            is_right_int = isinstance(right, int)
            is_right_float = isinstance(right, float)
            if is_left_int and is_right_float:
                return float(left), right
            if is_left_float and is_right_int:
                return left, float(right)
            return left, right
        ```

**Повторный запуск теста `28-rec-sumdig.kum` (после восстановления `_handle_type_promotion_for_comparison`):**
*   **Тест снова упал.**
*   **Ошибка:** `AttributeError: 'KumirInterpreterVisitor' object has no attribute 'current_scope'`
    *   **Место:** `pyrobot/backend/kumir_interpreter/interpreter.py`, строка 1689 (в старой нумерации, до добавления `_handle_type_promotion_for_comparison`), в методе `visitPrimaryExpression`.
    *   **Контекст:**
        ```python
        elif ctx.RETURN_VALUE():
            if 'return_value' not in self.current_scope: # Ошибка здесь
                raise KumirEvalError("Попытка использования неинициализированного возвращаемого значения")
            result = self.current_scope['return_value']
        ```
    *   **Причина:** Атрибут `self.current_scope` не существует. Вместо него для доступа к текущей области видимости следует использовать `self.scopes[-1]`, так как `self.scopes` – это стек (список) словарей областей видимости.
    *   **Отладочный `print` в `__init__`:**
        *   Добавленный `print(f"[DEBUG][INIT] ... dir(self) ...")` в `__init__` показал пустой список методов `[]`, что странно и требует отдельного изучения, но не связано напрямую с этой `AttributeError`.
    *   **Решение:** Заменить `self.current_scope` на `self.scopes[-1]` в соответствующем блоке метода `visitPrimaryExpression`.
        ```python
        elif ctx.RETURN_VALUE():
            current_scope_dict = self.scopes[-1]
            if 'return_value' not in current_scope_dict:
                raise KumirEvalError("Попытка использования неинициализированного возвращаемого значения")
            result = current_scope_dict['return_value']
        ```

**Повторный запуск теста `28-rec-sumdig.kum` (после исправления `current_scope`):**
*   **Тест снова упал.**
*   **Ошибка:** `KumirEvalError: Попытка использования неинициализированного возвращаемого значения`
    *   **Место:** `pyrobot/backend/kumir_interpreter/interpreter.py`, строка ~1702 (в зависимости от предыдущих правок), в методе `visitPrimaryExpression`.
    *   **Контекст:**
        ```python
        elif ctx.RETURN_VALUE():
            current_scope_dict = self.scopes[-1]
            if 'return_value' not in current_scope_dict: # Ошибка здесь, ключ 'return_value'
                raise KumirEvalError("Попытка использования неинициализированного возвращаемого значения")
            result = current_scope_dict['return_value']
        ```
    *   **Причина:** Несоответствие ключей. При присваивании `знач := ...` (в `visitAssignmentStatement`) и при инициализации возвращаемого значения функции (в `visitPostfixExpression`) используется ключ `'__знач__'`. Однако `visitPrimaryExpression` пытался прочитать значение по ключу `'return_value'`.
    *   **Решение:** В методе `visitPrimaryExpression` заменить ключ `'return_value'` на `'__знач__'` для консистентности.
        ```python
        elif ctx.RETURN_VALUE():
            current_scope_dict = self.scopes[-1]
            if '__знач__' not in current_scope_dict: # Исправлено на '__знач__'
                raise KumirEvalError("Попытка использования неинициализированного возвращаемого значения")
            result = current_scope_dict['__знач__'] # Исправлено на '__знач__'
        ```
    *   **Примечание по отладке:** Отладочные `print` для `type(self)` и `hasattr` в `visitRelationalExpression` и `visitEqualityExpression` показали, что `self` является корректным объектом `KumirInterpreterVisitor` и *имеет* атрибут `_handle_type_promotion_for_comparison` непосредственно перед предыдущей ошибкой `AttributeError`. Это делает предыдущую ошибку еще более загадочной, но, похоже, она была связана не с отсутствием метода, а с чем-то в стеке вызовов, что "маскировало" его для `visitIfStatement`. Текущая ошибка `KumirEvalError` из-за неинициализированного `знач` является более понятной.

---

## Отладка `28-rec-sumdig.kum` (продолжение)

**Проблема:** Тест падает с `KumirEvalError` ("Попытка вывести неинициализированное значение" или "Попытка использовать неинициализированное значение в операции '+'").

**Ключевое наблюдение (из логов пользователя):**
Выражение `n mod 10` внутри рекурсивной функции `sumDig` вычисляется в `None`.
Это `None` затем передается как левый операнд в операцию `+` (в выражении `(n mod 10) + sumDig(div(n,10))`), что приводит к ошибке в `_check_numeric`.
Лог пользователя:
```
[DEBUG][PRE_PERFORM_OP_ADD] op_text:'+', L_operand:'None'(NoneType), R_operand:'1'(int), expr_ctx:'(n mod 10)+sumDig(div(n,10))'
[DEBUG][_check_numeric] ENTERED. Op: +. Value initial type: NoneType.
[DEBUG][_check_numeric] Value after _get_value for op '+': None (type: NoneType)
[DEBUG][_check_numeric] Raising KumirEvalError: processed_value is None for op '+'
```

**Загадка:**
Почему `n mod 10` вычисляется в `None`?
Метод `visitMultiplicativeExpression` использует `_perform_binary_operation` для обработки операторов, включая `mod`.
Словарь `ARITHMETIC_OPS` не содержит оператор `KumirLexer.MOD` (ключевое слово `mod`).
Следовательно, `_perform_binary_operation` должен был бы обнаружить, что `operation_func` для `mod` не найдена, и сгенерировать `KumirEvalError` с сообщением "Неизвестный или неподдерживаемый арифметический оператор: mod".
Однако этой ошибки в логах нет, а вместо этого `n mod 10` каким-то образом возвращает `None`.

**Текущие действия (06.08.2024):**
1.  Обсудили с пользователем способы разделения `stdout` (вывод программы) и `stderr` (отладочные сообщения) при запуске тестов `pytest`.
2.  Добавили подробные отладочные сообщения в `_perform_binary_operation` в `interpreter.py`, чтобы отследить, как именно обрабатывается оператор `mod` (токен `KumirLexer.MOD`), находится ли для него функция в `ARITHMETIC_OPS`, и выполняется ли блок `if not operation_func:`.

**Следующий шаг:** Проанализировать логи после запуска теста с новыми отладочными сообщениями в `_perform_binary_operation`.

---

**Загадка:**
Почему `n mod 10` вычисляется в `None`?
Метод `visitMultiplicativeExpression` должен был бы либо вызвать `_perform_binary_operation` (если там есть `mod` или `div`), либо просто вернуть результат `visitPowerExpression`.
Если `mod` обрабатывается как встроенная функция (через `visitPostfixExpression` -> `_call_builtin_function`), то там тоже не должно быть проблем с `None`, т.к. `mod(N, 10)` возвращал корректные значения на предыдущих шагах.

**Новая проблема (07.08.2024):**
После добавления детального логгирования в `_perform_binary_operation` для отслеживания типа оператора:
    ```python
```

## Детальная история отладки теста `28-rec-sumdig.kum` (08.08.2024)

Мы столкнулись с серией проблем при отладке теста `28-rec-sumdig.kum`, который изначально падал с ошибкой `KumirEvalError`. Ниже приведено поэтапное описание процесса.

**Этап 1: Первоначальная ошибка - `KumirEvalError` (неинициализированное значение при выводе)**

*   **Проблема:** Тест падал, потому что оператор `вывод` в программе КуМир пытался напечатать результат рекурсивной функции `sumDig(N)`, но получал `None`.
*   **Гипотеза:** Потеря значения при передаче из методов `visitLogicalOrExpression` / `visitLogicalAndExpression` в `visitExpression`.
*   **Действия:**
    *   Добавлено подробное логирование (`[DEBUG][visit...]`) во все методы обхода выражений.
    *   Исправлена ошибка в `visitPrimaryExpression`: ключ для `ctx.RETURN_VALUE()` был `'return_value'` вместо `'__знач__'`.
*   **Находка:** Логирование показало, что `self.visit(sumDig_N_context)` возвращал `None` в `visitStatement` перед вызовом оператора `вывод`.

**Этап 2: Локализация проблемы в бинарных операциях внутри `sumDig`**

*   **Проблема:** Дальнейший анализ показал, что `None` появлялся глубже, внутри вычислений функции `sumDig`.
*   **Гипотеза:** Ошибка происходит внутри `self._perform_binary_operation`, когда левый операнд (результат `n mod 10`) передается как `None`.
*   **Действия:**
    *   Добавлены отладочные `print` перед вызовом `_perform_binary_operation` в `visitAdditiveExpression` и `visitMultiplicativeExpression`.
    *   Добавлены `print` внутри `_check_numeric`.
*   **Находка (БИНГО!):**
    ```
    [DEBUG][PRE_PERFORM_OP_ADD] op_text:'+', L_operand:'None'(NoneType), R_operand:'1'(int), expr_ctx:'(n mod 10)+sumDig(div(n,10))'
    [DEBUG][_check_numeric] ENTERED. Op: +. Value initial type: NoneType.
    [DEBUG][_check_numeric] Value after _get_value for op '+': None (type: NoneType)
    [DEBUG][_check_numeric] Raising KumirEvalError: processed_value is None for op '+'
    ```
    Это подтвердило, что `n mod 10` на каком-то шаге рекурсии вычислялось в `None`.

**Этап 3: Поиск причины `None` от `n mod 10` и попутная ошибка `AttributeError`**

*   **Задача:** Выяснить, почему `n mod 10` дает `None`.
*   **Действия:**
    *   Добавлен детальный `print` в `_perform_binary_operation` для отображения типов операторов, используя `KumirLexer.MOD` и `KumirLexer.DIV_KEYWORD`.
*   **Проблема (новая):** Возникла `AttributeError: type object 'KumirLexer' has no attribute 'MOD'` (и аналогично для `DIV_KEYWORD`).
*   **Действия (исправление `AttributeError`):**
    *   С помощью `grep_search` найдены правильные имена токенов: `KumirLexer.DIV` и предположительно `KumirLexer.MOD_KEYWORD` (хотя для `mod` в грамматике используется текстовый токен `'mod'`, а не именованный).
    *   Отладочный `print` был исправлен (временно убран `KumirLexer.MOD`, оставлен `KumirLexer.DIV`).
*   **Результат:** После исправления `AttributeError`, программа КуМир начала выполняться корректно, и функция `sumDig` стала возвращать правильное значение (15). **Исходная `KumirEvalError` была решена!**

**Этап 4: Новая проблема - `AssertionError` (пустой вывод)**

*   **Проблема:** Тест `28-rec-sumdig.kum` начал падать с `AssertionError`, так как `actual_output` в `test_functional.py` был пустым (`''`), хотя ожидался вывод `"Сумма цифр: 15\n"`.
*   **Гипотеза:** Проблема в том, как `run_kumir_program` (или вызываемая ею `interpret_kumir`) захватывает или возвращает `stdout` программы.
*   **Действия:**
    *   Проверено, что `visitStatement` для `io_ctx.OUTPUT()` использует `sys.stdout.write`.
    *   Добавлены отладочные `print` в `interpret_kumir` (перед `return stdout_capture.getvalue()`) и в `run_kumir_program` (для `returned_from_interpret_kumir` и `actual_output`).
*   **Находка:**
    *   `interpret_kumir` успешно захватывал вывод "Сумма цифр: 15\n" во внутренний `stdout_capture`.
    *   `interpret_kumir` возвращал этот захваченный вывод.
    *   `run_kumir_program` получал этот вывод, но `output_buffer.getvalue()` (который использовался для `actual_output` в тесте) оставался пустым.

**Этап 5: Отладка `DiagnosticErrorListener` (небольшое отступление)**

*   **Проблема:** В логах появилась ошибка `AttributeError: 'DiagnosticErrorListener' object has no attribute 'errors'`.
*   **Причина:** `DiagnosticErrorListener` был спроектирован для немедленного возбуждения исключения `KumirSyntaxError` при ошибке, а не для сбора ошибок в список `self.errors`.
*   **Решение:** Удалена проверка `if error_listener.errors:` в `interpret_kumir`.

**Этап 6: Отладка `AttributeError` в `visitAdditive/MultiplicativeExpression` (еще одно отступление)**

*   **Проблема:** Пытаясь "улучшить" обработку выражений без операторов в `visitAdditiveExpression` и `visitMultiplicativeExpression`, я вызвала `AttributeError: 'MultiplicativeExpressionContext' object has no attribute 'multiplicativeOperator'`. Это происходило, когда в выражении не было операторов (например, просто число). ANTLR не создает методы типа `multiplicativeOperator()` если соответствующий элемент грамматики (`(OP multiplicativeExpression)*`) отсутствует в конкретном узле.
*   **Решение:** Методы `visitAdditiveExpression` и `visitMultiplicativeExpression` были возвращены к их предыдущей, более простой, реализации, которая корректно обрабатывала одиночные операнды, полагаясь на количество дочерних `multiplicativeExpression` (или `powerExpression`).

**Этап 7: Решение `AssertionError` - двойное перенаправление `stdout`**

*   **Ключевая Находка (из логов Этапа 4):**
    ```
    [DEBUG_RUN_KUMIR_PROGRAM] BEFORE redirect_stdout. output_buffer is: ''
    ...
    [DEBUG_INTERPRET_KUMIR] Content of stdout_capture (18 chars):
    >>>
    Сумма цифр: 15
    <<<
    [DEBUG_RUN_KUMIR_PROGRAM] interpret_kumir returned:
    >>>
    Сумма цифр: 15
    <<<
    [DEBUG_RUN_KUMIR_PROGRAM] AFTER redirect_stdout. output_buffer is: ''
    [DEBUG_RUN_KUMIR_PROGRAM] actual_output which will be asserted: ''
    ```
*   **Причина `AssertionError`:**
    1.  `interpret_kumir` самостоятельно перехватывает `sys.stdout` в свой внутренний `StringIO` (назовем его `interpreter_buffer`) и корректно возвращает его содержимое в виде строки.
    2.  `run_kumir_program` создавал свой `StringIO` (`output_buffer`) и *дополнительно* оборачивал вызов `interpret_kumir` в `with redirect_stdout(output_buffer):`.
    3.  Внутри `interpret_kumir` `sys.stdout.write` писал в `interpreter_buffer`.
    4.  Однако, сам `output_buffer` (внешний) оставался пустым, потому что `interpret_kumir` уже "съел" весь вывод в свой буфер и вернул его как строку. Контекстный менеджер `redirect_stdout` не мог получить доступ к выводу, который уже был перенаправлен и обработан внутри `interpret_kumir`.
    5.  Тест сравнивал с `output_buffer.getvalue()`, который был пуст.
*   **Решение:**
    *   Удалить блок `with redirect_stdout(output_buffer):` из `run_kumir_program`.
    *   Использовать строку, возвращаемую `interpret_kumir`, напрямую как `actual_output_value`.
    *   Сравнить `actual_output_value` с ожидаемым результатом в тесте.

**Результат:** После устранения двойного перенаправления `stdout` тест `28-rec-sumdig.kum` успешно ПРОШЕЛ!


---

## Проблема с финальным переносом строки в команде `вывод` (09.08.2024)

*   **Проблема:** Интерпретатор некорректно обрабатывал команду `вывод`. Он автоматически добавлял символ новой строки (`\n`) в конце вывода, даже если в команде не было указано `нс` (новая строка) в качестве последнего аргумента. Это противоречило стандарту языка КуМир, где перенос строки должен происходить только по явной команде `нс`. Такое поведение было выявлено при отладке теста `1-primes.kum`.
*   **Исправление:** В файле `pyrobot/backend/kumir_interpreter/interpreter.py`, в методе `visitStatement` (конкретно при обработке ветки `io_ctx.OUTPUT()`), была удалена логика, отвечавшая за автоматическое добавление `\n`. Это включало удаление использования переменной `printed_non_literal` и соответствующего условного вызова `sys.stdout.write('\n')` в конце обработки аргументов вывода. Также были исправлены многочисленные ошибки отступов в методе `visitLoopStatement`, обнаруженные линтером.
*   **Результат:** После исправления команда `вывод` стала работать в точном соответствии со стандартом КуМира. Это позволило успешно пройти тестам `1-primes.kum` и `2-2+2.kum`, так как их ожидаемый вывод теперь совпадает с фактическим.

---

## Справка: Массивы (таблицы) в КуМире

**Документация:**
- Основное описание: `kumir2-master/userdocs/language/indentifiers.xml`, секция "Простые величины и таблицы. Описания величин" (примерно строки 400-450)
- Примеры объявлений: см. примеры в этом же разделе

### 1. Типы массивов (таблиц)
- `целтаб` — массив целых чисел
- `вещтаб` — массив вещественных чисел
- `логтаб` — массив логических значений
- `симтаб` — массив символов
- `литтаб` — массив строк
- Можно писать как слитно, так и раздельно: `цел таб k[-5:5]` или `вещтаб tab[1:4, 1:12]`

### 2. Размерность и индексы
- Массивы бывают 1-, 2- и 3-мерные
- Для каждого измерения указываются границы индексов (например, `[1:4, 1:12]`)
- Индексы могут быть отрицательными и не обязаны начинаться с 1

### 3. Примеры объявления
```
цел таб k[-5:5]
вещтаб tab[1:4, 1:12]
```
- `k` — одномерный массив с индексами от -5 до 5 (11 элементов)
- `tab` — двумерный массив 4×12 (48 элементов)

### 4. Использование
- Элемент массива: `a[i]`, `b[i,j]`
- Присваивание: `a[i] := 2*a[i-2]+a[i-1]`
- Можно использовать в выражениях, выводе, вводе и т.д.

### 5. Область действия и инициализация
- Массивы объявляются как обычные переменные, но с указанием типа и размерности
- По умолчанию элементы не инициализированы (как и обычные переменные)

### 6. Что реализовать в интерпретаторе
- Парсинг объявлений массивов (`целтаб`, `вещтаб` и т.д.) и их размерностей
- Хранение массивов в области видимости (например, как dict с ключами-индексами или вложенные списки)
- Поддержка обращения к элементам по индексу (в том числе с несколькими измерениями)
- Проверка выхода за границы
- Корректная инициализация (по умолчанию — неинициализировано)
- Ввод/вывод элементов массива

---

## Сессия 19.07.2024 (Продолжение работы с таблицами)

**Прогресс:**
- Успешно исправлены многочисленные ошибки отступов в `pyrobot/backend/kumir_interpreter/interpreter.py`, которые мешали сборке тестов `pytest`. Ключевым моментом стало добавление `pass` в пустой блок `if var_info['is_table']:` в `visitAssignmentStatement` пользователем.
- Исправлена ошибка `ImportError: cannot import name 'KumirRunError'`, путем удаления некорректного импорта из `interpreter.py`.
- Первый тест для таблиц `tests/test_tables.py::test_simple_1d_table_declaration_assignment_output` успешно **ПРОЙДЕН**. Это подтверждает базовую работоспособность объявления, присваивания и чтения для одномерных таблиц целого типа.

**План на следующую итерацию (таблицы):**
1.  Реализовать и запустить тест `test_2d_table_operations`:
    *   Объявление 2D таблицы (например, `целтаб T[1:2, 1:3]`).
    *   Присваивание значений нескольким элементам (например, `T[1,1] := 10`, `T[2,3] := 23`).
    *   Вывод этих элементов.
    *   Проверка, что вывод соответствует ожидаемому.
2.  Продолжить реализацию тестов для таблиц из списка TODO в `tests/test_tables.py`, покрывая различные сценарии:
    *   Выход за границы индексов (чтение/запись).
    *   Некорректные типы индексов.
    *   Несоответствие размерностей.
    *   Чтение неинициализированных элементов.
    *   Присваивание значений неверного типа.
    *   Объявление с некорректными границами.
    *   Тесты для других типов таблиц (`вещтаб`, `логтаб`, `симтаб`, `литтаб`).

**Заметки по коду/рефакторингу (на будущее):**
- Блок `if var_info['is_table']:` в `visitAssignmentStatement` на данный момент содержит только `pass`. Когда будем реализовывать присваивание целых таблиц (например, `Таблица1 := Таблица2`), эту логику нужно будет добавить туда.

## Рефакторинг interpreter.py - Фаза 2

**Задача:** Продолжить перенос логики выражений из `interpreter.py` в `expression_evaluator.py`.

**Шаг 1 (текущий):**
1.  Обновить `visitAssignmentStatement` в `interpreter.py`:
    *   Использовать `self.evaluator.visitExpression()` для правой части.
    *   Реализовать полную логику присваивания (переменные, таблицы, `__знач__`).
2.  Удалить из `interpreter.py`:
    *   Методы: `visitExpression`, `visitLogicalOrExpression`, `visitLogicalAndExpression`, `visitEqualityExpression`, `visitRelationalExpression`, `visitAdditiveExpression`, `visitMultiplicativeExpression`, `visitPowerExpression`, `visitUnaryExpression`, `visitPostfixExpression`, `visitPrimaryExpression`, `visitLiteral`.
    *   Вспомогательные методы: `_get_value`, `_handle_type_promotion_for_comparison`, `_check_numeric`, `_check_logical`, `_check_comparable`, `_perform_binary_operation`.
    *   Константы: `ARITHMETIC_OPS`, `COMPARISON_OPS`, `LOGICAL_OPS`.

**Следующие шаги:**
*   Заменить все вызовы удаленных методов в `interpreter.py` на `self.evaluator.имя_метода(...)`.
*   Проверить вызовы `self.visitor.visit()` в `ExpressionEvaluator` и скорректировать их.

**Итоги Фазы 2:**
*   Методы `visit...Expression` и их хелперы теперь полностью находятся в `ExpressionEvaluator`.
*   Вызовы этих методов из `KumirInterpreterVisitor` (в `visitAssignmentStatement`, `visitVariableDeclaration`, `visitLoopStatement`, `visitIfStatement`, `visitStatement`, `visitArgumentList`) были обновлены для использования `self.evaluator`.
*   Внутренние вызовы в `ExpressionEvaluator` для обработки подвыражений (например, в `visitPrimaryExpression` для `(выражение)`) также обновлены на `self.visitExpression()`.
*   Константы операций и дублирующиеся хелперы должны быть удалены из `KumirInterpreterVisitor` (предполагается, что это так, несмотря на сложности с их автоматическим удалением).

**Потенциальные задачи на будущее/проверку:**
*   Убедиться в полном удалении старых методов `visit...Expression` и хелперов из `interpreter.py`.
*   Пересмотреть использование `_get_value` в `interpreter.py` после вызовов `self.evaluator.visitExpression()` (вероятно, они избыточны).
*   Рассмотреть перенос `visitArgumentList` из `interpreter.py` в `expression_evaluator.py`.
*   Провести тщательное тестирование, включая тест `28-rec-sumdig.kum`.

## Финальный обзор interpreter.py (2024-08-12)

По результатам детальной проверки выявлены следующие моменты:

*   **`get_default_value` (строка ~71):**
    *   Для `kumir_type == 'сим'` возвращается `''`. Это приемлемо, так как `_validate_and_convert_value_for_assignment` проверяет длину символа.

*   **`declare_variable` (строка ~134):**
    *   **TODO к исправлению:** Заменить `raise Exception(...)` на `raise DeclarationError(...)` при повторном объявлении переменной.
    *   Сохраняется TODO из кода: "Использовать KumirExecutionError или DeclarationError".

*   **`_get_type_info_from_specifier` (строка ~161):**
    *   Закомментированный `else` для `arrayType` (строка ~191) – вероятно, не нужен, если грамматика обеспечивает наличие одного из `*_ARRAY_TYPE`.
    *   Отладочный `print` для `if base_kumir_type is None:` (строка ~210) – можно убрать, если определение типа выше надежно.

*   **`_collect_procedure_definitions` (строка ~366):**
    *   **TODO к исправлению:** Строку `line = header.start.line` (строка ~389) перенести внутрь блока `else:`, который обрабатывает случай отсутствия `header` (где сейчас `raise DeclarationError(f"Строка {line}: Отсутствует имя в заголовке алгоритма.")`).
    *   Сохраняется TODO из кода: "Разрешить перегрузку или выдавать ошибку? Пока ошибка."

*   **`visitAssignmentStatement` (строка ~681):**
    *   **TODO к исправлению:** Инициализировать `self.return_value = {}` в `__init__` (поскольку далее используется как словарь при присваивании `ЗНАЧ`).
    *   Логика `if not l_value_ctx and not ctx.ASSIGN():` (интерпретация как "expression statement") – допустима, если вызов процедуры может быть оператором.

*   **`visitStatement` (блок `OUTPUT`, строка ~761):**
    *   **TODO к исправлению:** Строка `value = self._get_value(value) if hasattr(self, '_get_value') else value` (строка ~910). Метод `_get_value`, вероятно, удален. Если `ExpressionEvaluator` возвращает "чистое" значение, эту строку можно упростить до `pass` или удалить (фактически, она и так не меняет `value`, если `_get_value` нет).

*   **`visitLoopStatement` (строка ~1050):**
    *   **TODO к исправлению:** Удалить `loop_executed_once = False` (строка ~1125), так как она не используется.

*   **`_handle_input` (строка ~1258):**
    *   Метод частично дублирует логику `ExpressionEvaluator`. Стоит рассмотреть возможность его упрощения или полной замены на вызовы `self.evaluator.visitExpression()`, особенно для `arg_ctx.expression()`. Обработка простых литералов может быть избыточной. (Пока оставляем, требует отдельного анализа).

*   **Прочие TODO из кода:**
    *   `declare_variable` (строка ~136): "Использовать KumirExecutionError или DeclarationError".
