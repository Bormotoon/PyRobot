#!/usr/bin/env python3
"""
Генератор тестов для курсов Полякова.

Парсит .kurs.xml и .work.xml файлы, извлекает эталонные решения из атрибута 'prg'
элементов <USER_PRG>/<TESTED_PRG>, и создает pytest-тесты для проверки интерпретатора КуМир.

Основано на анализе структуры XML из kurs_test_gen_info.md.
"""

import xml.etree.ElementTree as ET
import re
import html
from pathlib import Path
from typing import Dict, List, Optional
from datetime import datetime

# Константы
POLYAKOV_KURS_WORK_DIR = Path("c:/Users/Bormotoon/VSCodeProjects/PyRobot/polyakov_kurs_work")
GENERATED_TESTS_DIR = Path("c:/Users/Bormotoon/VSCodeProjects/PyRobot/tests/generated_course_tests")
TEST_TEMPLATE_PATH = Path("c:/Users/Bormotoon/VSCodeProjects/PyRobot/tests/test_polyakov_kum.py")

# Убедимся, что директория для тестов существует
GENERATED_TESTS_DIR.mkdir(parents=True, exist_ok=True)


def sanitize_filename(name: str) -> str:
    """Очищает имя файла от недопустимых символов для файловой системы."""
    # Удаляем недопустимые символы для имен файлов
    name = re.sub(r'[<>:"/\\|?*]', '', name)
    # Заменяем пробелы на подчеркивания
    name = name.replace(" ", "_")
    # Удаляем множественные подчеркивания
    name = re.sub(r'_+', '_', name)
    # Убираем подчеркивания в начале и конце
    name = name.strip('_')
    return name if name else "unnamed"


def parse_kurs_xml(kurs_file_path: Path) -> Dict[str, Dict[str, str]]:
    """
    Парсит .kurs.xml файл и извлекает информацию о задачах.
    
    Returns:
        Dict[task_id, {name: str, id: str}]
    """
    tasks: Dict[str, Dict[str, str]] = {}
    
    try:
        tree = ET.parse(kurs_file_path)
        root = tree.getroot()
        
        # Ищем все элементы <T> с атрибутом id
        for task_node in root.findall(".//T[@id]"):
            task_id = task_node.get("id")
            if not task_id:
                continue
                
            # Проверяем, что это действительно задача (имеет <PROGRAM>)
            program_node = task_node.find("PROGRAM")
            if program_node is None or not program_node.text or not program_node.text.strip():
                continue
                
            # Получаем имя задачи
            task_name = None
            
            # Сначала пробуем из xml:name
            if task_name is None:
                task_name = task_node.get("{http://www.w3.org/XML/1998/namespace}name")
            
            # Потом из обычного name
            if task_name is None:
                task_name = task_node.get("name")
            
            # Если имя слишком техническое (типа "1-0"), ищем в описании
            if task_name is None or re.fullmatch(r"\d+-\d+", task_name):
                desc_node = task_node.find("DESC")
                if desc_node is not None and desc_node.text:
                    # Очищаем от HTML тегов и берем первое предложение
                    desc_text = re.sub(r'<[^>]+>', '', desc_node.text.strip())
                    first_sentence = desc_text.split('.')[0].strip()
                    if first_sentence:
                        task_name = first_sentence
            
            # Если все еще нет имени, генерируем стандартное
            if not task_name:
                task_name = f"Задача_{task_id}"
                
            tasks[task_id] = {
                "name": task_name,
                "id": task_id
            }
            
    except ET.ParseError as e:
        print(f"❌ Ошибка парсинга XML файла {kurs_file_path}: {e}")
    except Exception as e:
        print(f"❌ Неожиданная ошибка при парсинге {kurs_file_path}: {e}")
    
    return tasks


def clean_kumir_code_from_prg(raw_prg: str) -> str:
    """
    Очищает код КуМир из атрибута 'prg' согласно kurs_test_gen_info.md:
    1. Декодирует HTML-сущности
    2. Удаляет маркеры |@protected и |@hidden
    """
    # Декодируем HTML-сущности
    cleaned = html.unescape(raw_prg)
    
    # Удаляем маркеры защиты/скрытия
    cleaned = re.sub(r'\|@(protected|hidden)', '', cleaned)
    
    # Убираем лишние пустые строки
    cleaned = re.sub(r'\n\s*\n', '\n\n', cleaned)
    
    return cleaned.strip()


def extract_task_name_from_kumir_code(kumir_code: str) -> Optional[str]:
    """Извлекает название задачи из первой строки алгоритма."""
    lines = kumir_code.split('\n')
    for line in lines:
        line = line.strip()
        if line.startswith('алг ') and '(' in line:
            # Извлекаем название между "алг " и "("
            match = re.match(r'алг\s+([^(]+)', line)
            if match:
                return match.group(1).strip()
    return None


def parse_work_xml(work_file_path: Path, tasks_info: Dict[str, Dict[str, str]]) -> Dict[str, str]:
    """
    Парсит .work.xml файл и извлекает решения для задач.
    
    Ищет элементы <USER_PRG> и <TESTED_PRG> с атрибутом 'prg',
    согласно структуре, описанной в kurs_test_gen_info.md.
    
    Returns:
        Dict[task_id, cleaned_kumir_code]
    """
    solutions: Dict[str, str] = {}
    
    try:
        tree = ET.parse(work_file_path)
        root = tree.getroot()
        
        # Ищем элементы USER_PRG и TESTED_PRG
        for element_name in ["USER_PRG", "TESTED_PRG"]:
            for prg_element in root.findall(f".//{element_name}[@testId][@prg]"):
                test_id = prg_element.get("testId")
                raw_prg = prg_element.get("prg")
                
                if not test_id or not raw_prg:
                    continue
                    
                # Проверяем, что это задача из нашего курса
                if test_id not in tasks_info:
                    print(f"⚠️  Найдено решение для неизвестной задачи {test_id} в {work_file_path.name}")
                    continue
                
                # Очищаем код согласно info-файлу
                cleaned_code = clean_kumir_code_from_prg(raw_prg)
                
                if cleaned_code:
                    solutions[test_id] = cleaned_code
                    print(f"✅ Извлечено решение для задачи {test_id}: {tasks_info[test_id]['name']}")
                else:
                    print(f"⚠️  Пустое решение для задачи {test_id}")
        
        # Приоритет TESTED_PRG над USER_PRG если есть оба (обычно они идентичны)
                    
    except ET.ParseError as e:
        print(f"❌ Ошибка парсинга XML файла {work_file_path}: {e}")
    except Exception as e:
        print(f"❌ Неожиданная ошибка при парсинге {work_file_path}: {e}")
    
    return solutions


def generate_test_file_content(course_name: str, tasks_with_solutions: Dict[str, Dict[str, str]]) -> str:
    """
    Генерирует содержимое файла с pytest-тестами для курса.
    
    Args:
        course_name: Имя курса
        tasks_with_solutions: Dict[task_id, {name, id, solution?}]
    """
    
    # Читаем шаблон тестов
    try:
        with open(TEST_TEMPLATE_PATH, "r", encoding="utf-8") as f:
            template_content = f.read()
    except FileNotFoundError:
        print(f"❌ Файл шаблона {TEST_TEMPLATE_PATH} не найден")
        return ""
    except Exception as e:
        print(f"❌ Ошибка чтения шаблона: {e}")
        return ""
    
    # Генерируем тестовые функции
    test_functions = []
    
    for task_id, data in tasks_with_solutions.items():
        task_name = data["name"]
        solution_code = data.get("solution", "")
        
        if not solution_code:
            print(f"⚠️  Пропускаем задачу '{task_name}' (ID: {task_id}) - нет решения")
            continue
        
        # Создаем безопасное имя для функции теста
        safe_course_name = sanitize_filename(course_name)
        safe_task_name = sanitize_filename(task_name)
        test_func_name = f"test_{safe_course_name}_{safe_task_name}_{task_id}"
        
        # Экранируем код для Python строки
        escaped_code = solution_code.replace('\\', '\\\\').replace("'''", "\\'\\'\\'")
        
        # Генерируем функцию теста
        test_function = f'''
def {test_func_name}(run_kumir_code_func, tmp_path):
    """
    Тест для задачи: {task_name} (ID: {task_id})
    Курс: {course_name}
    
    Ожидаемый результат: "Задание зачтено."
    """
    kumir_code = """{escaped_code}"""
    
    file_path = tmp_path / "{safe_course_name}_{safe_task_name}_{task_id}.kum"
    with open(file_path, "w", encoding="utf-8") as f:
        f.write(kumir_code)
    
    result = run_kumir_code_func(str(file_path))
    
    # Проверяем успешное выполнение
    assert result.return_code == 0, f"Код завершился с ошибкой: {{result.stderr_output}}"
    
    # Проверяем ожидаемый вывод
    expected_output = "Задание зачтено.\\n"
    assert result.stdout_output == expected_output, f"Неожиданный вывод.\\nОжидалось: {{expected_output!r}}\\nПолучено: {{result.stdout_output!r}}"
'''
        
        test_functions.append(test_function)
    
    if not test_functions:
        print(f"⚠️  Нет тестов для генерации в курсе {course_name}")
        return ""
    
    # Собираем итоговый файл
    # Берем шаблон и добавляем наши тесты в конец
    final_content = template_content.rstrip() + "\n\n"
    final_content += f"# Автогенерированные тесты для курса: {course_name}\n"
    final_content += f"# Сгенерировано: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n"
    final_content += "\n".join(test_functions)
    final_content += "\n"
    
    return final_content


def main():
    """Главная функция генератора тестов."""
    start_time = datetime.now()
    print(f"🚀 [{start_time.strftime('%Y-%m-%d %H:%M:%S')}] Начинаем генерацию тестов...")
    print(f"📁 Исходная директория: {POLYAKOV_KURS_WORK_DIR}")
    print(f"📁 Целевая директория: {GENERATED_TESTS_DIR}")
    
    course_count = 0
    generated_files_count = 0
    total_tests_count = 0
    
    # Обрабатываем каждый курс
    for course_dir in POLYAKOV_KURS_WORK_DIR.iterdir():
        if not course_dir.is_dir():
            continue
            
        course_name = course_dir.name
        print(f"\n📚 Обрабатываем курс: {course_name}")
        
        # Ищем .kurs.xml файл
        kurs_file = None
        for pattern in [f"{course_name}.kurs.xml", "*.kurs.xml"]:
            matches = list(course_dir.glob(pattern))
            if matches:
                kurs_file = matches[0]
                break
        
        if not kurs_file:
            print(f"❌ Не найден .kurs.xml файл в {course_dir}")
            continue
        
        # Ищем .work.xml файл
        work_file = None
        for pattern in [f"Поляков_{course_name}.work.xml", "*.work.xml"]:
            matches = list(course_dir.glob(pattern))
            if matches:
                work_file = matches[0]
                break
        
        if not work_file:
            print(f"❌ Не найден .work.xml файл в {course_dir}")
            continue
        
        print(f"📄 Курс: {kurs_file.name}")
        print(f"📄 Решения: {work_file.name}")
        
        # Парсим файлы
        tasks_info = parse_kurs_xml(kurs_file)
        if not tasks_info:
            print(f"❌ Не найдено задач в {kurs_file.name}")
            continue
        
        print(f"📝 Найдено задач в курсе: {len(tasks_info)}")
        
        solutions = parse_work_xml(work_file, tasks_info)
        print(f"✅ Извлечено решений: {len(solutions)}")
        
        # Объединяем данные
        tasks_with_solutions = {}
        for task_id, task_data in tasks_info.items():
            combined_data = task_data.copy()
            if task_id in solutions:
                combined_data["solution"] = solutions[task_id]
            tasks_with_solutions[task_id] = combined_data
        
        # Генерируем тесты
        test_content = generate_test_file_content(course_name, tasks_with_solutions)
        if not test_content:
            print(f"❌ Не удалось сгенерировать тесты для {course_name}")
            continue
        
        # Сохраняем файл
        test_file_name = f"test_{sanitize_filename(course_name)}.py"
        test_file_path = GENERATED_TESTS_DIR / test_file_name
        
        try:
            with open(test_file_path, "w", encoding="utf-8") as f:
                f.write(test_content)
            
            tests_in_file = len([task for task in tasks_with_solutions.values() if "solution" in task])
            print(f"✅ Сгенерирован файл: {test_file_path.name} ({tests_in_file} тестов)")
            
            generated_files_count += 1
            total_tests_count += tests_in_file
            
        except Exception as e:
            print(f"❌ Ошибка записи {test_file_path}: {e}")
        
        course_count += 1
    
    # Итоговая статистика
    end_time = datetime.now()
    duration = end_time - start_time
    
    print(f"\n🎉 [{end_time.strftime('%Y-%m-%d %H:%M:%S')}] Генерация завершена!")
    print(f"📊 Обработано курсов: {course_count}")
    print(f"📊 Сгенерировано файлов: {generated_files_count}")
    print(f"📊 Всего тестов: {total_tests_count}")
    print(f"⏱️  Время выполнения: {duration}")


if __name__ == "__main__":
    main()

    lines = template_content.split('\n')
    insert_after_line_index = -1 

    # Ищем место для вставки: после всех импортов и фикстур, но перед первым тестом
    # Или просто в конец файла, если шаблон пустой или не содержит тестов
    
    last_import_or_fixture_line = 0
    first_test_line = -1

    for i, line in enumerate(lines):
        if line.strip().startswith("import ") or line.strip().startswith("from "):
            last_import_or_fixture_line = i
        if line.strip().startswith("@pytest.fixture"): # Учитываем фикстуры
             # Ищем конец фикстуры (следующая пустая строка или начало def)
            for j in range(i + 1, len(lines)):
                if not lines[j].strip() or lines[j].strip().startswith("def "):
                    last_import_or_fixture_line = j -1 # Конец фикстуры - предыдущая строка
                    break
            else: # Если фикстура идет до конца файла
                last_import_or_fixture_line = len(lines) -1


        if line.strip().startswith("def test_") and first_test_line == -1:
            first_test_line = i
            break # Нашли первый тест, дальше не ищем

    if first_test_line != -1:
        # Если есть тесты, вставляем перед первым из них, но после импортов/фикстур
        insert_after_line_index = max(last_import_or_fixture_line, 0) if first_test_line == 0 else first_test_line -1
        # Берем все до этой точки
        header_lines = lines[:insert_after_line_index + 1]
         # Если мы вставляем перед первым тестом, то старые тесты нам не нужны
        if insert_after_line_index + 1 < len(lines) and lines[insert_after_line_index+1].strip().startswith("def test_"):
             pass # Старые тесты будут заменены
        elif first_test_line > 0 : # Если первый тест не в начале, то сохраняем все до него
             header_lines = lines[:first_test_line]


    elif last_import_or_fixture_line > 0:
        # Если тестов нет, но есть импорты/фикстуры, вставляем после них
        insert_after_line_index = last_import_or_fixture_line
        header_lines = lines[:insert_after_line_index + 1]
    else:
        # Если шаблон почти пустой (нет ни тестов, ни значимых импортов)
        # Просто берем все, что есть (может быть копирайт или комментарии)
        header_lines = lines
        insert_after_line_index = len(lines) -1


    # Если в шаблоне вообще не было строк (маловероятно, но возможно)
    if not lines:
        header_lines = ["import pytest", "from pathlib import Path"] # Минимальные необходимые импорты
        insert_after_line_index = len(header_lines) -1


    header = "\n".join(header_lines)
    if not header.strip() and not test_functions_code: # Если и шапка пустая, и тестов нет
        return "" # Не генерировать пустой файл

    # Добавляем пустую строку после шапки, если она не пустая и есть тесты для вставки
    if header.strip() and test_functions_code:
        header += "\n"

    generated_notice = f"# Файл сгенерирован автоматически скриптом generate_course_tests.py\n"
    generated_notice += f"# Курс: {course_name}\n\n"
    
    final_code = generated_notice + header + "\n\n" + "\n\n".join(test_functions_code)
    
    return final_code.strip() + "\n" # Убедимся, что в конце есть одна новая строка

def main():
    """Главная функция для генерации тестов."""
    print(f"Сканирование директории с курсами: {POLYAKOV_KURS_WORK_DIR}")
    
    found_courses_count = 0
    generated_files_count = 0

    for course_dir_item in POLYAKOV_KURS_WORK_DIR.iterdir():
        if course_dir_item.is_dir():
            course_name = course_dir_item.name
            print(f"  Найден курс: {course_name}")
            found_courses_count += 1
            
            # Ищем .kurs.xml файл. Имя файла может быть не точно таким же, как имя папки.
            # Например, папка "arrkum", файл "Массивы.kurs.xml"
            kurs_file: Optional[Path] = None
            possible_kurs_files = list(course_dir_item.glob("*.kurs.xml"))
            if possible_kurs_files:
                kurs_file = possible_kurs_files[0] # Берем первый найденный
                if len(possible_kurs_files) > 1:
                    print(f"    Предупреждение: Найдено несколько .kurs.xml файлов в {course_dir_item}. Используется: {kurs_file.name}")
            
            work_file: Optional[Path] = None
            possible_work_files = list(course_dir_item.glob("*.work.xml"))
            if possible_work_files:
                work_file = possible_work_files[0] # Берем первый найденный
                if len(possible_work_files) > 1:
                    print(f"    Предупреждение: Найдено несколько .work.xml файлов в {course_dir_item}. Используется: {work_file.name}")

            if kurs_file and kurs_file.exists() and work_file and work_file.exists():
                print(f"    Файл описания курса: {kurs_file.name}")
                print(f"    Файл решений: {work_file.name}")
                
                tasks_info = parse_kurs_xml(kurs_file)
                if not tasks_info:
                    print(f"    Предупреждение: Не найдено задач в {kurs_file.name} для курса '{course_name}'. Пропуск.")
                    continue
                    
                solutions = parse_work_xml(work_file, tasks_info)
                # Не будем выводить предупреждение, если нет решений, т.к. parse_work_xml уже это делает
                                    
                tasks_with_solutions: Dict[str, Dict[str,str]] = {}
                for task_id, task_data in tasks_info.items():
                    if task_id in solutions and solutions[task_id]: # Убедимся, что решение не пустое
                        tasks_with_solutions[task_id] = {
                            "name": task_data["name"],
                            "solution": solutions[task_id]
                        }
                    else:
                        print(f"    Предупреждение: Нет решения или оно пустое для задачи '{task_data['name']}' (ID: {task_id}) в курсе '{course_name}'.")

                if not tasks_with_solutions:
                    print(f"    Предупреждение: Нет задач с корректными решениями для генерации тестов в курсе '{course_name}'. Пропуск.")
                    continue

                test_file_name = f"test_{sanitize_filename(course_name)}.py"
                test_file_path = GENERATED_TESTS_DIR / test_file_name
                
                print(f"    Генерация файла теста: {test_file_path}")
                
                test_content = generate_test_file_content(course_name, tasks_with_solutions)
                
                if test_content: # Генерируем файл, только если есть что генерировать
                    with open(test_file_path, "w", encoding="utf-8") as f:
                        f.write(test_content)
                    print(f"    Файл теста {test_file_path.name} успешно сгенерирован.")
                    generated_files_count +=1
                else:
                    print(f"    Предупреждение: Контент для файла теста {test_file_path.name} не был сгенерирован (возможно, из-за отсутствия шаблона или задач).")
                
            else:
                if not (kurs_file and kurs_file.exists()):
                    print(f"    Предупреждение: Файл .kurs.xml не найден в директории {course_dir_item}")
                if not (work_file and work_file.exists()):
                     print(f"    Предупреждение: Файл .work.xml не найден в директории {course_dir_item}")
    
    print(f"\nСканирование завершено. Найдено курсов: {found_courses_count}.")
    print(f"Сгенерировано файлов с тестами: {generated_files_count}.")

if __name__ == "__main__":
    main()

import xml.etree.ElementTree as ET
import re
from pathlib import Path
from typing import Dict, List # Убрал Any и Optional
from datetime import datetime

# Константы
POLYAKOV_KURS_WORK_DIR = Path("c:/Users/Bormotoon/VSCodeProjects/PyRobot/polyakov_kurs_work")
GENERATED_TESTS_DIR = Path("c:/Users/Bormotoon/VSCodeProjects/PyRobot/tests/generated_course_tests")
TEST_TEMPLATE_PATH = Path("c:/Users/Bormotoon/VSCodeProjects/PyRobot/tests/test_polyakov_kum.py")

GENERATED_TESTS_DIR.mkdir(parents=True, exist_ok=True)

def sanitize_filename(name: str) -> str:
    """Очищает имя файла от недопустимых символов."""
    name = re.sub(r'[\/*?:"<>|]',"", name)
    name = name.replace(" ", "_")
    return name

def parse_kurs_xml(kurs_file_path: Path) -> Dict[str, Dict[str, str]]:
    """Парсит .kurs.xml файл и извлекает информацию о задачах."""
    tasks: Dict[str, Dict[str, str]] = {}
    try:
        tree = ET.parse(kurs_file_path)
        root = tree.getroot()
        
        # Пространство имен для атрибутов вроде xml:id
        ns = {'xml': 'http://www.w3.org/XML/1998/namespace'}

        for task_node in root.findall(".//T"): # Ищем все элементы <T>
            task_id = task_node.get(f"{{{ns['xml']}}}id")
            if not task_id: # Пробуем без пространства имен
                task_id = task_node.get("id")

            if task_id:
                # Задачи должны иметь непустой элемент <PROGRAM>
                program_node = task_node.find("PROGRAM")
                if program_node is not None and program_node.text and program_node.text.strip():
                    # Получаем имя задачи
                    task_name_attr = task_node.get(f"{{{ns['xml']}}}name")
                    if not task_name_attr:
                        task_name_attr = task_node.get("name")

                    current_task_name = task_name_attr
                    
                    # Если имя из атрибута отсутствует, слишком общее, или похоже на автогенеренное,
                    # пытаемся извлечь его из <DESC>
                    if not current_task_name or \
                       re.fullmatch(r"\d+-\d+", current_task_name or "") or \
                       (current_task_name or "").startswith("Задача_"):
                        
                        desc_node = task_node.find("DESC")
                        if desc_node is not None and desc_node.text:
                            # Очищаем от HTML тегов (например, <BR>) и берем первую строку/предложение
                            desc_text_cleaned = re.sub('<[^<]+?>', '', desc_node.text.strip())
                            name_from_desc = desc_text_cleaned.split('\\n')[0].split('.')[0].strip()
                            if name_from_desc: # Если удалось что-то извлечь
                                current_task_name = name_from_desc
                    
                    # Если имя все еще не определено, генерируем стандартное
                    if not current_task_name:
                        current_task_name = f"Задача_{task_id}"
                    
                    tasks[task_id] = {"name": current_task_name, "id": task_id}
                # else:
                #     # Элемент <T> с ID, но без <PROGRAM> или с пустым <PROGRAM> - это, скорее всего, раздел, а не задача.
                #     # Либо задача, для которой не указан файл с кодом. Такие пропускаем.
                #     # print(f"DEBUG: Пропускаем узел T с ID {task_id} - нет PROGAM или он пуст.")
                #     pass
            # else:
            #     # Элемент <T> без ID - это точно не задача, которую мы ищем.
            #     # print(f"DEBUG: Пропускаем узел T без ID.")
            #     pass

    except ET.ParseError as e:
        print(f"Ошибка парсинга XML в файле {kurs_file_path}: {e}")
    except Exception as e:
        print(f"Неожиданная ошибка при парсинге {kurs_file_path}: {e}")
    return tasks

def parse_work_xml(work_file_path: Path, tasks_info: Dict[str, Dict[str, str]]) -> Dict[str, str]:
    """Парсит .work.xml файл и извлекает решения для задач."""
    solutions: Dict[str, str] = {}
    try:
        tree = ET.parse(work_file_path)
        root = tree.getroot()
        for task_solution_element in root.findall(".//task_solution"):
            task_id = task_solution_element.get("id")
            if task_id and task_id in tasks_info:
                source_element = task_solution_element.find(".//source")
                if source_element is not None and source_element.text:
                    solution_code = source_element.text.strip()
                    
                    # Корректное удаление обертки КУМИРа
                    # Сначала проверяем более длинную конструкцию с \n, потом с \n
                    # Это на случай, если XML парсер по-разному обрабатывает переносы строк
                    patterns_to_remove_start = [
                        "алг программа\nнач\n", # С литеральным \n
                        "алг программа\nнач\n"   # С реальным \n
                    ]
                    patterns_to_remove_end = [
                        "\nкон", # С литеральным \n
                        "\nкон"   # С реальным \n
                    ]

                    for pattern in patterns_to_remove_start:
                        if solution_code.startswith(pattern):
                            solution_code = solution_code[len(pattern):]
                            break
                    
                    for pattern in patterns_to_remove_end:
                        if solution_code.endswith(pattern):
                            solution_code = solution_code[:-len(pattern)]
                            break
                            
                    solutions[task_id] = solution_code.strip()
                else:
                    print(f"Предупреждение: Не найден или пуст элемент <source> для задачи {task_id} в {work_file_path}")
            elif task_id:
                print(f"Предупреждение: Найдено решение для неизвестной задачи {task_id} в {work_file_path} (отсутствует в .kurs.xml)")

    except ET.ParseError as e:
        print(f"Ошибка парсинга {work_file_path}: {e}")
    return solutions

def generate_test_file_content(course_name: str, tasks_with_solutions: Dict[str, Dict[str, str]]) -> str:
    """Генерирует содержимое файла с pytest-тестами для одного курса."""
    
    try:
        with open(TEST_TEMPLATE_PATH, "r", encoding="utf-8") as f:
            template_content = f.read()
    except FileNotFoundError:
        print(f"Ошибка: Файл шаблона {TEST_TEMPLATE_PATH} не найден.")
        # Возвращаем пустую строку или возбуждаем исключение, чтобы остановить генерацию для этого курса
        return ""


    test_functions_code: List[str] = []
    for task_id, data in tasks_with_solutions.items():
        task_name = data["name"]
        solution_code = data.get("solution", "") # Получаем решение, если оно есть
        
        if not solution_code:
            print(f"Предупреждение: Отсутствует код решения для задачи '{task_name}' (ID: {task_id}) в курсе '{course_name}'. Тест будет пропущен.")
            continue

        escaped_solution_code = solution_code.replace("\\", "\\\\").replace("'", "\'").replace("\n", "\\n").replace('"', '''"''')
        
        test_func_name = f"test_{sanitize_filename(course_name)}_{sanitize_filename(task_name)}_{task_id}"
        temp_kum_file_name = sanitize_filename(f"{course_name}_{task_name}_{task_id}.kum")
        
        test_function = f"""
def {test_func_name}(run_kumir_code_func, tmp_path: Path):
    kumir_code = '''{escaped_solution_code}'''
    file_path = tmp_path / "{temp_kum_file_name}"
    with open(file_path, "w", encoding="utf-8") as f:
        f.write(kumir_code)
    
    result = run_kumir_code_func(str(file_path))
    assert result.return_code == 0, f"Код КуМира завершился с ошибкой: {{result.stderr_output}}\nКод:\n{{kumir_code}}"
"""
        test_functions_code.append(test_function)

    lines = template_content.split('\n')
    insert_after_line_index = -1 

    # Ищем место для вставки: после всех импортов и фикстур, но перед первым тестом
    # Или просто в конец файла, если шаблон пустой или не содержит тестов
    
    last_import_or_fixture_line = 0
    first_test_line = -1

    for i, line in enumerate(lines):
        if line.strip().startswith("import ") or line.strip().startswith("from "):
            last_import_or_fixture_line = i
        if line.strip().startswith("@pytest.fixture"): # Учитываем фикстуры
             # Ищем конец фикстуры (следующая пустая строка или начало def)
            for j in range(i + 1, len(lines)):
                if not lines[j].strip() or lines[j].strip().startswith("def "):
                    last_import_or_fixture_line = j -1 # Конец фикстуры - предыдущая строка
                    break
            else: # Если фикстура идет до конца файла
                last_import_or_fixture_line = len(lines) -1


        if line.strip().startswith("def test_") and first_test_line == -1:
            first_test_line = i
            break # Нашли первый тест, дальше не ищем

    if first_test_line != -1:
        # Если есть тесты, вставляем перед первым из них, но после импортов/фикстур
        insert_after_line_index = max(last_import_or_fixture_line, 0) if first_test_line == 0 else first_test_line -1
        # Берем все до этой точки
        header_lines = lines[:insert_after_line_index + 1]
         # Если мы вставляем перед первым тестом, то старые тесты нам не нужны
        if insert_after_line_index + 1 < len(lines) and lines[insert_after_line_index+1].strip().startswith("def test_"):
             pass # Старые тесты будут заменены
        elif first_test_line > 0 : # Если первый тест не в начале, то сохраняем все до него
             header_lines = lines[:first_test_line]
        else: # Если тестов нет или они в самом начале, берем все до конца импортов/фикстур
            header_lines = lines[:last_import_or_fixture_line + 1]
            
        # Собираем итоговый контент
        # Сначала заголовок (импорты, фикстуры из шаблона)
        # Затем новые сгенерированные тесты
        final_content = "\\n".join(header_lines) + "\\n\\n" + "\\n\\n".join(test_functions_code) + "\\n"
    
    else: # Если в шаблоне вообще нет тестов (def test_)
        # Просто добавляем новые тесты после всех импортов и фикстур
        final_content = "\\n".join(lines[:last_import_or_fixture_line + 1]) + "\\n\\n" + "\\n\\n".join(test_functions_code) + "\\n"

    return final_content

def main():
    """Главная функция для генерации тестов."""
    start_time = datetime.now()
    print(f"[{start_time.strftime('%Y-%m-%d %H:%M:%S')}] Начало генерации тестов...")

    GENERATED_TESTS_DIR.mkdir(parents=True, exist_ok=True) # Убедимся, что директория существует

    course_count = 0
    generated_test_files_count = 0

    for kurs_dir in POLYAKOV_KURS_WORK_DIR.iterdir():
        if kurs_dir.is_dir():
            course_name = kurs_dir.name
            print(f"  Обработка курса: {course_name}")

            kurs_file = kurs_dir / f"{course_name}.kurs.xml" # Ожидаемое имя файла курса
            # Иногда имя файла курса может отличаться от имени директории, например, "Массивы.kurs.xml"
            # Попробуем найти .kurs.xml файл в директории, если стандартное имя не подошло
            if not kurs_file.exists():
                found_kurs_files = list(kurs_dir.glob("*.kurs.xml"))
                if found_kurs_files:
                    kurs_file = found_kurs_files[0] # Берем первый найденный
                else:
                    print(f"    Предупреждение: Не найден .kurs.xml файл для курса {course_name}. Пропускаем.")
                    continue
            
            work_file = kurs_dir / f"Поляков_{course_name}.work.xml" # Ожидаемое имя файла с решениями
            # Аналогично для .work.xml
            if not work_file.exists():
                found_work_files = list(kurs_dir.glob("*.work.xml"))
                if found_work_files:
                    work_file = found_work_files[0]
                else:
                    print(f"    Предупреждение: Не найден .work.xml файл для курса {course_name}. Решения не будут извлечены.")
                    # Продолжаем, даже если нет файла решений, задачи из .kurs.xml все равно могут быть полезны
                    # Но тесты для них не будут содержать эталонного кода.
                    # В generate_test_file_content есть проверка на отсутствие решения.
                    pass # work_file останется None или неверным, parse_work_xml обработает это

            tasks_info = parse_kurs_xml(kurs_file)
            if not tasks_info:
                print(f"    Предупреждение: Не найдено задач в {kurs_file.name} для курса {course_name}. Пропускаем генерацию тестов для этого курса.")
                continue

            solutions: Dict[str, str] = {}
            if work_file and work_file.exists():
                 solutions = parse_work_xml(work_file, tasks_info)
            else:
                print(f"    Информация: Файл решений {work_file.name if work_file else 'не указан'} не найден или не существует. Тесты будут сгенерированы без эталонных решений.")


            tasks_with_solutions: Dict[str, Dict[str, str]] = {}
            for task_id, task_data in tasks_info.items():
                tasks_with_solutions[task_id] = task_data.copy() # Копируем, чтобы не изменять исходный tasks_info
                if task_id in solutions:
                    tasks_with_solutions[task_id]["solution"] = solutions[task_id] # FIX: Исправлено экранирование
                else:
                    # Если решения нет, оставляем поле "solution" отсутствующим или None
                    # Функция generate_test_file_content это обработает
                    print(f"      Информация: Для задачи '{task_data['name']}' (ID: {task_id}) не найдено решение в {work_file.name if work_file else 'файле решений'}.")


            if not any("\"solution\"" in data for data in tasks_with_solutions.values()):
                print(f"    Предупреждение: Для курса {course_name} не найдено ни одного решения для задач. Файл тестов не будет создан.")
                continue

            test_content = generate_test_file_content(course_name, tasks_with_solutions)

            if test_content: # Если контент успешно сгенерирован
                test_file_name = f"test_{sanitize_filename(course_name)}.py"
                test_file_path = GENERATED_TESTS_DIR / test_file_name
                try:
                    with open(test_file_path, "w", encoding="utf-8") as f:
                        f.write(test_content)
                    print(f"    Успешно сгенерирован файл тестов: {test_file_path}")
                    generated_test_files_count += 1
                except IOError as e:
                    print(f"    Ошибка записи файла тестов {test_file_path}: {e}")
            else:
                print(f"    Предупреждение: Контент для файла тестов курса {course_name} не был сгенерирован (возможно, из-за отсутствия шаблона или задач с решениями).")

            course_count += 1
    
    end_time = datetime.now()
    duration = end_time - start_time
    print(f"[{end_time.strftime('%Y-%m-%d %H:%M:%S')}] Генерация тестов завершена.")
    print(f"  Всего обработано курсов: {course_count}")
    print(f"  Сгенерировано файлов с тестами: {generated_test_files_count}")
    print(f"  Затрачено времени: {duration}")

if __name__ == "__main__":
    main()
