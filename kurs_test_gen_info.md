# Анализ содержимого атрибута `prg` из XML-файлов курсов Полякова (`.work.xml`)

Дата анализа: 2025-06-08

Этот документ описывает структуру и полезные элементы, извлекаемые из атрибута `prg` тегов `<USER_PRG>` (или `<TESTED_PRG>`) в файлах `.work.xml`, используемых в курсах К.Ю. Полякова. Понимание этой структуры критично для автоматической генерации тестов.

## 1. Источник данных

Атрибут `prg` тега `<USER_PRG>` (или `<TESTED_PRG>`, они часто идентичны по содержимому `prg`) содержит полный код на языке КуМир. Этот код включает как сам алгоритм, который должен написать ученик (или эталонное решение), так и встроенный блок для автоматического тестирования.

Пример тега:
```xml
<USER_PRG testId="22"
           prg="алг Возвести в квадрат (цел N, аргрез целтаб A[1:N])|@protected&#xa;
дано | Целочисленный массив A[1:N]|@protected&#xa;
надо | Возвести все элементы массива в квадрат.|@protected&#xa;
... (остальной код) ...
|@hidden"
/>
```

## 2. Предварительная обработка строки `prg`

Перед использованием, содержимое атрибута `prg` требует следующей обработки:

1.  **Декодирование HTML-сущностей**:
    *   `&#xa;` преобразуется в символ новой строки (`\\n`).
    *   `&quot;` преобразуется в двойную кавычку (`"`).
    *   Другие HTML-сущности также должны быть декодированы (например, с помощью `html.unescape()` в Python).
2.  **Удаление маркеров защиты/скрытия**:
    *   Строки вида `|@protected` и `|@hidden` необходимо удалить. Они служат для разметки в оригинальной системе КуМир и не являются частью исполняемого кода. Это можно сделать, например, с помощью регулярного выражения `re.sub(r'\|@(protected|hidden)', '', decoded_string)`.

После этих шагов получается чистый, исполняемый код на языке КуМир.

## 3. Структура очищенного КуМир-кода

Обработанный код обычно состоит из нескольких логических блоков (алгоритмов):

### 3.1. Основной алгоритм (задача для ученика)

Это первый алгоритм в коде. Он представляет собой задачу, которую должен решить ученик, или эталонное решение этой задачи.

*   **Сигнатура**: `алг <Название алгоритма> (<параметры>)`
    *   Пример: `алг Возвести в квадрат (цел N, аргрез целтаб A[1:N])`
*   **Секция `дано`**: Описывает входные данные и их предусловия.
    *   Пример: `дано | Целочисленный массив A[1:N]`
*   **Секция `надо`**: Описывает, что должен сделать алгоритм, какова его цель.
    *   Пример: `надо | Возвести все элементы массива в квадрат.`
*   **Тело алгоритма (`нач ... кон`)**: Содержит шаги для решения задачи.

### 3.2. Разделитель

Часто основной алгоритм отделен от блока тестирования одним или несколькими пустыми строками (двойной `\\n\\n`).

### 3.3. Алгоритм `@тестирование` (главный управляющий блок)

Это ключевой блок для автоматической проверки.

*   **Сигнатура**: `алг цел @тестирование` (может быть и без `цел`, просто `алг @тестирование`)
*   **Назначение**:
    1.  Инициализирует и подготавливает тестовые данные (например, массивы с различными значениями и размерами).
    2.  Вызывает **основной алгоритм** (тот, что предназначен для ученика) с этими тестовыми данными.
    3.  Вызывает **эталонный алгоритм** (обычно `__Решение__`, см. ниже) с теми же исходными тестовыми данными.
    4.  Сравнивает результаты работы алгоритма ученика и эталонного алгоритма (с помощью `__Сравнить__`).
    5.  Выводит вердикт.
*   **Ключевой вывод при успехе**: Если все проверки внутри `@тестирование` проходят успешно, алгоритм выводит строку:
    ```
    вывод "Задание зачтено."
    ```
    Эта строка является основным индикатором успешного прохождения теста при автоматизации.
*   **Обработка ошибок**: Если сравнение показывает расхождение, обычно вызывается процедура `__Ошибка__`, которая выводит детализированное сообщение об ошибке.

Пример структуры `@тестирование`:
```kumir
алг цел @тестирование
нач
  // ... подготовка данных (A, A0, B, B0) ...
  __Заполнить__(NA, A, A0, 1, 100)
  __Заполнить__(NB, B, B0, -100, 100)

  // Вызов алгоритма ученика
  Возвести в квадрат (NA, A)
  Возвести в квадрат (NB, B)

  // Вызов эталонного решения для тех же исходных данных
  __Решение__(NA, A0)
  __Решение__(NB, B0)

  // Сравнение результатов
  знач:=__Сравнить__(NA, A, A0)
  если знач = 0 то __Ошибка__(NA, A, A0) все
  // ... (аналогично для B и B0) ...

  // Финальный вердикт
  если знач = 10 то // Обычно 10 означает успех сравнения
    вывод "Задание зачтено."
  все
кон
```

### 3.4. Вспомогательные алгоритмы

Код также содержит ряд вспомогательных процедур и функций, используемых блоком `@тестирование`. Они обычно имеют префикс `__` (два подчеркивания) или помечены как `@hidden`.

*   **`алг __Заполнить__(...)`**: Генерирует и заполняет структуры данных (например, массивы) тестовыми значениями (часто случайными в заданном диапазоне).
*   **`алг цел __Сравнить__(...)`**: Сравнивает две структуры данных (например, два массива). Возвращает определенное значение, сигнализирующее о совпадении (например, `10`) или расхождении (например, `0`).
*   **`алг __Решение__(...)`**: Содержит **эталонное (правильное) решение** задачи. Блок `@тестирование` использует его для проверки корректности работы основного алгоритма.
*   **`алг __Вывод массива__(...)`**: Вспомогательная процедура для печати содержимого массива, часто используется в `__Ошибка__`.
*   **`алг __Ошибка__(...)`**: Вызывается при обнаружении несоответствия. Выводит сообщение об ошибке, а также обычно показывает полученный и ожидаемый результаты.

## 4. Извлечение полезной информации для генерации тестов

Из атрибута `prg` и его родительского тега можно извлечь следующую информацию, критически важную для генерации автоматизированных тестов:

1.  **`testId`**: Уникальный идентификатор задачи. Берется напрямую из атрибута `testId` тега `<USER_PRG>` (например, `testId="22"`).
2.  **Название задачи**: Можно извлечь из сигнатуры основного алгоритма (например, "Возвести в квадрат" из `алг Возвести в квадрат (...)`). Это полезно для именования тестовых функций в pytest, делая их более читаемыми.
3.  **Полный исполняемый код КуМир**: Всё содержимое атрибута `prg` (после очистки и декодирования) представляет собой готовую к запуску программу. Этот код передается интерпретатору КуМир для выполнения.
4.  **Ожидаемый стандартный вывод (stdout) при успехе**: Строка `"Задание зачтено.\\n"`. Если выполнение полного КуМир-кода приводит к такому выводу в stdout, тест считается пройденным.
5.  **Входные данные (stdin)**: Для этих тестов **не требуются**. Блок `@тестирование` сам генерирует все необходимые входные данные для проверяемого алгоритма и для эталонного решения.

## 5. Пример использования для генерации теста (псевдокод)

```
для каждого <USER_PRG> в work_file.xml:
  test_id = USER_PRG.getAttribute("testId")
  raw_kumir_code = USER_PRG.getAttribute("prg")

  cleaned_kumir_code = html.unescape(raw_kumir_code)
  cleaned_kumir_code = remove_markers(cleaned_kumir_code, ["|@protected", "|@hidden"])

  task_name = extract_task_name(cleaned_kumir_code) // Из "алг <Имя> (...)"

  // Создание pytest-теста
  test_function_name = f"test_{course_name}_{sanitize(task_name)}_{test_id}"
  
  // В теле тестовой функции:
  // 1. Записать cleaned_kumir_code во временный .kum файл
  // 2. Выполнить этот .kum файл с помощью интерпретатора КуМир
  // 3. actual_stdout = результат выполнения (stdout)
  // 4. expected_stdout = "Задание зачтено.\\n"
  // 5. assert actual_stdout == expected_stdout
```

Этот подход позволяет создавать надежные тесты, так как они полностью полагаются на встроенную в курс систему проверки.

## 6. Скорректированный подход: Тестирование интерпретатора с использованием эталонных алгоритмов

**Важное замечание**: Основная цель `pytest` тестов — проверка корректности работы **нашего интерпретатора КуМира**, а не просто подтверждение работы встроенных тестов Полякова. Просто запуск всего блока `@тестирование` и проверка вывода `"Задание зачтено.\n"` не даёт детальной информации о том, какая часть интерпретатора могла дать сбой.

**Более правильный подход для тестирования интерпретатора:**

1.  **Извлечение "чистого" эталонного алгоритма**:
    *   Из атрибута `prg` необходимо извлечь только ту часть, которая относится к **эталонному решению задачи**. Обычно это код, содержащийся в алгоритме с именем `__Решение__` (например, `алг __Решение__ (цел N, аргрез целтаб A[1:N]) ... кон`).
    *   Если алгоритма `__Решение__` нет, можно использовать основной алгоритм задачи (первый `алг ... кон` в коде), но `__Решение__` предпочтительнее, так как он явно предназначен быть эталоном.
    *   **Польза**: Этот "чистый" код можно тестировать более изолированно, проверяя, как интерпретатор справляется с конкретными конструкциями языка, использованными в решении.

2.  **Генерация входных данных и определение эталонных выходных данных (в Python)**:
    *   Вместо того чтобы полагаться на КуМировские `__Заполнить__` и `__Сравнить__` из блока `@тестирование`, тестовый фреймворк (Python/pytest) должен сам подготавливать:
        *   **Конкретные входные данные**: Например, для задачи "Возвести в квадрат" это может быть определённый массив (`[2, 3, 4]`) и его размер.
        *   **Эталонные выходные данные**: То, что *наш интерпретатор* должен вывести на `stdout` или какое состояние должны принять переменные *после* выполнения эталонного КуМир-алгоритма с подготовленными входными данными.
    *   **Идеи для тестовых сценариев**: Блок `@тестирование` из `.work.xml` всё ещё может быть полезен как источник идей для тестовых сценариев (например, какие типы данных использовать, какие размеры массивов, какие граничные условия проверить).

3.  **Конструирование тестовой КуМир-программы для `pytest`**:
    *   Для каждого тестового случая в `pytest` необходимо динамически или по шаблону сгенерировать небольшую КуМир-программу, которая:
        1.  Объявляет и инициализирует переменные и структуры данных согласно подготовленным в Python входным данным.
        2.  Включает в себя извлеченный **"чистый" эталонный алгоритм** (например, `__Решение__`).
        3.  Вызывает этот эталонный алгоритм с подготовленными данными.
        4.  Выводит на `stdout` результаты работы алгоритма (например, измененный массив, значение переменной, результат вызова функции), которые затем будут сравниваться с эталонными выходными данными, определёнными в Python.

4.  **Структура `pytest` теста**:
    *   Записать сгенерированную тестовую КуМир-программу во временный `.kum` файл.
    *   Запустить этот `.kum` файл с помощью нашего интерпретатора КуМира.
    *   Сравнить фактический `stdout` (и, возможно, другие наблюдаемые результаты, если интерпретатор позволяет их получить) с ожидаемыми эталонными выходными данными.

**Пример конструирования КуМир-программы для теста "Возвести в квадрат":**

*   **Извлеченный эталонный алгоритм (`__Решение__`)**:
    ```kumir
    алг __Решение__ (цел N_arg, аргрез целтаб A_arg[1:N_arg])
    нач
      цел i_arg
      нц для i_arg от 1 до N_arg 
        A_arg[i_arg]:=A_arg[i_arg]*A_arg[i_arg] 
      кц
    кон
    ```
*   **Тестовый сценарий в Python**:
    *   Вход: `N=3`, массив `A = [2, 5, 7]`
    *   Ожидаемый `stdout`: `"4 25 49 \n"`
*   **Генерируемая `.kum` программа для `pytest`**:
    ```kumir
    алг ГлавныйТест
    нач
      цел N = 3
      целтаб X[1:3]
      X[1]:=2; X[2]:=5; X[3]:=7

      // Вставляем сюда извлеченный эталонный алгоритм
      алг __Решение__ (цел N_arg, аргрез целтаб A_arg[1:N_arg])
      нач
        цел i_arg
        нц для i_arg от 1 до N_arg 
          A_arg[i_arg]:=A_arg[i_arg]*A_arg[i_arg] 
        кц
      кон
      // Конец вставленного алгоритма

      // Вызываем эталонный алгоритм
      __Решение__(N, X)

      // Выводим результат для проверки
      цел k
      нц для k от 1 до N
        вывод X[k], " "
      кц
      вывод нс
    кон
    ```

**Преимущества скорректированного подхода**:
*   **Целенаправленное тестирование интерпретатора**: Тесты проверяют, как интерпретатор обрабатывает конкретные языковые конструкции в контексте эталонных алгоритмов.
*   **Более точная диагностика ошибок**: В случае сбоя легче локализовать проблему в интерпретаторе.
*   **Независимость от сложности блока `@тестирование`**: Нам не нужно полностью полагаться на корректность работы всех вспомогательных функций КуМира из блока `@тестирование` в нашем интерпретаторе, чтобы проверить базовые вещи.

Файлы `.work.xml` остаются ценным источником **эталонных алгоритмов** и **идей для тестовых сценариев**.
